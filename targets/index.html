<!DOCTYPE html>
<html><head>

    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">

    <link rel="canonical" href="https://verified-network-toolchain.github.io/petr4/targets/">

    <title>
        
        Adding a New Target | Petr4
        
    </title>

    
    <link href="https://verified-network-toolchain.github.io/petr4/css/fontawesome.min.css" rel="stylesheet">

    
    <link rel="stylesheet" href="https://verified-network-toolchain.github.io/petr4/css/ace.min.css">

    
    
        
    

</head>
<body><nav class="navbar navbar-expand-lg navbar-dark bg-primary shadow sticky-top" id="navbarMain">
    <div class="container">
        <div>
            <a class="navbar-brand" href="/petr4">
                Petr4
            </a>
        </div>
        
            <button class="navbar-toggler navbar-toggler-right collapsed" type="button" data-toggle="collapse" data-target="#navbarMainCollapse" aria-controls="navbarMainCollapse" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarMainCollapse">
              <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://github.com/verified-network-toolchain/petr4/" >
                                  <i class='fab fa-github'></i> Code
                                </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="https://verified-network-toolchain.github.io/petr4/" >
                                  <i class='fa fa-home'></i> Home
                                </a>
                            </li>
              </ul>
            </div>
    </div>
</nav>
<div class="container-fluid">
            <div class="row">

                <div class="docs-sidenav order-0 col-12 col-md-3 col-lg-2 col-xl-2 position-sticky border-right"><nav class="navbar navbar-expand-md navbar-light pl-0">
    <button class="navbar-toggler navbar-toggler-right collapsed" type="button" data-toggle="collapse" data-target="#sidenav-left-collapse" aria-controls="sidenav-left-collapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

     <div class="collapse navbar-collapse align-items-start flex-column" id="sidenav-left-collapse">
         <ul class="navbar-nav flex-column pt-3">
    <li data-nav-id="/petr4/installation/" class="nav-item my-1
        ">
        
        <a class="nav-link p-0" href="/petr4/installation/"><h6>Installing Petr4</h6></a>
    </li>
    <li data-nav-id="/petr4/claims/" class="nav-item my-1
        ">
        
        <a class="nav-link p-0" href="/petr4/claims/"><h6>Verifying claims from the POPL&#39;21 paper</h6></a>
    </li>
    <li data-nav-id="/petr4/usage/" class="nav-item my-1
        ">
        
        <a class="nav-link p-0" href="/petr4/usage/"><h6>Using Petr4</h6></a>
    </li>
    <li data-nav-id="/petr4/targets/" class="nav-item my-1 parent active
        ">
        
        <a class="nav-link p-0" href="/petr4/targets/"><h6>Adding a New Target</h6></a>
    </li>
    <li data-nav-id="/petr4/contributors/" class="nav-item my-1
        ">
        
        <a class="nav-link p-0" href="/petr4/contributors/"><h6>Contributors</h6></a>
    </li>
        </ul>
    </div>
</nav>


</div>
                <div class="docs-toc large order-lg-2 order-md-0 order-xs-1 col-12 col-lg-2 col-xl-2 position-sticky border-left"><div class="docs-toc">
	<nav id="TableOfContents"></nav>
</div>
</div>
                <div class="main col-12 order-1 col-md-9 col-lg-10 col-xl-8 py-3">
                

<h1>Adding a New Target</h1>

<p class="lead">
    <p>The P4 specification leaves some decisions about program structure and semantics
up to targets. Petr4 is modular in the same way, for two key reasons: it helps
us comply with the specification, and it lets users easily add support for new
targets. This will be useful for anyone interested in using Petr4 to test P4 code
written in an architecture we do not yet support, or those looking to design
a new P4 architecture. Here, we document the process of adding an implementation
of a P4 architecture to our interpreter.</p>
<h2 id="what-is-a-p4-architecture">What is a P4 architecture?</h2>
<p>At surface level, an architecture in P4 provides a collection of <code>extern</code>
functions/datatypes and defines the user-programmable components of its
packet-processing pipeline. However, a closer examination of the the P4
specification reveals that many decisions in the P4 semantics are left up to
targets. The architecture&rsquo;s responsibilities include but are not limited to:</p>
<ul>
<li>
<p>provide static analysis for enforcing target-dependent well-formedness rules</p>
</li>
<li>
<p>define semantics for initializing metadata</p>
</li>
<li>
<p>provide semantics for threading the packet and other metadata through the pipeline</p>
</li>
<li>
<p>define the behavior of reading from uninitialized/invalid headers</p>
</li>
<li>
<p>provide custom table attributes</p>
</li>
<li>
<p>define custom semantics for the invocation/execution of tables</p>
</li>
</ul>
<p>Therefore, an architecture consists of definitions for all of these semantic
concerns. Indeed, many of these components correspond directly to values
required by our signature for a target implementation.</p>
<h2 id="adding-to-our-code">Adding to our code</h2>
<p>The Petr4 interpreter is written as a module functor in the OCaml module system.
Before the interpreter can run at all, a target implementor has to provide an
implementation of the <code>Target</code> module type and instantiate the interpreter with
their target. The specialized module will evaluate programs according to the
semantics of the target.</p>
<p>The signature for the module type <code>Target</code> is given in <code>lib/target.mli</code>. It is
worth noting that there is a large collection of helper functions defined in
<code>target.mli</code> which will be available in the newly implemented target. Our own
implementations of the V1model and eBPF architectures  make use of these. Also
provided by <code>target.mli</code> is the abstract type for the state of the program. An
implementer will be primarily concerned with the functions <code>insert_extern</code> and
<code>find_extern</code>, as they deal with the part of the state which contains all of the
target-provided stateful objects.</p>
<p>We now step through the process of implementing this signature using the example
architecture <code>Very Simple Switch</code> (<code>VSS</code>), a toy architecture that the P4
language specification uses to illustrate the oddities of target-dependent
semantics in P4. For reference, the target description file in the P4 code is
given below:</p>
<pre><code># include &lt;core.p4&gt;

typedef bit&lt;4&gt; PortId;

const PortId REAL_PORT_COUNT = 4w8;

struct InControl {
    PortId inputPort;
}

const PortId RECIRCULATE_IN_PORT = 0xD;
const PortId CPU_IN_PORT = 0xE;

struct OutControl {
    PortId outputPort;
}

const PortId DROP_PORT = 0xF;
const PortId CPU_OUT_PORT = 0xE;
const PortId RECIRCULATE_OUT_PORT = 0xD;

parser Parser&lt;H&gt;(packet_in b, out H parsedHeaders);

control Pipe&lt;H&gt;(inout H headers,
                in error parseError,
                in InControl inCtrl,
                out OutControl outCtrl);

control Deparser&lt;H&gt;(inout H outputHeaders, packet_out b);

package VSS&lt;H&gt;(Parser&lt;H&gt; p,
               Pipe&lt;H&gt; map,
               Deparser&lt;H&gt; d);

extern Checksum16 {
    Checksum16();
    void clear();
    void update&lt;T&gt;(in T data);
    void remove&lt;T&gt;(in T data);
    bit&lt;16&gt; get();
}
</code></pre><p>First, the user must provide the type <code>obj</code>, which will be used to represent
target-provided stateful values. In the case of <code>VSS</code>, only one such data
structure is needed &ndash; the underlying value of the <code>Checksum16</code> extern. Some
other commonly used externs include counter and register arrays, as in <code>V1 Model</code>. The types <code>state</code> and <code>extern</code> are parameterized on the type <code>obj</code> and
should be copied into the implementation as they appear in the signature.</p>
<p>The user must also provide the functions <code>write_header_field</code> and
<code>read_header_field</code>. These functions will be called by the main interpreter when
reading and writing to headers, and they are intended to capture the fact that
the semantics in these cases is left target-dependent by the P4 specification.
However, the abstraction in its current form is not necessarily expressive
enough to capture all possible decisions for header reads and writes. The
average user will likely want to reuse our implementations of these functions in
<code>v1model.ml</code> and <code>ebpf.ml</code>.</p>
<p>The next required value is the <code>eval_extern</code> function. This function takes as
its arguments the name of the extern to evaluate, the envrionment and state, the
type arguments of the extern call (e.g. a concrete value for <code>T</code> in the case of
<code>update</code> and <code>remove</code> in <code>VSS</code> provided by the type checker), and the arguments
paired with their types. For implementation, we may assume that the arguments
are provided in the correct order and that the list is the proper length. The is
also the place where we use the number and types of the arguments to distinguish
between different externs of the same name, as permitted by the P4
specification. Note that in the case of an invocation of an extern function
using dot-notation, e.g. <code>checksum.clear()</code>, the value of <code>checksum</code> will be
available as the addition first argument in the list of arguments. The extern
evaluation should then return as a tuple the updated environment (though most
externs do not change the environment), the update state, a signal (almost
always <code>Continue</code>), and the return value. Implementing the externs will require
some degree of familiarity with our types for values, environments, and states.
Also, note that any mutation of an extern object should be done by updating the
mapping in the state via <code>insert_extern</code>.</p>
<p>The target must also define what meta-data to initialize. Most targets
initialize metadata upon packet ingress for each individual packet, consisting
at least of the port number. The current version of our interpreter takes as
input this port number, and it is provided as an argument to
<code>initialize_metadata</code>. Note that the current architecture is not expressive
enough to capture all values one may wish to include in the metadata, such as
time stamps.</p>
<p>We also include a post-processing step, <code>get_outport</code>, which is intended to
examine the state and environment for the metadata at the end of the
packet-processing pipeline in order to decide on which port number the P4
program has determined the packet should be emitted.</p>
<p>Lastly, the target implementation should provide the function <code>eval_pipeline</code>,
which determines how the components of the main P4 package should interact in
order to process a given packet. The pipeline evaluator takes as inputs the
control-plane configuration, initial environment and state, and the packet,
outputting the updated state, environment, and optional packet (no packet
corresponds to the packet having been dropped). The astute reader will notice
the mysterious final argument of type <code>state apply</code>. This function is the only
piece of the interpreter which we were unable to move into <code>target.ml</code> due to
a circular dependency, so the interpreter passes it to the pipeline evaluator as
an argument. A typical implementation of a pipeline will normally invoke this
apply function on the packet and the other required arguments to the parser(s)
and control(s). Because the target is responsible for providing arguments to its
P4-programmable blocks, this will involve constructing values of our <code>value</code>
type explicitly and loading them into the environment and state. The user should
be careful to choose variable names that will not result in naming conflicts. In
the case of <code>VSS</code>, an implementation will need to pass a packet value and an
uninitialized header to the parser, pass the resulting headers, error, and
metadata to the control, and finally pass the updated packet and metadata to the
deparser, returning the updated state, environment and packet.</p>
<p>The final step is to apply the <code>Corize</code> functor from <code>lib/p4core.ml</code> to your new
target to ensure that it provides the standard operations on packets provided by
the core library in addition to its own externs (this is a single line at the
bottom of your newly implemented target). Then, apply the <code>MakeInterpreter</code>
functor from <code>lib/eval.mli</code> to your corized target in a new line at the bottom
of <code>eval.ml(i)</code> to instantiate the semantics of P4 on your custom interpreter!
This provides you with the library of evaluation functions given in
<code>lib/eval.mli</code> which you may use to process individual packets on custom
control-plane configurations.</p>
<h2 id="supported-architectures">Supported Architectures</h2>
<p>Petr4&rsquo;s implementation currently supports the V1 Model architecture, which is
perhaps the most widely used architecture in P4. It is standard to <code>bmv2</code>, and
much of the benchmark suite from <code>P4c</code> is written in the V1 model. Many of the
standard operations we may expect a network device to perform are expressed in
the V1 model&rsquo;s <code>extern</code> library, and it&rsquo;s pipeline is representative of the
structure of a standard packet-processing pipeline.</p>
<p>We also support the eBPF Filter architecture. This is a much smaller
architecture, with a minimal collection of externs and a pipeline consisting of
only two components. This is supported primarily for proof-of-concept that our
abstraction over targets is powerful enough to describe more than only the V1
model.</p>
<p>The code that implements the externs and the pipelines of the V1 model and the
eBPF filter can be found in <code>lib/v1model.ml</code> and <code>lib/ebpf.ml</code> respectively. The
implementation of <code>ebpf.ml</code> in particular may be a good reference point for
someone seeking to implement their own target.</p>
<h2 id="limitations">Limitations</h2>
<p>There are two main ways in which our current implementation fails to capture the
full expressivity of the P4 abstract machine. First, our implementation has no
support for concurrency, and we only consider single-packet execution with
a mostly static control-plane configuration. Some important externs from the V1
model library that have to do with concurrency and multiple packets (such as
<code>clone</code> and <code>resubmit</code>) are unimplemented in <code>v1model.ml</code>. Second, our
abstraction excludes from consideration some important concerns about
target-dependent semantics in P4. Specifically, while we provide minimal support
for target-dependent decisions about invalid headers, our abstraction is not
expressive enough to describe all possible decisions a target may make about
accessing invalid header fields, header union, uninitialized stack accesses,
etc. We also omit target-dependent table behaviors such as certain table
annotations or custom table attributes.</p>

</p>

<!-- 


<ul class="docs-children list-unstyled">

	
</ul>



 -->


    


                    
                    <div class="row"><div class="position-relative mx-auto col-lg-9">
                          <div class="bg-primary overflow-hidden p-3 mt-5 shadow">

    <h4 class="text-white text-center">Read more</h4>

    <div class="d-flex justify-content-center"><a class="p-1 mr-3 d-inline-block text-white" href="/petr4/usage/" title="Using Petr4"><i class="fas fa-chevron-left p-1"></i>Using Petr4</a>
        <a class="p-1 ml-3 d-inline-block text-white text-right" href="/petr4/contributors/" title="Contributors">Contributors<i class="fas fa-chevron-right p-1"></i></a>
    </div>
</div>


                        </div></div> 

                </div>

            </div> 

        </div> 
<script src="https://verified-network-toolchain.github.io/petr4/lib/jquery.min.js"></script> 
<script src="https://verified-network-toolchain.github.io/petr4/lib/popper.min.js"></script> 

<script src="https://verified-network-toolchain.github.io/petr4/js/bootstrap.min.js"></script> 


<script type="text/javascript" src="/petr4/plugins/lunr.min.js"></script>
<script type="text/javascript" src="/petr4/plugins/auto-complete.js"></script>
<link href="/petr4/plugins/auto-complete.css" rel="stylesheet">
<script type="text/javascript">
  
      var baseurl = "https:\/\/verified-network-toolchain.github.io\/petr4\/";
  
</script>
<script type="text/javascript" src="/petr4/plugins/search.js"></script>


<script type="text/javascript" src="/petr4/plugins/clipboard.js"></script>
<script>
  new ClipboardJS('.btn');
</script>
</body>
</html>
