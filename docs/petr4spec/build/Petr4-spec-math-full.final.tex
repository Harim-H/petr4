% MathMode: full, MathRender: png, MathDpi: 299, MathEmbedLimit: 524288, MathScale: 108, MathBaseline: 0, MathDocClass: [10pt]book, MathImgDir: math, MathLatex: pdflatex, Dvipng: dvipng, Convert: convert, Dvips: dvips, Ps2pdf: ps2pdf
\documentclass[10pt]{book}
% generated by Madoko, version 1.2.3
%mdk-data-line={1}
\newcommand\mdmathmode{full}
\newcommand\mdmathrender{png}
\usepackage[heading-base={2},section-num={false},bib-label={true},fontspec={true}]{madoko2}
\usepackage[top=1in, bottom=1.25in, left=1in, right=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{mathpartir}
\usepackage{amscd}
\usepackage[version=3]{mhchem}
%mdk-data-line={18}

  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

\begin{document}


\begin{mdSnippets}
%mdk-data-line={148}
%mdk-data-line={159}
%mdk-begin-mathdefs
%mdk-data-line={168;ops.tex:1}
%stuff here and there:
\renewcommand{\or}{\ | \ }
\newcommand{\whereBulletIs}{,\textit{ where } \bullet \textit{ is }}
\newcommand{\whereIs}[1]{,\textit{ where } {#1} \textit{ is }}
\newcommand{\where}[1]{,\textit{ where } {#1}}
\newcommand{\textOr}{\textit{ or }}
\newcommand{\numeric}[1]{\mathit{numeric}({#1})}
\newcommand{\error}{\mathit{error}}
\newcommand{\cond}{\mathit{cond}}
\newcommand{\prim}[1]{{#1}^\prime}
\newcommand{\pprim}[1]{{#1}^{\prime\prime}}
\newcommand{\so}[2]{{#1} \Rightarrow {#2}}
\newcommand{\lookupEnv}[1]{\env({#1})}
\newcommand{\emp}{[\ ]}

% separator
\newcommand{\rn}[1]{\TirName{#1}}
\newcommand{\rSep}{\rn{-}}

\newcommand*{\rE}{\rSep\rn{E}}
\newcommand*{\restJ}{\rn{Rest}}

%typing judgments:
\newcommand{\envOne}[2]{\Delta, T, \Gamma \vdash {#1} : {#2}}
\newcommand{\expenv}[4]{\env, \ctxt \vdash {#1} \leadsto {#2}, {#3}, {#4}}
\newcommand{\expenvWithCtxt}[5]{\env, {#1} \vdash {#2} \leadsto {#3}, {#4}, {#5}}
\newcommand{\coerceBinArgsEnv}[3]{\env, \ctxt \vdash {#1} \twoheadrightarrow ({#2}; {#3})}
\newcommand{\binOpEnv}[4]{\env \vdash {#1} \hookrightarrow {#2}, {#3}, {#4}}
\newcommand{\typWellFormed}[1]{\env \vdash {#1}}

%contexts:
\newcommand{\cte}{\mathit{CONSTANT}}

%operators:
\newcommand{\mask}[2]{{#1} \&\&\& {#2}}
\newcommand{\range}[2]{{#1}..{#2}}
\newcommand{\ternary}[3]{{#1} ? {#2} : {#3}}
\newcommand{\errMem}[1]{\mathit{error}.{#1}}
\newcommand{\typMem}[2]{{#1}.{#2}}
\newcommand{\shiftR}{\gg}
\newcommand{\shiftL}{\ll}
\newcommand{\concat}{+\!+\ }
\newcommand{\restOps}{\odot}
\newcommand{\ops}{\odot}
\newcommand{\cast}[2]{({#1}){#2}}
\newcommand{\plusSat}{\vert+\vert}
\newcommand{\subSat}{\vert-\vert}
\newcommand{\bitAnd}{\&}
\newcommand{\bitOr}{\vert}
\newcommand{\bitXor}{\hat{}}
\newcommand{\bitComplement}{\sim}
\renewcommand{\div}{/}
\renewcommand{\mod}{\%}

%metavariables:
\newcommand{\env}{e}
\newcommand{\typ}{t}
\newcommand{\ctxt}{c}
\newcommand{\bool}{b}
\newcommand{\str}{s}
\newcommand{\width}{w}
\newcommand{\val}{v}
\newcommand{\bit}{\mathit{bit}}
\renewcommand{\int}{n}
\newcommand{\bitWidth}[2]{{#1}_{#2}}
\newcommand{\intWidth}[2]{{#1}_{#2}}
\newcommand{\name}{\mathit{name}}
\renewcommand{\array}{a}
\renewcommand{\index}{i}
\newcommand{\arrayAccess}[2]{{#1}[{#2}]}
\newcommand{\size}{n}
\newcommand{\high}{h}
\newcommand{\low}{l}
\newcommand{\bitString}{bs}
\newcommand{\bitStringAccess}[3]{{#1}[{#2}:{#3}]}
\renewcommand{\exp}{\mathit{exp}}
\newcommand{\field}{f}
\renewcommand{\arg}{\mathit{arg}}


%function helpers
\newcommand{\isNumeric}[1]{\mathit{is\_numeric}({#1})}
\newcommand{\isArray}[1]{\mathit{is\_array}({#1})}
\newcommand{\compileTimeEval}[1]{\llbracket{#1}\rrbracket_\env}
\newcommand{\implicitCast}[2]{\mathit{implicit\_cast}({#1},{#2})_\env}
\newcommand{\reduceEnums}[1]{\mathit{reduce\_enums}({#1}.\typ)_\env} 
\newcommand{\inOrLess}[2]{\mathit{in\_or\_directionless}({#1},{#2})}
\newcommand{\typEq}[3]{{#2} ==_{\env,{#1}} {#3}}
\newcommand{\typHasEq}[1]{\mathit{has\_equality}({#1})_\env}
\newcommand{\nonNeg}[1]{\mathit{is\_nonneg\_numeric}({#1})_\env}
\newcommand{\pos}[1]{\mathit{is\_pos\_numeric}({#1})_\env}
\newcommand{\compTimeKnown}[1]{\mathit{compile\_time\_known}({#1})_\env}
\newcommand{\sat}[1]{\mathit{saturate}({#1})_\env}
\newcommand{\trans}[2]{\mathit{translate}({#1})_{\env,{#2}}}
\newcommand{\isValidNestedTyp}[2]{\mathit{is\_valid\_nested\_type}({#1},{#2})_\env}
%{#1} is outer, 2 is inner
\newcommand{\noDup}[1]{\mathit{no\_duplicate}({#1})}
\newcommand{\explicitCastOK}[2]{\mathit{explicit\_cast\_ok} ({#1}, {#2})_\env}

%types:
\newcommand{\bitWidthTyp}[1]{\mathit{bit}<\!{#1}\!>}
\newcommand{\intWidthTyp}[1]{\mathit{int}<\!{#1}\!>}
\newcommand{\boolTyp}{\mathit{bool}}
\newcommand{\stringTyp}{\mathit{string}}
\newcommand{\integerTyp}{\mathit{integer}}
\newcommand{\bitStringTyp}[2]{\mathit{bit[{#1}-{#2}]}}
\newcommand{\intTyp}{\mathit{int}}
\newcommand{\setTyp}[1]{\mathit{set}<\!{#1}\!>}
\newcommand{\errTyp}{\mathit{error}}
\newcommand{\varBitTyp}[1]{\mathit{varbit}<{#1}>}
\newcommand{\matchKindTyp}{\mathit{match\_kind}}
\newcommand{\voidTyp}{\mathit{void}}
\newcommand{\arrayTyp}[2]{{#1}[{#2}]}
\newcommand{\tupleTyp}[2]{<{#1},\ldots,{#2}>}
\newcommand{\listTyp}[2]{[{#1},\ldots,{#2}]}
\newcommand{\enumTyp}{\mathit{enum}\ {\typ}\ {\name}\{\name_1,\ldots,\name_n\}}
\newcommand{\enumTypNoTyp}{\mathit{enum} \ {\name}\{\name_1,\ldots,\name_n\}}
\newcommand{\recordTyp}{\mathit{record}\{\field_1:\typ_1,\ldots,\field_n:\typ_n \}}
\newcommand{\headerUnionTyp}{\mathit{header\_union}\{\field_1:\typ_1,\ldots,\field_n:\typ_n \}}
\newcommand{\headerTyp}{\mathit{header}\{\field_1:\typ_1,\ldots,\field_n:\typ_n \}}
\newcommand{\structTyp}{\mathit{struct}\{\field_1:\typ_1,\ldots,\field_n:\typ_n \}}
\newcommand{\newTypeTyp}[2]{\mathit{type}\ {#1}\ {#2}}

%directions:
\newcommand{\less}{\mathit{directionless}}
\newcommand{\dir}{d}
\renewcommand{\in}{\mathit{in}}
\newcommand{\out}{\mathit{out}}



%mdk-data-line={225}
\begin{mdDisplaySnippet}[fe1cc8d577df4ef72f46fc064ef83d83]%mdk
%mdk-data-line={229}
\begin{mathpar}
  \small

  \inferrule[Bool]
     {}
     {\expenv \bool \bool \boolTyp \less}

  \inferrule[String]
     {}
     {\expenv \str \str \stringTyp \less}

  \inferrule[Integer]
     {}
     {\expenv \int \int \integerTyp \less}

  \inferrule[Bit]
     {}
     {\expenv {\bitWidth \bit \width} {\bitWidth \bit \width} {\bitWidthTyp \width} \less}

  \inferrule[Int]
     {  }
     {\expenv {\intWidth \int \width} {\intWidth \int \width} {\intWidthTyp \width} {\less}}

  \inferrule[Name]
     {\lookupEnv \name = (\typ, \dir)}
     {\expenv \name \name \typ \dir}

  \inferrule[ArrayAccess]
     {\expenv {\array} {\prim \array} {\arrayTyp \typ \size} \dir \\
      \expenv \index {\prim \index} {\prim \typ} {\prim \dir} \\
      \isArray {\arrayTyp \typ \size} \\
      \isNumeric {\prim \typ}}
     {\expenv {\arrayAccess \array \index} {\arrayAccess {\prim \array} {\prim \index}} \typ \dir }

  \inferrule[BitStringAccess]
     {\expenvWithCtxt \cte \high {\prim \high} {\typ_\high} {\dir_\high} \\
      \isNumeric {\typ_\high} \\
      \pprim \high = \compileTimeEval {\prim \high} \\
      \expenvWithCtxt \cte \low {\prim \low} {\typ_\low} {\dir_\low} \\
      \isNumeric {\typ_\low} \\
      \pprim \low = \compileTimeEval {\prim \low} \\
      0 \leq \pprim \low < \width \\
      \pprim l \leq \pprim h < \width \\
      \expenv \bitString {\prim \bitString} \typ \dir \\
      \typ = \intWidthTyp \width \textOr \bitWidthTyp \width}
     {\expenv {\bitStringAccess \bitString \low \high} {\bitStringAccess \bitString {\pprim \low} {\pprim \high}} {\bitStringTyp {\pprim \low} {\pprim \high}} \dir }

  \inferrule[List]
     {1 \leq i \leq n; \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}}
     {\expenv {[\exp_1, \ldots, \exp_n]} {[\exp_1, \ldots, \exp_n]} {[\typ_1, \ldots, \typ_n]} \less }

  \inferrule[Record]
     {1 \leq i \leq n; \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}  }
     {\expenv {\{\field_1 = \exp_1, \ldots, \field_n = \exp_n \}} {\{\field_1 = \prim {\exp_1}, \ldots, \field_n = \prim {\exp_n} \}} {\{\field_1 : \typ_1, \ldots, \field_n : \typ_n \}} \less  }

  \inferrule[LogicalNegation]
     { \expenv \exp {\prim \exp} \boolTyp \dir }
     { \expenv {!\exp} {!\prim \exp} \boolTyp \dir }

  \inferrule[BitwiseComplement]
     { \expenv \exp {\prim \exp} {\bitWidthTyp \width} \dir }
     { \expenv {\bitComplement\!\exp} {\bitComplement\!\prim \exp} {\bitWidthTyp \width} \dir }

  \inferrule[UnaryMinusCTK]
     { \expenv \exp {\prim \exp} \intTyp \dir }
     { \expenv {-\exp} {-\prim \exp} \intTyp \dir }

  \inferrule[UnaryMinus]
     { \expenv \exp {\prim \exp} {\intWidthTyp \width} \dir }
     { \expenv {-\exp} {-\prim \exp} {\intWidthTyp \width} \dir }

  \inferrule[BinaryOps]
     {\coerceBinArgsEnv {\exp_1 \oplus \exp_2} {\prim {\exp_1}} {\prim {\exp_2}} \\
      \binOpEnv {\prim {\exp_1} \oplus \prim {\exp_2}} {\pprim {\exp_1} \oplus \pprim {\exp_2}} \typ \dir }
     { \expenv {\exp_1 \oplus \exp_2} {\prim {\exp_1} \oplus \prim {\exp_2}} \typ \dir }

\end{mathpar}\end{mdDisplaySnippet}%mdk
\begin{mdDisplaySnippet}[2db607e0cdb187183152882fe2bc28f6]%mdk
%mdk-data-line={311}
\begin{mathpar}
  \small

  \inferrule[Cast]
     { \expenv \exp {\exp_1} {\typ_1} \dir \\
       \typ_2 = \sat {\typ_1} \\
       \typ_3 = \trans {\typ_2} {\emp} \\
       \typ_4 = \sat {\typ_3} \\
       \typWellFormed {\typ_3} \\
       \explicitCastOK {\typ_1} {\typ_3}}
     { \expenv {\cast \typ \exp} {\cast {\typ_1} {\exp_1}} {\typ_3} \less  }

  \inferrule[TypeMember]
     {\lookupEnv {\typMem \typ \name} = (\typ, \dir)  }
     {\expenv {\typMem \typ \name} {\typMem \typ \name} \typ \less  }

  \inferrule[ErrorMember]
     {\lookupEnv {\errMem \name} = (\errTyp, \dir)  }
     {\expenv {\errMem \name} {\errMem \name} \errTyp \less  }

  \inferrule[ExpressionMember]
     { blah }
     { blah}

  \inferrule[Ternary]
     {\expenv {\exp_1} {\prim {\exp_1}} \boolTyp {\dir_1} \\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_1} {\dir_2} \\
      \expenv {\exp_3} {\prim {\exp_3}} {\typ_2} {\dir_3}\\
      \typ_1 = \typ_2 \\
      \typ_1 \neq \integerTyp}
     {\expenv {\ternary {\exp_1} {\exp_2} {\exp_3}} {\ternary {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\typ_1} \less }

  \inferrule[FunctionCall]
     { blah }
     { blah }
     % { \expenv {\exp (\typ_1 \arg_1, \ldots, \typ_n \arg_n)}  }

% function type: <return type> <function name>(x1,...,xn) {...}

  \inferrule[NamelessIinstantiation]
     { blah }
     { blah }

  \inferrule[Mask]
     {\expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
      \left( \so {\typ_1 = \typ_2 = \bitWidthTyp \width} {\typ = \bitWidthTyp \width}\right) \\
      \textOr
      \left( \so {\typ_1 = \typ_2 = \integerTyp} {\typ = \integerTyp}\right) \\
      \textOr
      \left( \so {\typ_1 = \bitWidthTyp \width, \typ_2 = \integerTyp} {\typ = \bitWidthTyp \width}\right) \\
      \textOr
      \left( \so {\typ_1 = \integerTyp, \typ_2 = \bitWidthTyp \width} {\typ = \bitWidthTyp \width}\right)
      }
     {\expenv {\mask {\exp_1} {\exp_2}} {\mask {\prim \exp_1} {\prim \exp_2}} {\setTyp \typ} \less  }

  \inferrule[Range]
     { \expenv \low {\prim \low} \typ {\dir_\low} \\
       \expenv \high {\prim \high} \typ {\dir_\high} \\
       \typ_\low = \typ_\high = \bitWidthTyp \width \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expenv {\range \low \high} {\range {\prim \low} {\prim \high}} {\setTyp \typ} \dir }


\end{mathpar}\end{mdDisplaySnippet}%mdk
%mdk-data-line={385}
\begin{mdDisplaySnippet}[03d1c2f3478f5da31720384825562876]%mdk
%mdk-data-line={389}
\begin{mathpar}
  \small

  \inferrule[ShiftRight]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \shiftR \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}}  }

  \inferrule[ShiftLeft]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \shiftL \exp_2} {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}} }

  \inferrule[BitConcatenation]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \concat \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}} }

  \inferrule[Rest]
     { \expenv  {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
       t = \implicitCast {\typ_1} {\typ_2} \\
       {\pprim {\exp_1}} = \cast \typ {\prim {\exp_1}}, {\typ_1}, {\dir_1} \\
       {\pprim {\exp_2}} = \cast \typ {\prim {\exp_2}}, {\typ_2}, {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \restOps \exp_2} {\pprim {\exp_1}} {\pprim {\exp_2}} }

\end{mathpar}\end{mdDisplaySnippet}%mdk
%mdk-data-line={423}
\begin{mdDisplaySnippet}[176d2bc18cc6df3d387fd1049308686d]%mdk
%mdk-data-line={429}
\begin{mathpar}
  \small

  \inferrule[LogicalOps($\ops=\&,\vert$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \boolTyp}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[NumericOps($+, -, *$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \integerTyp \textOr \intWidthTyp \width }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[EqualityChecks($==, !=$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \typEq {\emp} {\typ_1} {\typ_2} \\
       \typHasEq {\typ_1} }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[OpSat($\plusSat,\subSat$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[BitwiseOps($\bitAnd, \bitOr, \bitXor, \bitComplement$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[BitstringConcatenation]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \so {\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2} \textOr \intWidthTyp {\width_2}} {\typ = \bitWidthTyp {\width_1 + \width_2}} \right) \\
       \textOr \left( \so {\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2} \textOr \intWidthTyp {\width_2}} {\typ = \intWidthTyp {\width_1 + \width_2}} \right) }
     { \binOpEnv {\exp_1 \concat \exp_2} {\exp_1 \concat \exp_2} {\typ} \dir }

  \inferrule[ComparisonOps($<, \leq, >, \geq$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \typ_1 = \typ_2 = \integerTyp \right) \\
       \textOr \left( \typ_1 = \typ_2 = \bitWidthTyp \width \right) \\
       \textOr \left( \typ_1 = \typ_2 = \intWidthTyp \width \right)}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[DivOps($\div, \mod$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \so {\typ_1 = \typ_2 = \integerTyp, \nonNeg {\exp_1}, \pos {\exp_2}}  {\typ = \integerTyp} \right) \\
       \textOr \left( \so {\typ_1 = \typ_2 = \bitWidthTyp \width, \nonNeg {\exp_1}, \pos {\exp_2}}  {\typ = \bitWidthTyp \width} \right) }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \typ \dir }

  \inferrule[ShiftOps($\shiftL,\shiftR$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \nonNeg {\exp_2} \\
       \left( \typ_1 = \bitWidthTyp \width \textOr \intWidthTyp \width \right) \\
       \textOr \left( \typ_1 = \integerTyp, \compTimeKnown {\exp_2} \right) }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

\end{mathpar}\end{mdDisplaySnippet}%mdk
%mdk-data-line={508}
\begin{mdDisplaySnippet}[4215fd222c178311bf53c6bb5caebc0d]%mdk
%mdk-data-line={512}
\begin{mathpar}
  \small

  \inferrule[Bool]
     { }
     { \typWellFormed \boolTyp }

  \inferrule[String]
     { }
     { \typWellFormed \stringTyp }

  \inferrule[Integer]
     { }
     { \typWellFormed \integerTyp }

  \inferrule[Int]
     { }
     { \typWellFormed {\intWidthTyp \width} }

  \inferrule[Bit]
     { }
     { \typWellFormed {\bitWidthTyp \width} }

  \inferrule[VarBit]
     { }
     { \typWellFormed {\varBitTyp \width} }

  \inferrule[Error]
     { }
     { \typWellFormed \errTyp}

  \inferrule[Void]
     { }
     { \typWellFormed \voidTyp}

  \inferrule[MatchKind]
     { }
     { \typWellFormed \matchKindTyp}

  \inferrule[Array]
     { \typWellFormed \typ \\
       \isValidNestedTyp {\arrayTyp \typ \size} {\typ}}
     { \typWellFormed {\arrayTyp \typ \size} }

  \inferrule[Tuple]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp {\tupleTyp {\typ_1} {\typ_n}} {\typ_i}}
     { \typWellFormed {\tupleTyp {\typ_1} {\typ_n}} }

  \inferrule[List]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp {\listTyp {\typ_1} {\typ_n}} {\typ_i}}
     { \typWellFormed {\listTyp {\typ_1} {\typ_n}} }

  \inferrule[Set]
     { \typWellFormed \typ }
     { \typWellFormed {\setTyp \typ} }

  \inferrule[EnumWithType]
     { \typWellFormed \typ }
     { \typWellFormed \enumTyp }

  \inferrule[EnumWithoutType]
     {  }
     { \typWellFormed \enumTypNoTyp }

  \inferrule[Record]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp \recordTyp {\typ_i} \\
       \noDup {\field_1, \ldots, \field_n}}
     { \typWellFormed \recordTyp }

  \inferrule[HeaderUnion]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp \headerUnionTyp {\typ_i} \\
       \noDup {\field_1, \ldots, \field_n}}
     { \typWellFormed \headerUnionTyp }

  \inferrule[Struct]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp \structTyp {\typ_i} \\
       \noDup {\field_1, \ldots, \field_n}}
     { \typWellFormed \structTyp }

  \inferrule[Header]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp \headerTyp {\typ_i} \\
       \noDup {\field_1, \ldots, \field_n}}
     { \typWellFormed \headerTyp }

  \inferrule[NewType]
     { \typWellFormed \typ }
     { \typWellFormed {\newTypeTyp \typ \name} }

  \inferrule[Specialized]
     { blah }
     { blah }

  \inferrule[Package]
     { blah }
     { blah }

  \inferrule[Control]
     { blah }
     { blah }

  \inferrule[Parser]
     { blah }
     { blah }

  \inferrule[Extern]
     { blah }
     { blah }

  \inferrule[Function]
     { blah }
     { blah }

  \inferrule[Action]
     { blah }
     { blah }

  \inferrule[Constructor]
     { blah }
     { blah }

  \inferrule[Table]
     { blah }
     { blah }

  \inferrule[TypeName]
     { blah }
     { blah }

% is_well_formed_type
\end{mathpar}\end{mdDisplaySnippet}%mdk

\end{mdSnippets}

\end{document}
