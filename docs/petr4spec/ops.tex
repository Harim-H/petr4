%rule names:
\newcommand{\rn}[1]{\TirName{#1}}
\newcommand{\rSep}{\rn{-}}
\newcommand*{\rE}{\rSep\rn{E}}
\newcommand*{\rAE}{\rSep\rn{AE}}
\newcommand*{\rT}{\rSep\rn{T}}
\newcommand*{\rS}{\rSep\rn{S}}
\newcommand*{\rAS}{\rSep\rn{AS}}
\newcommand*{\rD}{\rSep\rn{D}}
\newcommand*{\rAD}{\rSep\rn{AD}}

\newcommand*{\ruleName}{\rn{RuleName}}
\newcommand*{\ruleNameE}{\ruleName\rE}
\newcommand*{\ruleNameAE}{\ruleName\rAE}
\newcommand*{\ruleNameT}{\ruleName\rT}
\newcommand*{\ruleNameS}{\ruleName\rS}
\newcommand*{\ruleNameD}{\ruleName\rD}

\newcommand*{\boolT}{\rn{Bool}\rT}
\newcommand*{\stringT}{\rn{String}\rT}
\newcommand*{\intT}{\rn{(InfinitPrecision)Integer}\rT}
\newcommand*{\varbitT}{\rn{Varbit}\rT}
\newcommand*{\errT}{\rn{Error}\rT}
\newcommand*{\voidT}{\rn{Void}\rT}
\newcommand*{\matchKindT}{\rn{MatchKind}\rT}
\newcommand*{\enumOneT}{\rn{Enum}\rT}
\newcommand*{\intWidthT}{\rn{SignedInt}\rT}
\newcommand*{\bitWidthT}{\rn{BitString(UnsignedInteger)}\rT}
\newcommand*{\arrayT}{\rn{Array}\rT}
\newcommand*{\tupleT}{\rn{Tuple}\rT}
\newcommand*{\setT}{\rn{Set}\rT}
\newcommand*{\enumTwoT}{\rn{SerializableEnum}\rT}
\newcommand*{\recordT}{\rn{Record}\rT}
\newcommand*{\newTypeT}{\rn{NewType(typedef)}\rT}
\newcommand*{\specializedExternT}{\rn{SpecializedType}\rSep\rn{ExternBase}\rT}
\newcommand*{\specializedRestT}{\rn{SpecializedType}\rSep\rn{Rest}\rT}
\newcommand*{\packageT}{\rn{Package}\rT}
\newcommand*{\controlT}{\rn{Control}\rT}
\newcommand*{\externT}{\rn{Extern}\rT}
\newcommand*{\functionT}{\rn{Function}\rT}
\newcommand*{\actionT}{\rn{Action}\rT}
\newcommand*{\constructorT}{\rn{Constructor}\rT}
\newcommand*{\tableT}{\rn{Table}\rT}
\newcommand*{\typeNameT}{\rn{TypeName}\rT}

\newcommand*{\boolE}{\rn{Bool}\rE}
\newcommand*{\stringE}{\rn{String}\rE}
\newcommand*{\integerE}{\rn{Integer}\rE}
\newcommand*{\bitStringE}{\rn{FixedLengthInt}\rE}
\newcommand*{\signedIntE}{\rn{SignedInt}\rE}
\newcommand*{\nameE}{\rn{Name}\rE}
\newcommand*{\arrayAccessE}{\rn{ArrayAccess}\rE}
\newcommand*{\bitStringAccessE}{\rn{BitStringAccess}\rE}
\newcommand*{\listE}{\rn{List}\rE}
%% \newcommand*{\listAltE}{\rn{List}\rSep\rn{Alt}\rE}
\newcommand*{\recordE}{\rn{Record}\rE}
\newcommand*{\logicalNegE}{\rn{LogicalNegation}\rE}
\newcommand*{\bitwiseComplementE}{\rn{BitwiseComplement}\rE}
\newcommand*{\unaryMinusE}{\rn{UnaryMinus}\rE}
\newcommand*{\binaryOpsE}{\rn{BinaryOps}\rE}
\newcommand*{\castE}{\rn{cast}\rE}
\newcommand*{\typeMemE}{\rn{TypeMember}\rE}
\newcommand*{\errMemE}{\rn{ErrorMember}\rE}
\newcommand*{\expMemE}{\rn{ExpressionMember}\rE}
\newcommand*{\ternaryE}{\rn{Ternary}\rE}
\newcommand*{\funcCallE}{\rn{FunctionCall}\rE\rSep\rn{1}}
\newcommand*{\funcCallNoTypeArgE}{\rn{FunctionCall}\rE\rSep\rn{2}}
\newcommand*{\instE}{\rn{Instantiation}\rE}
\newcommand*{\maskE}{\rn{Mask}\rE}
\newcommand*{\rangeE}{\rn{Range}\rE}

\newcommand*{\shiftRAE}{\rn{ShiftRight}\rAE}
\newcommand*{\shiftLAE}{\rn{ShiftLeft}\rAE}
\newcommand*{\bitConcatAE}{\rn{BitConcatenation}\rAE}
\newcommand*{\restAE}{\rn{Rest}\rAE}


%function call helper
\newcommand*{\nameFuncNameE}{\rn{Name}\rSep\rn{Func}\rAE\rSep\rn{1}}
\newcommand*{\nameFuncCountE}{\rn{Name}\rSep\rn{Func}\rAE\rSep\rn{2}}
\newcommand*{\nameActionE}{\rn{Name}\rSep\rn{Action}\rAE}
%% \newcommand*{\nameActionNameE}{\rn{NameExpression}\rSep\rn{ActionType}\rSep\rn{ResolveByName}\rE}
%% \newcommand*{\nameActionCountE}{\rn{NameExpression}\rSep\rn{ActionType}\rSep\rn{ResolveByCount}\rE}
\newcommand*{\expMemExternNameE}{\rn{ExpMem}\rSep\rn{Extern}\rAE\rSep\rn{1}}
\newcommand*{\expMemExternCountE}{\rn{ExpMem}\rSep\rn{Extern}\rAE\rSep\rn{2}}
\newcommand*{\expMemSpcE}{\rn{ExpMem}\rSep\rn{Specialized}\rAE}
%% \newcommand*{\expMemSpcCountE}{\rn{Exp:ExpMem}\rSep\rn{Type:Specialized}\rSep\rn{Resolve:Count}\rE}

\newcommand*{\inferTypeArgAE}{\rn{InferTypeArg}\rAE}

\newcommand*{\assignmentS}{\rn{Assignment}\rS}
\newcommand*{\emptyS}{\rn{Empty}\rS}
\newcommand*{\blockS}{\rn{Block}\rS}
\newcommand*{\returnS}{\rn{Return(inApplyBlockOrAction)}\rS}
\newcommand*{\returnEmpS}{\rn{ReturnEmpty}\rS}
\newcommand*{\returnFuncS}{\rn{Return(inFunction)}\rS}
\newcommand*{\exitS}{\rn{Exit}\rS}
\newcommand*{\ifthenS}{\rn{IfThen}\rS}
\newcommand*{\ifthenelseS}{\rn{IfThenElse}\rS}
\newcommand*{\switchS}{\rn{Switch}\rS}
\newcommand*{\declS}{\rn{Declaration}\rS}

\newcommand*{\constantD}{\rn{Constant}\rD}
\newcommand*{\instantD}{\rn{Instantiation}\rD}
\newcommand*{\parserD}{\rn{Parser}\rD}
\newcommand*{\controlD}{\rn{Control}\rD}
\newcommand*{\funcD}{\rn{Function}\rD}
\newcommand*{\actionD}{\rn{Action}\rD}
\newcommand*{\externFuncD}{\rn{ExternFunction}\rD}
\newcommand*{\varD}{\rn{Variable}\rD}
\newcommand*{\varInitD}{\rn{VariableInit}\rD}
\newcommand*{\valueSetD}{\rn{ValueSet}\rD}
\newcommand*{\tableD}{\rn{Table}\rD}
\newcommand*{\headerD}{\rn{Header}\rD}
\newcommand*{\headerUnionD}{\rn{HeaderUnion}\rD}
\newcommand*{\structD}{\rn{Struct}\rD}
\newcommand*{\errD}{\rn{Error}\rD}
\newcommand*{\matchkindD}{\rn{MatchKind}\rD}
\newcommand*{\enumD}{\rn{Enum}\rD}
\newcommand*{\serEnumD}{\rn{SerializableEnum}\rD}
\newcommand*{\externObjD}{\rn{ExternObject}\rD}
\newcommand*{\typDefD}{\rn{TypeDefinition}\rD}
\newcommand*{\newtypeD}{\rn{NewType}\rD}
\newcommand*{\controlTypD}{\rn{ControlType}\rD}
\newcommand*{\parserTypD}{\rn{ParserType}\rD}
\newcommand*{\packageTypD}{\rn{PackageType}\rD}

%stuff here and there:
%TODO: fix mathit in the followings:
\renewcommand{\or}{\ | \ }
\newcommand{\whereBulletIs}{,\textit{ where } \bullet \textit{ is }}
\newcommand{\whereIs}[1]{,\textit{ where } {#1} \textit{ is }}
\newcommand{\where}[1]{,\textit{ where } {#1}}
\newcommand{\textOr}{\textit{ or }}
\newcommand{\numeric}[1]{\mathit{numeric}({#1})}
\newcommand{\error}{\mathit{error}}
\newcommand{\cond}{\mathit{cond}}
\newcommand{\prim}[1]{{#1}^\prime}
\newcommand{\pprim}[1]{{#1}^{\prime\prime}}
\newcommand{\ppprim}[1]{{#1}^{\prime\prime\prime}}
\newcommand{\so}[2]{{#1} \Rightarrow {#2}}
\newcommand{\lookupEnv}[1]{\env({#1})}
\newcommand{\emp}{[\ ]}
\newcommand{\insertToEnv}[2]{\env, [{#1} : {#2} ]}
\newcommand{\insertToEnvv}[1]{\env, [{#1}]}
\newcommand{\suchThat}[2]{{#1}\ . \ {#2}}
\newcommand{\tr}{\mathsf{true}}
\newcommand{\fl}{\mathsf{false}}

% renew these commands to change the size and indentation of program text
%% \newcommand{\progind}{\parindent}
%% \newcommand{\progfontsize}{\small}
%% \newcommand{\progformat}{}
%% % in-line code
%% \newcommand{\prog}[1]{\textrm{\progfontsize\progformat\texttt{#1}}}
%% \newcommand{\tr}{\prog{true}}
%% \newcommand{\fl}{\prog{false}}

%% \newcommand{\iLeqLeq}[2]{{#1} \leq i \leq {#2}. \ } %TODO: refactor 1 < i < n
%% \newcommand{\iLeqL}[2]{{#1} \leq i < {#2}. \ }
%% \newcommand{\iEqLeq}[2]{{#1} < i \leq {#2}. \ }
%% \newcommand{\iLL}[2]{{#1} < i < {#2}. \ }
%% \newcommand{\leqLeq}[3]{{#1} \leq {#2} \leq {#3}. \ }
%% \newcommand{\leqL}[3]{{#1} \leq {#2} < {#3}. \ }
%% \newcommand{\lLeq}[3]{{#1} < {#2} \leq {#3}. \ }
%% \newcommand{\lL}[3]{{#1} < {#2} < {#3}. \ }
%% \newcommand{\forallcond}[3]{\forall {#1} \in {#2}\ . \ {#3}}

%typing judgments:
\newcommand{\envOne}[2]{\Delta, T, \Gamma \vdash {#1} : {#2}}
\newcommand{\expenv}[4]{\env, \ctxt \vdash {#1} \leadsto {#2}, {#3}, {#4}}
\newcommand{\expenvv}[5]{\env_{#5}, \ctxt_{#5} \vdash {#1} \leadsto {#2}, {#3}, {#4}}
\newcommand{\expenvvv}[3]{{#1}, \ctxt \vdash {#2} \leadsto {#3}}
\newcommand{\expenvWithCtxt}[5]{\env, {#1} \vdash {#2} \leadsto {#3}, {#4}, {#5}}
\newcommand{\coerceBinArgsEnv}[3]{\env, \ctxt \vdash {#1} \twoheadrightarrow ({#2}), ({#3})}
\newcommand{\binOpEnv}[7]{\env \vdash {#1}, ({#4}, {#5}), ({#6}, {#7}) : {#2}, {#3}}
\newcommand{\typWellFormed}[1]{\env \vdash {#1}}
\newcommand{\typNotWellFormed}[1]{\env \nvdash {#1}}
\newcommand{\typWellFormedWithEnv}[2]{{#1} \vdash {#2}}
\newcommand{\typEqEnv}[3]{ {#2} ==_{\env,{#1}} {#3}}
%context. type of expression. type of returned name.exp
\newcommand{\fieldAccessEnv}[4]{\env, {#1} \vdash {#2}, {#3} : {#4}}
\newcommand{\stmtenv}[3]{\env, \ctxt \vdash {#1} \leadsto {#2}, {#3} \dashv \env}
\newcommand{\stmtenvv}[5]{\env_{#1}, \ctxt_{#1} \vdash {#2} \leadsto {#3}, {#4} \dashv \env_{#5}}
\newcommand{\dclenv}[2]{\env, \ctxt \vdash {#1} \leadsto {#2} \dashv \env}
\newcommand{\dclenvv}[4]{\env_{#1}, \ctxt_{#1} \vdash {#2} \leadsto {#3} \dashv \env_{#4}}
\newcommand{\dclenvvv}[4]{\constEnv, \typEnv \vdash {#1} \leadsto {#2} \dashv {#3}, {#4}}
\newcommand{\explCast}[2]{\castenv {e} {#1} {#2}}
\newcommand{\castenv}[3]{\env \vdash {#2} \rightarrow_{#1} {#3}}
\newcommand{\implCast}[2]{\castenv {i} {#1} {#2}}
%exp, args. exp', type pars, pars, kind, return type.
%check if you need the dir to be returned as well. 
\newcommand{\resolveFuncOver}[7]{\env, \ctxt \vdash {#1}, {#2} \twoheadrightarrow {#3}, {#4}, {#5}, {#6}, {#7}}
%typ par : typ arg. par = exp. . typ par : typ arg (infered).
% this has an extra input in code (which is constraints (init to typ par : typ arg)) but it's never used so i dropped it. same for return type.
\newcommand{\inferTypParArg}[3]{\env, \ctxt \vdash {#1}, {#2} \mapsto {#3}}
\newcommand{\unify}[6]{{#1}, {#2}, {#3} \vDash {#4} \Join {#5} \mapsto {#6}}


%contexts:
\newcommand{\cte}{\mathfrak{constant}}
\newcommand{\applyBlockCtxt}{\mathfrak{applyBlock}}
\newcommand{\actionCtxt}{\mathfrak{action}}
\newcommand{\tableActionCtxt}{\mathfrak{tableAction}}
\newcommand{\funcCtxt}[1]{\mathfrak{function}\ {#1}}
\newcommand{\parserCtxt}{\mathfrak{parserState}}
\newcommand{\toplevel}{\mathfrak{topLevel}}
\newcommand{\declLocalCtxt}{\mathfrak{declLocal}}

%operators:
\newcommand{\mask}[2]{{#1}\ \&\&\&\ {#2}}
\newcommand{\range}[2]{{#1}..{#2}}
\newcommand{\ternary}[3]{{#1}\ ?\ {#2}\ : \ {#3}}
\newcommand{\errMem}[1]{\mathsf{error}.{#1}}
\newcommand{\typMem}[2]{{#1}.{#2}}
\newcommand{\shiftR}{\gg}
\newcommand{\shiftL}{\ll}
\newcommand{\concat}{+\!+\ }
\newcommand{\restOps}{\odot}
\newcommand{\ops}{\odot}
\newcommand{\cast}[2]{({#1}){#2}}
\newcommand{\plusSat}{\vert+\vert}
\newcommand{\subSat}{\vert-\vert}
\newcommand{\bitAnd}{\&}
\newcommand{\bitOr}{\vert}
\newcommand{\bitXor}{\hat{}}
\newcommand{\bitComplement}{\sim}
\renewcommand{\div}{/}
\renewcommand{\mod}{\%}
\newcommand{\funcCall}[3]{{#1}\langle{#2}\rangle({#3})}
\newcommand{\funcCallNoTypArgs}[2]{{#1}({#2})}
\newcommand{\expMem}[2]{{#1}.{#2}}
\newcommand{\instantiation}[2]{{#1}({#2})}
\newcommand{\assign}[2]{{#1}={#2}}
\newcommand{\noop}{;}
\newcommand{\return}[1]{\mathsf{return}\ {#1}}
\newcommand{\exit}{\mathit{exit}}
\newcommand{\switch}[2]{\mathit{switch}\ ({#1}) \{{#2}\}}
\newcommand{\lbl}{l}
\newcommand{\actionCase}[1]{\lbl : \block {#1}}
\newcommand{\const}[3]{\mathit{const}\ {#1}\ {#2} := {#3}}
\newcommand{\inst}[4]{{#1} ({#2}) {#3} \{{#4}\}}
\newcommand{\varDecl}[2]{{#1}\ {#2}}
\newcommand{\varInit}[3]{{#1}\ {#2} := {#3}}
%name.
%% \newcommand{\parserDecl}[]{\mathit{parser}\ {#1} (type_param param) {const_param locals states}
\renewcommand{\list}[1]{\{{#1}\}}
%% \newcommand{\record}[2]{\{\field_{#1} = \exp_{#1}, \ldots, \field_{#2} = \exp_{#2}\}}
\newcommand{\recordd}[3]{\{\field_{#1} = {#3}_{#1}, \ldots, \field_{#2} = {#3}_{#2}\}}
\newcommand{\record}[2]{\recordd {#1} {#2} {\exp} }
\newcommand{\records}[1]{\{\overline {\field = {#1}} \}}


%metavariables:
\newcommand{\constraint}{C}
\newcommand{\optConstraint}{B}
\newcommand{\nonoptConstraint}{N}
\newcommand{\typeEqs}{\Delta}
\newcommand{\anyTyp}{a}
\newcommand{\env}{\Gamma}
\newcommand{\typEnv}{\Gamma}
\newcommand{\constEnv}{\Sigma}
\newcommand{\typ}{\tau}
\newcommand{\typs}{\overline \typ}
\newcommand{\ctxt}{c}
\newcommand{\bool}{b}
\newcommand{\str}{s}
\newcommand{\width}{w}
\newcommand{\val}{v}
\newcommand{\bit}{b}
\renewcommand{\int}{n}
\newcommand{\bitWidth}[2]{{#1}_{#2}}
\newcommand{\intWidth}[2]{{#1}_{#2}}
\newcommand{\name}{x}
\newcommand{\var}{x}
\newcommand{\typVar}{X}
\newcommand{\typVars}{\overline \typVar}
%% \renewcommand{\array}{a}
%% \renewcommand{\index}{i}
\newcommand{\arrayAccess}[2]{{#1}[{#2}]}
\newcommand{\size}{n}
\newcommand{\high}{h}
\newcommand{\low}{l}
\newcommand{\bitString}{bs}
\newcommand{\bitStringAccess}[3]{{#1}[{#2}:{#3}]}
\renewcommand{\exp}{\mathit{exp}}
\newcommand{\exps}{\overline {\exp}}
\newcommand{\field}{f}
\newcommand{\fields}{\overline \field}
\newcommand{\param}{x}
\newcommand{\params}{\overline x}
\newcommand{\prm}[1]{\dir_{#1} \ \typ_{#1}\  \param_{#1}}
\newcommand{\singleprm}{\dir \ \typ \ \param}
\newcommand{\prms}{\overline {\singleprm}}
\newcommand{\prmss}{\overline {\prim \dir \ \prim \typ \ \prim \param}}
\newcommand{\typParam}{\typVar}
\newcommand{\typParams}{\overline \typParam}
\newcommand{\pari}[1]{\dir_{#1} \typ_{#1} \typParam_{#1}}
\newcommand{\pars}[2]{\pari {#1}, \ldots, \pari {#2}}
\newcommand{\wildcardParam}{w}
\newcommand{\wildcardParams}{\overline \wildcardParam}
\renewcommand{\arg}{\mathit{arg}}
\newcommand{\args}{\overline \arg}
\newcommand{\stmt}{\mathit{stmt}}
\newcommand{\stmts}{\overline \stmt}
\newcommand{\block}[1]{\{ {#1} \}}
\newcommand{\ifthen}[2]{\mathsf{if}\ {#1}\ \mathsf{then}\ {#2}}
\newcommand{\ifthenelse}[3]{\mathsf{if}\ {#1}\ \mathsf{then}\ {#2}\ \mathsf{else}\ {#3}}
\newcommand{\dcl}{\mathit{dcl}}
\newcommand{\kind}{k}
\newcommand{\ret}{\mathit{return}}
\newcommand{\argexp}{\exp}
\newcommand{\argexps}{\overline \argexp}
\newcommand{\argexpi}[1]{\argexp_{#1}}
\newcommand{\argexpss}[2]{\argexpi {#1}, \ldots, \argexpi {#2}}
\newcommand{\argkv}{\var = \exp}
\newcommand{\argkvi}[1]{\var_{#1}=\exp_{#1}}
\newcommand{\argkvs}{\overline \argkv}
\newcommand{\argkvss}[2]{\argkvi {#1}, \ldots, \argkvi {#2}}
\newcommand{\names}{\overline \name}
\newcommand{\methods}[2]{\overline {{#1}:{#2}}}

%function helpers
\newcommand{\mergeConst}[1]{\mathit{merge\_types}({#1})}
\newcommand{\toVoid}[1]{\mathit{voidify}({#1})}
\newcommand{\breakMaybes}[3]{\mathit{break\_option}({#1})=\left({#2},{#3}\right)}
\newcommand{\isExtern}[1]{\mathit{is\_extern}({#1})}
\newcommand{\nothing}{\bot}
\newcommand{\maskTypeIs}[2]{\mathit{mask\_type}({#1},{#2})}
% \typ = \intWidthTyp \width \textOr \bitWidthTyp \width
\newcommand{\widthInt}[1]{\mathit{width\_int}({#1})}
%% - $\bothWidthInt {\typ_1} {\typ_2}$ is a helper function that checks if both types are fixed-length signed or unsigned integers. That is, it checks the conditions below and returns $\tr$ if one of them holds:
%% + $\typ_1 = \typ_2 = \bitWidthTyp \width$
%% + $\typ_1 = \typ_2 = \intWidthTyp \width$
%% \newcommand{\bothWidthInt}[2]{\mathit{both\_width\_int}({#1},{#2})}
%\typ = {\bitWidthTyp \width} \textOr \intWidthTyp \width \textOr \integerTyp
\newcommand{\isInt}[1]{\mathit{is\_int}({#1})}
% \left( \typ_1 = \typ_2 = \integerTyp \right) \\
% \textOr \left( \prim {\typ_1} = \prim {\typ_2} = \bitWidthTyp \width \right) \\
% \textOr \left( \prim {\typ_1} = \prim {\typ_2} = \intWidthTyp \width \right)
\newcommand{\bothInt}[2]{\mathit{both\_int}({#1},{#2})}
\newcommand{\concatCond}[2]{\mathit{concat\_type}({#1},{#2})}
\newcommand{\divCond}[2]{\mathit{div\_type}({#1},{#2})}
\newcommand{\shiftCond}[2]{\mathit{shift\_condition}({#1},{#2})}
\newcommand{\addTypeEnv}[2]{\typEnv[{#1}:{#2}]}
\newcommand{\addTypEnvv}[1]{\typEnv[{#1}]}
\newcommand{\unionEnv}[2]{{#1}\cup{#2}}
\newcommand{\addConstEnv}[2]{\constEnv[{#1}={#2}]}
\newcommand{\isNumeric}[1]{\mathit{is\_numeric}({#1})}
%% \newcommand{\isArray}[1]{\mathit{is\_array}({#1})}
\newcommand{\getEnum}[1]{\mathit{get\_enum}({#1})}
\newcommand{\isConstant}[1]{\mathit{is\_constant} ({#1})}
\newcommand{\isInstantiation}[1]{\mathit{is\_instantiation} ({#1})}
\newcommand{\isVariable}[1]{\mathit{is\_variable} ({#1})}
\newcommand{\compileTimeEval}[1]{\llbracket{#1}\rrbracket_\env}
\newcommand{\implicitCast}[2]{\mathit{implicit\_cast}({#1},{#2})}
\newcommand{\reduceEnums}[1]{\mathit{reduce\_enums}({#1})_\env} 
\newcommand{\inOrLess}[2]{\mathit{in\_or\_directionless}({#1},{#2})}
%% \newcommand{\typEq}[3]{{#2} ==_{\env,{#1}} {#3}}
\newcommand{\typHasEq}[1]{\mathit{has\_equality}({#1})_\env}
\newcommand{\nonNeg}[1]{\mathit{is\_nonneg\_numeric}({#1})_\env}
\newcommand{\pos}[1]{\mathit{is\_pos\_numeric}({#1})_\env}
\newcommand{\compTimeKnown}[1]{\mathit{compile\_time\_known}({#1})_\env}
\newcommand{\sat}[1]{\mathit{saturate}({#1})_\env}
\newcommand{\trans}[2]{\mathit{translate}({#1})_{\env,{#2}}}
\newcommand{\transMaybe}[1]{\mathit{optional\_translate}({#1})_{\env}}
\newcommand{\isValidNestedTyp}[1]{\mathit{is\_valid\_nested}({#1})_\env}
%{#1} is outer, 2 is inner
\newcommand{\noDup}[1]{\mathit{no\_duplicate}({#1})}
\newcommand{\explicitCastOK}[2]{\explCast {#1} {#2}}
\newcommand{\insertTypVars}[1]{\mathit{insert\_type\_vars}({#1}, \env)}
\newcommand{\getTypeParams}[1]{\mathit{get\_type\_params}({#1})}
\newcommand{\reduce}[1]{\mathit{reduce}({#1})_\env}
\newcommand{\reduceWithEnv}[2]{\mathit{reduce}({#2})_{#1}}
%% \newcommand{\fieldOrMethodTyp}[1]{\mathit{field\_or\_method\_type}({#1})}
\newcommand{\isLval}[1]{\mathit{is\_lvalue}({#1})}
%type. exp. 
\newcommand{\castExpression}[2]{\mathit{cast\_expression}({#1},{#2})}
\newcommand{\ifVoidTyp}[1]{\mathit{if\_void\_type}({#1})}
\newcommand{\allowedTypeForVar}[1]{\mathit{is\_allowed\_type\_for\_variable}({#1})}
\newcommand{\checkParamShadow}[2]{\mathit{check\_parameter\_shadowing}({#1}, {#2})}
\newcommand{\match}[2]{\mathit{match}({#1},{#2})}
%% \newcommand{\zip}[2]{\mathit{zip} ({#1},{#2})}
\newcommand{\matchParArg}[2]{\mathit{macth\_parameter\_argument}({#1},{#2})}
\newcommand{\validatePars}[3]{\mathit{validate\_parameter}({#1})_{{#2},{#3}}}
\newcommand{\maybe}[1]{{#1}_{\bot}}
\newcommand{\castParArg}[1]{\mathit{cast\_parameter\_argument}({#1})}
\newcommand{\callOK}[2]{\mathit{call\_ok}({#1},{#2})}
\newcommand{\removeOptionalPars}[1]{\mathit{remove\_optional\_parameteres}({#1})}
\newcommand{\concatList}[2]{{#1}\ +\!+\ {#2}}
\newcommand{\isDirectionless}[1]{\mathit{is\_directionless}({#1})}
\newcommand{\whatevs}{\_}

%fields 
\newcommand{\isValid}{\mathsf{isValid}}
\newcommand{\apply}{\mathsf{apply}}
\newcommand{\minSizeBits}{\mathsf{minSizeInBits}}
\newcommand{\minSizeBytes}{\mathsf{minSizeInBytes}}
\newcommand{\setValid}{\mathsf{setValid}}
\newcommand{\setInvalid}{\mathsf{setInvalid}}
\newcommand{\pushFront}{\mathsf{push\_front}}
\newcommand{\popFront}{\mathsf{pop\_front}}
\newcommand{\sizeMem}{\mathsf{size}}
\newcommand{\lastIndex}{\mathsf{lastIndex}}
\renewcommand{\next}{\mathsf{next}}
\newcommand{\last}{\mathsf{last}}


%kinds
\newcommand{\builtin}{\mathsf{builtin}}
\newcommand{\actionKind}{\mathsf{action}}
\newcommand{\parserKind}{\mathsf{parser}}
\newcommand{\controlKind}{\mathsf{control}}
\newcommand{\methodKind}{\mathsf{method}}
\newcommand{\externKind}{\mathsf{extern}}
\newcommand{\tableKind}{\mathsf{table}}
\newcommand{\funcKind}{\mathsf{function}}

%keywords
\newcommand{\newtypKey}{\mathsf{newtype}}

%types:
\newcommand{\dontcareTyp}{\mathsf{dont\_care}}
\newcommand{\bitWidthTyp}[1]{\mathsf{bit}\langle{#1}\rangle}
\newcommand{\intWidthTyp}[1]{\mathsf{int}\langle{#1}\rangle}
\newcommand{\boolTyp}{\mathsf{bool}}
\newcommand{\stringTyp}{\mathsf{string}}
\newcommand{\integerTyp}{\mathsf{int}}
\newcommand{\bitStringTyp}[1]{\bitWidthTyp {#1}}
\newcommand{\setTyp}[1]{\mathsf{set}\langle{#1}\rangle}
\newcommand{\errTyp}{\mathsf{error}}
\newcommand{\varBitTyp}[1]{\mathsf{varbit}\langle{#1}\rangle}
\newcommand{\matchKindTyp}{\mathsf{match\_kind}}
\newcommand{\voidTyp}{\mathsf{void}}
\newcommand{\arrayTyp}[2]{{#1}[{#2}]}
\newcommand{\tupleTyp}[2]{\mathsf{tuple}\langle{#1},\ldots,{#2}\rangle}
\newcommand{\tupleTyps}[1]{\mathsf{tuple}\langle{#1}\rangle}
\newcommand{\listTyp}[2]{\tupleTyp {#1} {#2}}
\newcommand{\listTyps}[1]{\tupleTyps {#1}}
\newcommand{\enumTypDef}{\mathsf{enum}\ {\typ}\ {\name}\ \{\names\}}
\newcommand{\enumTyp}[3]{\mathsf{enum}\ {#1}\ {#2}\ \{{#3}\}}
\newcommand{\enumTypNoTypDef}{\mathsf{enum} \ {\name}\ \{\names\}}
\newcommand{\enumTypNoTyp}[2]{\mathsf{enum} \ {#1}\ \{{#2}\}}
\newcommand{\recordTypDef}{\recordTyp 1 n}
\newcommand{\recordTyp}[2]{\{\field_{#1}:\typ_{#1};\ldots;\field_{#2}:\typ_{#2}\}}
\newcommand{\recordTypp}[2]{\{\prim {\field_{#1}}:\prim {\typ_{#1}};\ldots;\prim {\field_{#2}}:\prim {\typ_{#2}}\}}
\newcommand{\recordTyps}{\{\overline {\field : \typ}\}}
\newcommand{\recordTypss}[2]{\{\overline {{#1} : {#2}}\}}
\newcommand{\headerUnionTyp}[2]{\recordTyp {#1} {#2}}
\newcommand{\headerTyp}[2]{\recordTyp {#1} {#2}}
\newcommand{\structTyp}[2]{\recordTyp {#1} {#2}}
\newcommand{\headerTyps}[2]{\recordTypss {#1} {#2}}
\newcommand{\headerTypp}[2]{\recordTypp {#1} {#2}}
\newcommand{\structTypp}[2]{\recordTypp {#1} {#2}}
\newcommand{\structTypDef}{\recordTypDef}
\newcommand{\structTyps}[2]{\recordTypss {#1} {#2}}
%% \newcommand{\headerUnionTyp}{\mathit{header\_union}\{\field_1:\typ_1;\ldots;\field_n:\typ_n \}}
%% \newcommand{\headerTypDef}{\headerTyp 1 n}
%% \newcommand{\headerTyp}[2]{\mathit{header}\{\field_{#1}:\typ_{#1};\ldots;\field_{#2}:\typ_{#2}\}}
%% \newcommand{\headerTypp}[2]{\mathit{header}\{\prim {\field_{#1}}:\prim {\typ_{#1}};\ldots;\prim {\field_{#2}}:\prim {\typ_{#2}}\}}
%% \newcommand{\structTypDef}{\structTyp 1 n}
%% \newcommand{\structTyp}[2]{\mathit{struct}\{\field_{#1}:\typ_{#1};\ldots;\field_{#2}:\typ_{#2}\}}
%% \newcommand{\structTypp}[2]{\mathit{struct}\{\prim {\field_{#1}}:\prim {\typ_{#1}};\ldots;\prim {\field_{#2}}:\prim {\typ_{#2}}\}}
\newcommand{\newTypeTyp}[2]{\newtypKey \ {#1}\ {#2}}
\newcommand{\funcTyp}[3]{\mathsf{function}\ {#1}\ \langle{#2}\rangle ({#3})}
\newcommand{\simpFuncTyp}[2]{{#1} \rightarrow {#2}}
%kind.type param. param. return type. 
\newcommand{\funcType}[4]{\mathsf{function}\ {#1}\ \langle{#2}\rangle ({#3})\rightarrow {#4}}
\newcommand{\constructorTyp}[4]{{#1}\  {#2}\ \langle{#3}\rangle\ ({#4}, \_)}
\newcommand{\externTyp}[1]{\mathsf{extern} \  {#1}}
\newcommand{\spcTyp}[2]{{#1}\langle{#2}\rangle}
\newcommand{\parserTyp}[2]{\mathsf{parser}\langle{#1}\rangle({#2})}
\newcommand{\controlTyp}[2]{\mathsf{control}\langle{#1}\rangle({#2})}
\newcommand{\packageTyp}[3]{\mathsf{package}\langle{#1}\rangle({#2},{#3})}
\newcommand{\actionTyp}[2]{\mathsf{action}(\mathsf{data:}\ {#1},\mathsf{control:}\ {#2})}
\newcommand{\tableTyp}[1]{\mathsf{table}\ {#1}}
\newcommand{\typNameTyp}[1]{\mathsf{type\_name}\ {#1}}
\newcommand{\unitTyp}{()}

%directions:
\newcommand{\less}{\mathsf{directionless}}
\newcommand{\dir}{d}
\newcommand{\dirs}{\overline \dir}
\newcommand{\inDir}{\mathsf{in}}
\newcommand{\out}{\mathsf{out}}
\newcommand{\inout}{\mathsf{in\_out}}
