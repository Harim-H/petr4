%rule names:
\newcommand{\rn}[1]{\TirName{#1}}
\newcommand{\rSep}{\rn{-}}
\newcommand*{\rE}{\rSep\rn{E}}
\newcommand*{\rAE}{\rSep\rn{AE}}
\newcommand*{\rT}{\rSep\rn{T}}
\newcommand*{\rS}{\rSep\rn{S}}
\newcommand*{\rAS}{\rSep\rn{AS}}
\newcommand*{\rD}{\rSep\rn{D}}
\newcommand*{\rAD}{\rSep\rn{AD}}

\newcommand*{\ruleName}{\rn{RuleName}}
\newcommand*{\ruleNameE}{\ruleName\rE}
\newcommand*{\ruleNameAE}{\ruleName\rAE}
\newcommand*{\ruleNameT}{\ruleName\rT}
\newcommand*{\ruleNameS}{\ruleName\rS}
\newcommand*{\ruleNameD}{\ruleName\rD}

\newcommand*{\boolT}{\rn{Bool}\rT}
\newcommand*{\stringT}{\rn{String}\rT}
\newcommand*{\intT}{\rn{(InfinitPrecision)Integer}\rT}
\newcommand*{\varbitT}{\rn{Varbit}\rT}
\newcommand*{\errT}{\rn{Error}\rT}
\newcommand*{\voidT}{\rn{Void}\rT}
\newcommand*{\matchKindT}{\rn{MatchKind}\rT}
\newcommand*{\enumOneT}{\rn{Enum}\rT}
\newcommand*{\intWidthT}{\rn{SignedInt}\rT}
\newcommand*{\bitWidthT}{\rn{BitString(UnsignedInteger)}\rT}
\newcommand*{\arrayT}{\rn{Array}\rT}
\newcommand*{\tupleT}{\rn{Tuple}\rT}
\newcommand*{\setT}{\rn{Set}\rT}
\newcommand*{\enumTwoT}{\rn{SerializableEnum}\rT}
\newcommand*{\recordT}{\rn{Record}\rT}
\newcommand*{\newTypeT}{\rn{NewType(typedef)}\rT}
\newcommand*{\specializedExternT}{\rn{SpecializedType}\rSep\rn{ExternBase}\rT}
\newcommand*{\specializedRestT}{\rn{SpecializedType}\rSep\rn{Rest}\rT}
\newcommand*{\packageT}{\rn{Package}\rT}
\newcommand*{\controlT}{\rn{Control}\rT}
\newcommand*{\externT}{\rn{Extern}\rT}
\newcommand*{\functionT}{\rn{Function}\rT}
\newcommand*{\actionT}{\rn{Action}\rT}
\newcommand*{\constructorT}{\rn{Constructor}\rT}
\newcommand*{\tableT}{\rn{Table}\rT}
\newcommand*{\typeNameT}{\rn{TypeName}\rT}

\newcommand*{\boolE}{\rn{Bool}\rE}
\newcommand*{\stringE}{\rn{String}\rE}
\newcommand*{\integerE}{\rn{Integer}\rE}
\newcommand*{\bitStringE}{\rn{FixedLengthInt}\rE}
\newcommand*{\signedIntE}{\rn{SignedInt}\rE}
\newcommand*{\nameE}{\rn{Name}\rE}
\newcommand*{\arrayAccessE}{\rn{ArrayAccess}\rE}
\newcommand*{\bitStringAccessE}{\rn{BitStringAccess}\rE}
\newcommand*{\listE}{\rn{List}\rE}
\newcommand*{\recordE}{\rn{Record}\rE}
\newcommand*{\logicalNegE}{\rn{LogicalNegation}\rE}
\newcommand*{\bitwiseComplementE}{\rn{BitwiseComplement}\rE}
\newcommand*{\unaryMinusE}{\rn{UnaryMinus}\rE}
\newcommand*{\binaryOpsE}{\rn{BinaryOps}\rE}
\newcommand*{\castE}{\rn{cast}\rE}
\newcommand*{\typeMemE}{\rn{TypeMember}\rE}
\newcommand*{\errMemE}{\rn{ErrorMember}\rE}
\newcommand*{\expMemE}{\rn{ExpressionMember}\rE}
\newcommand*{\ternaryE}{\rn{Ternary}\rE}
\newcommand*{\funcCallE}{\rn{FunctionCall}\rE}
\newcommand*{\instE}{\rn{Instantiation}\rE}
\newcommand*{\maskE}{\rn{Mask}\rE}
\newcommand*{\rangeE}{\rn{Range}\rE}

\newcommand*{\shiftRAE}{\rn{ShiftRight}\rAE}
\newcommand*{\shiftLAE}{\rn{ShiftLeft}\rAE}
\newcommand*{\bitConcatAE}{\rn{BitConcatenation}\rAE}
\newcommand*{\restAE}{\rn{Rest}\rAE}


%function call helper
\newcommand*{\nameFuncNameE}{\rn{NameExpression}\rSep\rn{FunctionType}\rSep\rn{ResolveByName}\rE}
\newcommand*{\nameFuncCountE}{\rn{NameExpression}\rSep\rn{FunctionType}\rSep\rn{ResolveByCount}\rE}
\newcommand*{\nameActionE}{\rn{NameExpression}\rSep\rn{ActionType}\rE}
%% \newcommand*{\nameActionNameE}{\rn{NameExpression}\rSep\rn{ActionType}\rSep\rn{ResolveByName}\rE}
%% \newcommand*{\nameActionCountE}{\rn{NameExpression}\rSep\rn{ActionType}\rSep\rn{ResolveByCount}\rE}
\newcommand*{\expMemFuncNameE}{\rn{ExpMemExpression}\rSep\rn{FunctionType}\rSep\rn{ResolveByName}\rE}
\newcommand*{\expMemFuncCountE}{\rn{ExpMemExpression}\rSep\rn{FunctionType}\rSep\rn{ResolveByCount}\rE}
\newcommand*{\expMemActionNameE}{\rn{ExpMemExpression}\rSep\rn{ActionType}\rSep\rn{ResolveByName}\rE}
\newcommand*{\expMemActionCountE}{\rn{ExpMemExpression}\rSep\rn{ActionType}\rSep\rn{ResolveByCount}\rE}

%stuff here and there:
\renewcommand{\or}{\ | \ }
\newcommand{\whereBulletIs}{,\textit{ where } \bullet \textit{ is }}
\newcommand{\whereIs}[1]{,\textit{ where } {#1} \textit{ is }}
\newcommand{\where}[1]{,\textit{ where } {#1}}
\newcommand{\textOr}{\textit{ or }}
\newcommand{\numeric}[1]{\mathit{numeric}({#1})}
\newcommand{\error}{\mathit{error}}
\newcommand{\cond}{\mathit{cond}}
\newcommand{\prim}[1]{{#1}^\prime}
\newcommand{\pprim}[1]{{#1}^{\prime\prime}}
\newcommand{\ppprim}[1]{{#1}^{\prime\prime\prime}}
\newcommand{\so}[2]{{#1} \Rightarrow {#2}}
\newcommand{\lookupEnv}[1]{\env({#1})}
\newcommand{\emp}{[\ ]}
\newcommand{\insertToEnv}[2]{\env, [{#1} : {#2} ]}
\newcommand{\insertToEnvv}[1]{\env, [{#1}]}

%typing judgments:
\newcommand{\envOne}[2]{\Delta, T, \Gamma \vdash {#1} : {#2}}
\newcommand{\expenv}[4]{\env, \ctxt \vdash {#1} \leadsto {#2}, {#3}, {#4}}
\newcommand{\expenvv}[5]{\env_{#5}, \ctxt_{#5} \vdash {#1} \leadsto {#2}, {#3}, {#4}}
\newcommand{\expenvWithCtxt}[5]{\env, {#1} \vdash {#2} \leadsto {#3}, {#4}, {#5}}
\newcommand{\coerceBinArgsEnv}[3]{\env, \ctxt \vdash {#1} \twoheadrightarrow ({#2}; {#3})}
\newcommand{\binOpEnv}[3]{\env \vdash {#1} : {#2}, {#3}}
\newcommand{\typWellFormed}[1]{\env \vdash {#1}}
\newcommand{\typWellFormedWithEnv}[2]{{#1} \vdash {#2}}
\newcommand{\typEqEnv}[2]{\env \vdash {#1}, {#2}}
%context. type of expression. type of returned name.exp
\newcommand{\fieldAccessEnv}[3]{\env, {#1} \vdash \name, {#2} : {#3}}
\newcommand{\stmtenv}[3]{\env, \ctxt \vdash {#1} \leadsto {#2}, {#3} \dashv \env}
\newcommand{\stmtenvv}[5]{\env_{#1}, \ctxt_{#1} \vdash {#2} \leadsto {#3}, {#4} \dashv \env_{#5}}
\newcommand{\dclenv}[2]{\env, \ctxt \vdash {#1} \leadsto {#2} \dashv \env}
\newcommand{\dclenvv}[4]{\env_{#1}, \ctxt_{#1} \vdash {#2} \leadsto {#3} \dashv \env_{#4}}
\newcommand{\dclenvvv}[4]{\constEnv, \typEnv \vdash {#1} \leadsto {#2} \dashv {#3}, {#4}}
\newcommand{\explCast}[2]{\castenv {e} {#1} {#2}}
\newcommand{\castenv}[3]{\env \vdash {#2} \rightarrow_{#1} {#3}}
\newcommand{\implCast}[2]{\castenv {i} {#1} {#2}}
%exp, args. exp', type pars, pars, kind, return type.
%check if you need the dir to be returned as well. 
\newcommand{\resolveFuncOver}[7]{\env, \ctxt \vdash {#1}, {#2} \leadsto {#3}, {#4}, {#5}, {#6}, {#7}}
%return type. typ par : typ arg. par = exp. constraints (init to typ par : typ arg). typ par : typ arg (infered). 
\newcommand{\inferTypParArg}[5]{\env, \ctxt \vdash {#1}, {#2}, {#3}, {#4} \mapsto {#5}}



%contexts:
\newcommand{\cte}{\mathit{CONSTANT}}
\newcommand{\applyBlockCtxt}{\mathit{APPLYBLOCK}}
\newcommand{\actionCtxt}{\mathit{ACTION}}
\newcommand{\funcCtxt}[1]{\mathit{FUNCTION}\ {#1}}
\newcommand{\parserCtxt}{\mathit{PARSERSTATE}}
\newcommand{\toplevel}{\mathit{TOPLEVEL}}

%operators:
\newcommand{\mask}[2]{{#1} \&\&\& {#2}}
\newcommand{\range}[2]{{#1}..{#2}}
\newcommand{\ternary}[3]{{#1} ? {#2} : {#3}}
\newcommand{\errMem}[1]{\mathit{error}.{#1}}
\newcommand{\typMem}[2]{{#1}.{#2}}
\newcommand{\shiftR}{\gg}
\newcommand{\shiftL}{\ll}
\newcommand{\concat}{+\!+\ }
\newcommand{\restOps}{\odot}
\newcommand{\ops}{\odot}
\newcommand{\cast}[2]{({#1}){#2}}
\newcommand{\plusSat}{\vert+\vert}
\newcommand{\subSat}{\vert-\vert}
\newcommand{\bitAnd}{\&}
\newcommand{\bitOr}{\vert}
\newcommand{\bitXor}{\hat{}}
\newcommand{\bitComplement}{\sim}
\renewcommand{\div}{/}
\renewcommand{\mod}{\%}
\newcommand{\funcCall}[3]{{#1}<{#2}>({#3})}
\newcommand{\expMem}[2]{{#1}.{#2}}
\newcommand{\instantiation}[2]{{#1}({#2})}
\newcommand{\assign}[2]{{#1}={#2}}
\newcommand{\noop}{;}
\newcommand{\return}[1]{\mathit{return}\ {#1}}
\newcommand{\exit}{\mathit{exit}}
\newcommand{\switch}[2]{\mathit{switch}\ ({#1}) \{{#2}\}}
\newcommand{\lbl}{l}
\newcommand{\actionCase}[1]{\lbl : \block {#1}}
\newcommand{\const}[3]{\mathit{const}\ {#1}\ {#2} := {#3}}
\newcommand{\inst}[4]{{#1} ({#2}) {#3} \{{#4}\}}
\newcommand{\varDecl}[2]{{#1}\ {#2}}
\newcommand{\varInit}[3]{{#1}\ {#2} := {#3}}
%name.
%% \newcommand{\parserDecl}[]{\mathit{parser}\ {#1} (type_param param) {const_param locals states}
\renewcommand{\list}[1]{\{{#1}\}}
%% \newcommand{\record}[2]{\{\field_{#1} = \exp_{#1}, \ldots, \field_{#2} = \exp_{#2}\}}
\newcommand{\recordd}[3]{\{\field_{#1} = {#3}_{#1}, \ldots, \field_{#2} = {#3}_{#2}\}}
\newcommand{\record}[2]{\recordd {#1} {#2} {\exp} }


%metavariables:
\newcommand{\env}{\Gamma}
\newcommand{\typEnv}{\Gamma}
\newcommand{\constEnv}{\Sigma}
\newcommand{\typ}{\tau}
\newcommand{\typs}{\overline \typ}
\newcommand{\ctxt}{c}
\newcommand{\bool}{b}
\newcommand{\str}{s}
\newcommand{\width}{w}
\newcommand{\val}{v}
\newcommand{\bit}{b}
\renewcommand{\int}{n}
\newcommand{\bitWidth}[2]{{#1}_{#2}}
\newcommand{\intWidth}[2]{{#1}_{#2}}
\newcommand{\name}{x}
\newcommand{\var}{x}
\newcommand{\typVar}{X}
\newcommand{\typVars}{\overline \typVar}
%% \renewcommand{\array}{a}
%% \renewcommand{\index}{i}
\newcommand{\arrayAccess}[2]{{#1}[{#2}]}
\newcommand{\size}{n}
\newcommand{\high}{h}
\newcommand{\low}{l}
\newcommand{\bitString}{bs}
\newcommand{\bitStringAccess}[3]{{#1}[{#2}:{#3}]}
\renewcommand{\exp}{\mathit{exp}}
\newcommand{\field}{f}
\newcommand{\param}{x}
\newcommand{\params}{\overline x}
\newcommand{\prm}[1]{\dir_{#1} \ \typ_{#1}\  \param_{#1}}
\newcommand{\typParam}{\typVar}
\newcommand{\typParams}{\overline \typParam}
\newcommand{\pari}[1]{\dir_{#1} \typ_{#1} \typParam_{#1}}
\newcommand{\pars}[2]{\pari {#1}, \ldots, \pari {#2}}
\newcommand{\wildcardParam}{w}
\newcommand{\wildcardParams}{\overline \wildcardParam}
\renewcommand{\arg}{\mathit{arg}}
\newcommand{\args}{\overline \arg}
\newcommand{\stmt}{\mathit{stmt}}
\newcommand{\stmts}{\overline \stmt}
\newcommand{\block}[1]{\{ {#1} \}}
\newcommand{\ifthen}[2]{\mathit{if}\ {#1}\ \mathit{then}\ {#2}}
\newcommand{\ifthenelse}[3]{\mathit{if}\ {#1}\ \mathit{then}\ {#2}\ \mathit{else}\ {#3}}
\newcommand{\dcl}{\mathit{dcl}}
\newcommand{\kind}{k}
\newcommand{\ret}{\mathit{return}}
\newcommand{\argexp}{\exp}
\newcommand{\argexps}{\overline \argexp}
\newcommand{\argexpi}[1]{\argexp_{#1}}
\newcommand{\argexpss}[2]{\argexpi {#1}, \ldots, \argexpi {#2}}
\newcommand{\argkv}{\var = \exp}
\newcommand{\argkvi}[1]{\var_{#1}=\exp_{#1}}
\newcommand{\argkvs}{\overline \argkv}
\newcommand{\argkvss}[2]{\argkvi {#1}, \ldots, \argkvi {#2}}
\newcommand{\names}{\overline \name}

%function helpers
\newcommand{\addTypeEnv}[2]{\typEnv[{#1}:{#2}]}
\newcommand{\addTypEnvv}[1]{\typEnv[{#1}]}
\newcommand{\addConstEnv}[2]{\constEnv[{#1}={#2}]}
\newcommand{\isNumeric}[1]{\mathit{is\_numeric}({#1})}
%% \newcommand{\isArray}[1]{\mathit{is\_array}({#1})}
\newcommand{\getEnum}[1]{\mathit{get\_enum}({#1})}
\newcommand{\isConstant}[1]{\mathit{is\_constant} ({#1})}
\newcommand{\isInstantiation}[1]{\mathit{is\_instantiation} ({#1})}
\newcommand{\isVariable}[1]{\mathit{is\_variable} ({#1})}
\newcommand{\compileTimeEval}[1]{\llbracket{#1}\rrbracket_\env}
\newcommand{\implicitCast}[2]{\implCast {#1} {#2}}
\newcommand{\reduceEnums}[1]{\mathit{reduce\_enums}({#1}.\typ)_\env} 
\newcommand{\inOrLess}[2]{\mathit{in\_or\_directionless}({#1},{#2})}
\newcommand{\typEq}[3]{{#2} ==_{\env,{#1}} {#3}}
\newcommand{\typHasEq}[1]{\mathit{has\_equality}({#1})_\env}
\newcommand{\nonNeg}[1]{\mathit{is\_nonneg\_numeric}({#1})_\env}
\newcommand{\pos}[1]{\mathit{is\_pos\_numeric}({#1})_\env}
\newcommand{\compTimeKnown}[1]{\mathit{compile\_time\_known}({#1})_\env}
\newcommand{\sat}[1]{\mathit{saturate}({#1})_\env}
\newcommand{\trans}[2]{\mathit{translate}({#1})_{\env,{#2}}}
\newcommand{\isValidNestedTyp}[2]{\mathit{is\_valid\_nested\_type}({#1},{#2})_\env}
%{#1} is outer, 2 is inner
\newcommand{\noDup}[1]{\mathit{no\_duplicate}({#1})}
\newcommand{\explicitCastOK}[2]{\explCast {#1} {#2}}
\newcommand{\insertTypVars}[1]{\mathit{insert\_type\_vars}({#1}, \env)}
\newcommand{\getTypeParams}[1]{\mathit{get\_type\_params}({#1})}
\newcommand{\reduce}[1]{\mathit{reduce}({#1})_\env}
\newcommand{\reduceWithEnv}[2]{\mathit{reduce}({#2})_{#1}}
%% \newcommand{\fieldOrMethodTyp}[1]{\mathit{field\_or\_method\_type}({#1})}
\newcommand{\isLval}[1]{\mathit{is\_lvalue}({#1})}
%type. exp. 
\newcommand{\castExpression}[2]{\mathit{cast\_expression}({#1},{#2})}
\newcommand{\ifVoidTyp}[1]{\mathit{if\_void\_type}({#1})}
\newcommand{\allowedTypeForVar}[1]{\mathit{is\_allowed\_type\_for\_variable}({#1})}
\newcommand{\checkParamShadow}[2]{\mathit{check\_parameter\_shadowing}({#1}, {#2})}
\newcommand{\match}[2]{\mathit{match}({#1},{#2})}
\newcommand{\zip}[2]{\mathit{zip} ({#1},{#2})}
\newcommand{\matchParArg}[2]{\mathit{macth\_parameter\_argument}({#1},{#2})}
\newcommand{\validatePars}[3]{\mathit{validate\_parameter}({#1})_{{#2},{#3}}}
\newcommand{\maybe}[1]{{#1}_{\bot}}
\newcommand{\castParArg}[1]{\mathit{cast\_parameter\_argument}({#1})}
\newcommand{\callOK}[2]{\mathit{call\_ok}({#1},{#2})}
\newcommand{\removeOptionalPars}[1]{\mathit{remove\_optional\_parameteres}({#1})}
\newcommand{\concatList}{++}

%fields 
\newcommand{\isValid}{\mathit{isValid}}
\newcommand{\apply}{\mathit{apply}}
\newcommand{\minSizeBits}{\mathit{minSizeInBits}}
\newcommand{\minSizeBytes}{\mathit{minSizeInBytes}}
\newcommand{\setValid}{\mathit{setValid}}
\newcommand{\setInvalid}{\mathit{setInvalid}}
\newcommand{\pushFront}{\mathit{push\_front}}
\newcommand{\popFront}{\mathit{pop\_front}}
\newcommand{\sizeFlag}{\mathit{size}}
\newcommand{\lastIndex}{\mathit{lastIndex}}
\renewcommand{\next}{\mathit{next}}
\newcommand{\last}{\mathit{last}}


%kinds
\newcommand{\builtin}{\mathit{builtin}}
\newcommand{\actionKind}{\mathit{action}}

%types:
\newcommand{\bitWidthTyp}[1]{\mathit{bit}<\!{#1}\!>}
\newcommand{\intWidthTyp}[1]{\mathit{int}<\!{#1}\!>}
\newcommand{\boolTyp}{\mathit{bool}}
\newcommand{\stringTyp}{\mathit{string}}
\newcommand{\integerTyp}{\mathit{int}}
\newcommand{\bitStringTyp}[1]{\mathit{bit}<{#1}>}
\newcommand{\setTyp}[1]{\mathit{set}<\!{#1}\!>}
\newcommand{\errTyp}{\mathit{error}}
\newcommand{\varBitTyp}[1]{\mathit{varbit}<{#1}>}
\newcommand{\matchKindTyp}{\mathit{match\_kind}}
\newcommand{\voidTyp}{\mathit{void}}
\newcommand{\arrayTyp}[2]{{#1}[{#2}]}
\newcommand{\tupleTyp}[2]{\mathit{tuple}<{#1},\ldots,{#2}>}
\newcommand{\tupleTyps}[1]{\mathit{tuple}<{#1}>}
\newcommand{\listTyp}[2]{\tupleTyp {#1} {#2}}
\newcommand{\listTyps}[1]{\tupleTyps {#1}}
\newcommand{\enumTyp}{\mathit{enum}\ {\typ}\ {\name}\{\name_1,\ldots,\name_n\}}
\newcommand{\enumTypNoTyp}{\mathit{enum} \ {\name}\{\name_1,\ldots,\name_n\}}
\newcommand{\recordTypDef}{\recordTyp 1 n}
\newcommand{\recordTyp}[2]{\{\field_{#1}:\typ_{#1};\ldots;\field_{#2}:\typ_{#2}\}}
\newcommand{\recordTypp}[2]{\{\prim {\field_{#1}}:\prim {\typ_{#1}};\ldots;\prim {\field_{#2}}:\prim {\typ_{#2}}\}}
\newcommand{\headerUnionTyp}[2]{\recordTyp {#1} {#2}}
\newcommand{\headerTyp}[2]{\recordTyp {#1} {#2}}
\newcommand{\structTyp}[2]{\recordTyp {#1} {#2}}
\newcommand{\headerTypp}[2]{\recordTypp {#1} {#2}}
\newcommand{\structTypp}[2]{\recordTypp {#1} {#2}}
\newcommand{\structTypDef}{\recordTypDef}
%% \newcommand{\headerUnionTyp}{\mathit{header\_union}\{\field_1:\typ_1;\ldots;\field_n:\typ_n \}}
%% \newcommand{\headerTypDef}{\headerTyp 1 n}
%% \newcommand{\headerTyp}[2]{\mathit{header}\{\field_{#1}:\typ_{#1};\ldots;\field_{#2}:\typ_{#2}\}}
%% \newcommand{\headerTypp}[2]{\mathit{header}\{\prim {\field_{#1}}:\prim {\typ_{#1}};\ldots;\prim {\field_{#2}}:\prim {\typ_{#2}}\}}
%% \newcommand{\structTypDef}{\structTyp 1 n}
%% \newcommand{\structTyp}[2]{\mathit{struct}\{\field_{#1}:\typ_{#1};\ldots;\field_{#2}:\typ_{#2}\}}
%% \newcommand{\structTypp}[2]{\mathit{struct}\{\prim {\field_{#1}}:\prim {\typ_{#1}};\ldots;\prim {\field_{#2}}:\prim {\typ_{#2}}\}}
\newcommand{\newTypeTyp}[2]{{#1}\ {#2}}
\newcommand{\funcTyp}[3]{\mathit{function}\ {#1}<{#2}> ({#3})}
%kind.type param. param. return type. 
\newcommand{\funcType}[4]{\mathit{function}\ {#1}<{#2}> ({#3})\rightarrow {#4}}
\newcommand{\constructorTyp}[4]{{#1}\  {#2}\ <{#3}>\ ({#4}, \_)}
\newcommand{\externTyp}[1]{\mathit{extern} \  {#1}}
\newcommand{\spcTyp}[2]{{#1}<{#2}>}
\newcommand{\parserTyp}[2]{\mathit{parser}<{#1}>({#2})}
\newcommand{\controlTyp}[2]{\mathit{control}<{#1}>({#2})}
\newcommand{\packageTyp}[3]{\mathit{package}<{#1}>({#2},{#3})}
\newcommand{\actionTyp}[2]{\mathit{action}(\mathit{data:}{#1},\mathit{control:}{#2})}
\newcommand{\tableTyp}[1]{\mathit{table}\ {#1}}
\newcommand{\typNameTyp}[1]{\mathit{type\_name}\ {#1}}
\newcommand{\unitTyp}{()}

%directions:
\newcommand{\less}{\mathit{directionless}}
\newcommand{\dir}{d}
\newcommand{\inDir}{\mathit{in}}
\newcommand{\out}{\mathit{out}}
\newcommand{\inout}{\mathit{in\_out}}
