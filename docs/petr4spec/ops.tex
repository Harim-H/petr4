%stuff here and there:
\renewcommand{\or}{\ | \ }
\newcommand{\whereBulletIs}{,\textit{ where } \bullet \textit{ is }}
\newcommand{\whereIs}[1]{,\textit{ where } {#1} \textit{ is }}
\newcommand{\where}[1]{,\textit{ where } {#1}}
\newcommand{\textOr}{\textit{ or }}
\newcommand{\numeric}[1]{\mathit{numeric}({#1})}
\newcommand{\error}{\mathit{error}}
\newcommand{\cond}{\mathit{cond}}
\newcommand{\prim}[1]{{#1}^\prime}
\newcommand{\pprim}[1]{{#1}^{\prime\prime}}
\newcommand{\so}[2]{{#1} \Rightarrow {#2}}
\newcommand{\lookupEnv}[1]{\env({#1})}
\newcommand{\emp}{[\ ]}

% separator
\newcommand{\rn}[1]{\TirName{#1}}
\newcommand{\rSep}{\rn{-}}

\newcommand*{\rE}{\rSep\rn{E}}
\newcommand*{\restJ}{\rn{Rest}}

%typing judgments:
\newcommand{\envOne}[2]{\Delta, T, \Gamma \vdash {#1} : {#2}}
\newcommand{\expenv}[4]{\env, \ctxt \vdash {#1} \leadsto {#2}, {#3}, {#4}}
\newcommand{\expenvWithCtxt}[5]{\env, {#1} \vdash {#2} \leadsto {#3}, {#4}, {#5}}
\newcommand{\coerceBinArgsEnv}[3]{\env, \ctxt \vdash {#1} \twoheadrightarrow ({#2}; {#3})}
\newcommand{\binOpEnv}[4]{\env \vdash {#1} \hookrightarrow {#2}, {#3}, {#4}}
\newcommand{\typWellFormed}[1]{\env \vdash {#1}}
\newcommand{\typWellFormedWithEnv}[2]{{#1} \vdash {#2}}


%contexts:
\newcommand{\cte}{\mathit{CONSTANT}}

%operators:
\newcommand{\mask}[2]{{#1} \&\&\& {#2}}
\newcommand{\range}[2]{{#1}..{#2}}
\newcommand{\ternary}[3]{{#1} ? {#2} : {#3}}
\newcommand{\errMem}[1]{\mathit{error}.{#1}}
\newcommand{\typMem}[2]{{#1}.{#2}}
\newcommand{\shiftR}{\gg}
\newcommand{\shiftL}{\ll}
\newcommand{\concat}{+\!+\ }
\newcommand{\restOps}{\odot}
\newcommand{\ops}{\odot}
\newcommand{\cast}[2]{({#1}){#2}}
\newcommand{\plusSat}{\vert+\vert}
\newcommand{\subSat}{\vert-\vert}
\newcommand{\bitAnd}{\&}
\newcommand{\bitOr}{\vert}
\newcommand{\bitXor}{\hat{}}
\newcommand{\bitComplement}{\sim}
\renewcommand{\div}{/}
\renewcommand{\mod}{\%}
\newcommand{\funcCall}[]{}

%metavariables:
\newcommand{\env}{e}
\newcommand{\typ}{t}
\newcommand{\ctxt}{c}
\newcommand{\bool}{b}
\newcommand{\str}{s}
\newcommand{\width}{w}
\newcommand{\val}{v}
\newcommand{\bit}{\mathit{bit}}
\renewcommand{\int}{n}
\newcommand{\bitWidth}[2]{{#1}_{#2}}
\newcommand{\intWidth}[2]{{#1}_{#2}}
\newcommand{\name}{\mathit{name}}
\renewcommand{\array}{a}
\renewcommand{\index}{i}
\newcommand{\arrayAccess}[2]{{#1}[{#2}]}
\newcommand{\size}{n}
\newcommand{\high}{h}
\newcommand{\low}{l}
\newcommand{\bitString}{bs}
\newcommand{\bitStringAccess}[3]{{#1}[{#2}:{#3}]}
\renewcommand{\exp}{\mathit{exp}}
\newcommand{\field}{f}
\newcommand{\param}{x}
\newcommand{\parDef}[1]{\dir_{#1} \ \typ_{#1}\  \param_{#1}}
\newcommand{\typParam}{X}
\newcommand{\wildcardParam}{w}


%function helpers
\newcommand{\isNumeric}[1]{\mathit{is\_numeric}({#1})}
\newcommand{\isArray}[1]{\mathit{is\_array}({#1})}
\newcommand{\compileTimeEval}[1]{\llbracket{#1}\rrbracket_\env}
\newcommand{\implicitCast}[2]{\mathit{implicit\_cast}({#1},{#2})_\env}
\newcommand{\reduceEnums}[1]{\mathit{reduce\_enums}({#1}.\typ)_\env} 
\newcommand{\inOrLess}[2]{\mathit{in\_or\_directionless}({#1},{#2})}
\newcommand{\typEq}[3]{{#2} ==_{\env,{#1}} {#3}}
\newcommand{\typHasEq}[1]{\mathit{has\_equality}({#1})_\env}
\newcommand{\nonNeg}[1]{\mathit{is\_nonneg\_numeric}({#1})_\env}
\newcommand{\pos}[1]{\mathit{is\_pos\_numeric}({#1})_\env}
\newcommand{\compTimeKnown}[1]{\mathit{compile\_time\_known}({#1})_\env}
\newcommand{\sat}[1]{\mathit{saturate}({#1})_\env}
\newcommand{\trans}[2]{\mathit{translate}({#1})_{\env,{#2}}}
\newcommand{\isValidNestedTyp}[2]{\mathit{is\_valid\_nested\_type}({#1},{#2})_\env}
%{#1} is outer, 2 is inner
\newcommand{\noDup}[1]{\mathit{no\_duplicate}({#1})}
\newcommand{\explicitCastOK}[2]{\mathit{explicit\_cast\_ok} ({#1}, {#2})_\env}
\newcommand{\insertTypVars}[1]{\mathit{insert\_type\_vars}({#1}, \env)}
\newcommand{\getTypeParams}[1]{\mathit{get\_type\_params}({#1})}

%types:
\newcommand{\bitWidthTyp}[1]{\mathit{bit}<\!{#1}\!>}
\newcommand{\intWidthTyp}[1]{\mathit{int}<\!{#1}\!>}
\newcommand{\boolTyp}{\mathit{bool}}
\newcommand{\stringTyp}{\mathit{string}}
\newcommand{\integerTyp}{\mathit{int}}
\newcommand{\bitStringTyp}[1]{\mathit{bit}<{#1}>}
\newcommand{\setTyp}[1]{\mathit{set}<\!{#1}\!>}
\newcommand{\errTyp}{\mathit{error}}
\newcommand{\varBitTyp}[1]{\mathit{varbit}<{#1}>}
\newcommand{\matchKindTyp}{\mathit{match\_kind}}
\newcommand{\voidTyp}{\mathit{void}}
\newcommand{\arrayTyp}[2]{{#1}[{#2}]}
\newcommand{\tupleTyp}[2]{\mathit{tuple}<{#1},\ldots,{#2}>}
\newcommand{\listTyp}[2]{[{#1},\ldots,{#2}]}
\newcommand{\enumTyp}{\mathit{enum}\ {\typ}\ {\name}\{\name_1,\ldots,\name_n\}}
\newcommand{\enumTypNoTyp}{\mathit{enum} \ {\name}\{\name_1,\ldots,\name_n\}}
\newcommand{\recordTyp}{\mathit{record}\{\field_1:\typ_1;\ldots;\field_n:\typ_n \}}
\newcommand{\headerUnionTyp}{\mathit{header\_union}\{\field_1:\typ_1;\ldots;\field_n:\typ_n \}}
\newcommand{\headerTyp}{\mathit{header}\{\field_1:\typ_1;\ldots;\field_n:\typ_n \}}
\newcommand{\structTyp}{\mathit{struct}\{\field_1:\typ_1;\ldots;\field_n:\typ_n \}}
\newcommand{\newTypeTyp}[2]{\mathit{type}\ {#1}\ {#2}}
\newcommand{\funcTyp}[3]{\mathit{function}\ {#1}<{#2}> ({#3})}
\newcommand{\constructorTyp}[3]{{#1}\  {#2}\  ({#3}, \_)}
\newcommand{\externTyp}[1]{\mathit{extern} \  {#1}}
\newcommand{\spcTyp}[2]{{#1}<{#2}>}
\newcommand{\parserTyp}[2]{\mathit{parser}<{#1}>({#2})}
\newcommand{\controlTyp}[2]{\mathit{control}<{#1}>({#2})}
\newcommand{\packageTyp}[3]{\mathit{package}<{#1}>({#2},{#3})}
\newcommand{\actionTyp}[2]{\mathit{action}(\mathit{data:}{#1},\mathit{control:}{#2})}
\newcommand{\tableTyp}[1]{\mathit{table}\ {#1}}
\newcommand{\typNameTyp}[1]{\mathit{type\_name}\ {#1}}

%directions:
\newcommand{\less}{\mathit{directionless}}
\newcommand{\dir}{d}
\renewcommand{\in}{\mathit{in}}
\newcommand{\out}{\mathit{out}}

