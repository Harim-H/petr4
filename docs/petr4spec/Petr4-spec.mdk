Title : Petr4 Type System Formalization
Title Footer: &date;
Author: Parisa Ataei, Ryan Doenges, Nate Foster
Affiliation: Cornell University
Heading depth: 5
Math Dpi    : 299
Pdf Latex: xelatex
Math Latex Full: pdflatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
MathJax Ext: AMScd
Package: amscd
MathJax Ext : mhchem
Package     : [version=3]mhchem

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

~Aligned : replace:"~Math&nl;\begin{aligned}&nl;&source;&nl;\end{aligned}&nl;~" 


[TITLE]

~ TexRaw
\mdDefineUnicode{10214}{\ensuremath{\llbracket}}
\mdDefineUnicode{10215}{\ensuremath{\rrbracket}}
~

~ Begin Abstract
P4 is a language for programming the data plane of network
devices. Petr4 provides a clean-slate definitional interpreter
and a core calculus that models a fragment of P4. This document
provides a definition of Petr4's type system that is consistent
with its implementation. The target audience of this document
includes developers and debuggers who work on P4 implementations
such as Petr4 and P4C. In essence, this document may be of
interest to programmers who are interested in understanding
the implementation of Petr4 deeply.
~ End Abstract

~ MathDefs
[INCLUDE="ops.tex"]
~

[TOC]

# Overview { #sec-overview }

This document defines the type system of Petr4. The type system
conducts three tasks simultaneously:

1. It type checks P4 programs.
2. It conducts type inference.
3. It does a pass from the surface syntax to the first IR. 


## Connecting To The Implementation { #sec-conn }

The following locates each data type in the implementation
(<https://github.com/verified-network-toolchain/petr4>):

- The surface AST is _types.program_
- The type of programs of the surface syntax is _types.type.t_
- The first IR is _prog.program_
- The type of the first IR is _prog.type.t_

For simplicity, we have removed the information that is needed to report when an error
happens. Such information is passed around in the surface syntax as a field (called
`tags`) of record for all data types.

## Architecture { #sec-arch }

Figure [#fig-arch] depicts part of Petr4's architecture that contains the type system.
After lexing and parsing a P4 program we get a program in our surface syntax. This
program is then passed through the _elaborator_ where type variables are introduced
instead of underscore and new type variable names are generated for variables with the
same name but in different scopes. This document does not discuss the innerworkings of
`elaborate`. Then, the program is passed through the type system (encoded in `checker`).
This document discusses the innerworking of the type system extensively. Finally, the
program is evaluated.

~ Figure { #fig-arch; caption: "Part of Petr4's achitecture." }
![arch]
~
[arch]: figs/petr4/arch.png { width: 100%; page-align: forcehere }

# Type System

some general explanation of the type system and the judgments.

## Expression's Typing Rules
translate typ translate a surface type to the IR's type. we don't present these types
since their difference isn't much.
saturate typ saturates a type. Eliminate all type references in typ and replace them with the type they refer to. The result of saturation will contain no TypeName constructors anywhere. It may contain TypeName constructors.
e(name) looks up name in the environment and returns its type and direction.
is array determines whether a type is an array type.
is numberic determines whether a type is numeric.
compile time evaluation evaluates the expression expr at compile time.
explicit cast ok checks whether typ1 can be converted to typ2 under e based on P4's specification of 8.9.1.â€‚Explicit casts.
reduce takes a type and saturates the type first and returns the base of a specialized type by removing all its type parameters as long as the number of type params and type args match..
fieldOrMethodTyp checks if the type is
1) header, headerunion, or struct. if so checks the name of each field with the name of exprmem and if they're the same returns the field's type. if no field matches (passes to type_expression_member_builtin) takes the type, name, context. if type is an array and name is either size or lastindex it returns the type Bit<32>. if type is an array and name is next or last and context is parser state it returns the initial type passed in. ow. error.
2) if type is specialized with base as an extern, checks the env for the extern name, if it exists, finds the extern method with the name same as expmem name and returns a reduced type of function with that method type. if it doesn't find a method with the same name as expmem uses type_expression_member_builtin. 
3) if type is an extern, converts it to specialized with base as extern and empty args.
4) any other type uses type_epxression_member_builtin.
arg can be exp, key value, or missing.

I couldn't find the followings in section 8 of p4 spec:
array access, bist string access, type member, anonymous instant (this is probably method invocation or sth).

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Bool]
     {}
     {\expenv \bool \bool \boolTyp \less}

  \inferrule[String]
     {}
     {\expenv \str \str \stringTyp \less}

  \inferrule[Integer]
     {}
     {\expenv \int \int \integerTyp \less}

  \inferrule[Bit]
     {}
     {\expenv {\bitWidth \bit \width} {\bitWidth \bit \width} {\bitWidthTyp \width} \less}

  \inferrule[Int]
     {  }
     {\expenv {\intWidth \int \width} {\intWidth \int \width} {\intWidthTyp \width} {\less}}

  \inferrule[Name]
     {\lookupEnv \name = (\typ, \dir)}
     {\expenv \name \name \typ \dir}

  \inferrule[ArrayAccess]
     {\expenv {\array} {\prim \array} {\arrayTyp \typ \size} \dir \\
      \expenv \index {\prim \index} {\prim \typ} {\prim \dir} \\
      \isArray {\arrayTyp \typ \size} \\
      \isNumeric {\prim \typ}}
     {\expenv {\arrayAccess \array \index} {\arrayAccess {\prim \array} {\prim \index}} \typ \dir }

  \inferrule[BitStringAccess]
     {\expenvWithCtxt \cte \high {\prim \high} {\typ_\high} {\dir_\high} \\
      \isNumeric {\typ_\high} \\
      \pprim \high = \compileTimeEval {\prim \high} \\
      \expenvWithCtxt \cte \low {\prim \low} {\typ_\low} {\dir_\low} \\
      \isNumeric {\typ_\low} \\
      \pprim \low = \compileTimeEval {\prim \low} \\
      0 \leq \pprim \low < \width \\
      \pprim l \leq \pprim h < \width \\
      \expenv \bitString {\prim \bitString} \typ \dir \\
      \typ = \intWidthTyp \width \textOr \bitWidthTyp \width}
     {\expenv {\bitStringAccess \bitString \low \high} {\bitStringAccess \bitString {\pprim \low} {\pprim \high}} {\bitStringTyp {\pprim \high - \pprim \low}} \dir }

  \inferrule[List]
     {1 \leq i \leq n; \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}}
     {\expenv {\list {\exp_1, \ldots, \exp_n}} {\list {\exp_1, \ldots, \exp_n}} {\listTyp {\typ_1} {\typ_n}} \less }

  \inferrule[Record]
     {1 \leq i \leq n; \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}  }
     {\expenv {\record 1 n} {\recordd 1 n {\prim \exp}} {\recordTypDef} \less  }

  \inferrule[LogicalNegation]
     { \expenv \exp {\prim \exp} \boolTyp \dir }
     { \expenv {!\exp} {!\prim \exp} \boolTyp \dir }

  \inferrule[BitwiseComplement]
     { \expenv \exp {\prim \exp} \typ  \dir \\
       \typ = {\bitWidthTyp \width} \textOr \intWidthTyp \width}
     { \expenv {\bitComplement\!\exp} {\bitComplement\!\prim \exp} {\typ} \dir }

  \inferrule[UnaryMinus]
     { \expenv \exp {\prim \exp} \typ  \dir \\
       \typ = {\bitWidthTyp \width} \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expenv {-\exp} {-\prim \exp} {\intWidthTyp \width} \dir }

  \inferrule[BinaryOps]
     {\coerceBinArgsEnv {\exp_1 \oplus \exp_2} {\prim {\exp_1}} {\prim {\exp_2}} \\
      \binOpEnv {\prim {\exp_1} \oplus \prim {\exp_2}} {\pprim {\exp_1} \oplus \pprim {\exp_2}} \typ \dir }
     { \expenv {\exp_1 \oplus \exp_2} {\prim {\exp_1} \oplus \prim {\exp_2}} \typ \dir }

\end{mathpar}
~~
~

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Cast]
     { \expenv \exp {\exp_1} {\typ_1} \dir \\
       \typ_2 = \sat {\typ_1} \\
       \typ_3 = \trans {\typ_2} {\emp} \\
       \typ_4 = \sat {\typ_3} \\
       \typWellFormed {\typ_3} \\
       \explicitCastOK {\typ_1} {\typ_3}}
     { \expenv {\cast \typ \exp} {\cast {\typ_1} {\exp_1}} {\typ_3} \less  }

  \inferrule[TypeMember]
     {\lookupEnv {\typMem \typ \name} = (\typ, \dir)  }
     {\expenv {\typMem \typ \name} {\typMem \typ \name} \typ \less  }

  \inferrule[ErrorMember]
     {\lookupEnv {\errMem \name} = (\errTyp, \dir)  }
     {\expenv {\errMem \name} {\errMem \name} \errTyp \less  }

  \inferrule[ExpressionMember-StructOrHeaderOrHeaderUnion]
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \structTypDef = \reduce \typ \\
       % \structTypDef = \prim \typ\\
       \field_{n+1} = \isValid\\
       \exists 1 \leq i \leq n+1; \field_i = \name
       }
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\typ_i} {\less} }

  \inferrule[ExpressionMember-StructOrHeaderOrHeaderUnion-BuiltInMethods]
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \structTypDef = \reduce \typ \\
        % = \prim \typ\\
       \field_{n+1} = \isValid\\
       \fieldAccessEnv {\structTypDef} \name {\prim \typ}
       }
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\prim \typ} {\less} }

  \inferrule[ExpressionMember-Specialized]
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \spcTyp {\externTyp {\prim \name}} {\typs} = \reduce \typ \\
       % names in the following are actually methods. have to see what they contain.
       \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       % \prim \env = \insertToEnv  \typParams \typs \\
       \exists \name_i \in \names; \name_i = \name \\
       \pprim {\typ_i} = \reduceWithEnv {\insertToEnv  \typParams \typs} {\prim {\typ_i}}}
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\pprim {\typ_i}} \less}

  \inferrule[ExpressionMember-Specialized-BuiltInMethods]
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \spcTyp {\externTyp {\prim \name}} {\typs} = \reduce \typ \\
       % names in the following are actually methods. have to see what they contain.
       % \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       \fieldAccessEnv {\spcTyp {\externTyp {\prim \name}} {\typs}} \name {\prim \typ}}
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\prim \typ} \less}

  \inferrule[ExpressionMember-Extern]
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \externTyp {\prim \name} = \reduce \typ \\
       \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       % \prim \env = \insertToEnv  \typParams \typs \\
       \exists \name_i \in \names; \name_i = \name \\
       \pprim {\typ_i} = \reduce {\prim {\typ_i}}}
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\pprim {\typ_i}} \less}

  \inferrule[ExpressionMember-Extern-BuiltInMethods]
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \externTyp {\prim \name} = \reduce \typ \\
       % \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       \fieldAccessEnv {\spcTyp {\externTyp {\prim \name}} {\ }} \name {\prim \typ}}
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\prim \typ} \less}

  \inferrule[ExpressionMember-Rest]
     {\expenv \exp {\prim \exp} {\typ} \dir \\
       \prim \typ = \reduce \typ \\
       \fieldAccessEnv {\prim \typ} \name {\pprim \typ}}
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\pprim \typ} {\less} }


  \inferrule[Ternary]
     {\expenv {\exp_1} {\prim {\exp_1}} \boolTyp {\dir_1} \\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_1} {\dir_2} \\
      \expenv {\exp_3} {\prim {\exp_3}} {\typ_2} {\dir_3}\\
      \typ_1 = \typ_2 \\
      \typ_1 \neq \integerTyp}
     {\expenv {\ternary {\exp_1} {\exp_2} {\exp_3}} {\ternary {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\typ_1} \less }

  \inferrule[Ternary(AllowedInP4ButNotePetr4)]
     {\expenv {\exp_1} {\prim {\exp_1}} \boolTyp {\dir_1} \\
      \expenv {\exp_2} {\prim {\exp_2}} {\integerTyp} {\dir_2} \\
      \expenv {\exp_3} {\prim {\exp_3}} {\integerTyp} {\dir_3}\\
      % \typ_1 = \typ_2 \\
      % \typ_1 \eq \integerTyp \\
      \compTimeKnown {\exp_1}}
     {\expenv {\ternary {\exp_1} {\exp_2} {\exp_3}} {\ternary {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\typ_1} \less }


  \inferrule[FunctionCall-Function]
     { \expenv \exp {\prim \exp} {\funcType \kind \typVars {\prm 1, \ldots, \prm n} {\typ_\ret}} \dir\\
       % (\exp', \funcType \kind {\typVars} \params {\prim \typ}, \dir) = \resolveFuncOverload \exp \args \\
       % 1 \leq i \leq n; \prim {\typ_i} = \trans {\typ_i} \emp\\
       \prim \typs = \trans \typs \emp \\
       % \match \params \args\\
       |\typs| = |\typVars| \\
       \prim \typ = \sat {\typ_\ret}\\
       infer
       }
     { \expenv {\funcCall \exp \typs {\argkvss 1, \ldots, \argkvss n}} {} {\prim \typ} \less }

  \inferrule[FunctionCall-Action]
     {  }
     { blah }

% function type: <return type> <function name>(x1,...,xn) {...}

  \inferrule[AnonymousInstantiation]
     { (\prim {\arg_1}, \ldots, \prim {\arg_n}, \prim \typ) = typeConstInvoc  }
     { \expenv {\instantiation {\spcTyp \name {\typ_1, \ldots, \typ_m}} {\arg_1, \ldots, \arg_n}} {\instantiation {\spcTyp \name {\typ_1, \ldots, \typ_m}} {\prim {\arg_1}, \ldots, \prim {\arg_n}}} {\prim \typ} \less}

  \inferrule[AnonymousInstatnt2]
     { \expenv {\instantiation {\spcTyp \name {\ }} {\arg_1, \ldots, \arg_n}} {\prim \exp} \typ \dir}
     { \expenv {\instantiation {\name} {\arg_1, \ldots, \arg_n}} {\prim \exp} \typ \dir }

  \inferrule[Mask]
     {\expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
      \left( \so {\typ_1 = \typ_2 = \bitWidthTyp \width} {\typ = \bitWidthTyp \width}\right) \\
      \textOr
      \left( \so {\typ_1 = \typ_2 = \integerTyp} {\typ = \integerTyp}\right) \\
      \textOr
      \left( \so {\typ_1 = \bitWidthTyp \width, \typ_2 = \integerTyp} {\typ = \bitWidthTyp \width}\right) \\
      \textOr
      \left( \so {\typ_1 = \integerTyp, \typ_2 = \bitWidthTyp \width} {\typ = \bitWidthTyp \width}\right)
      }
     {\expenv {\mask {\exp_1} {\exp_2}} {\mask {\prim \exp_1} {\prim \exp_2}} {\setTyp \typ} \less  }

  \inferrule[Range]
     { \expenv \low {\prim \low} \typ {\dir_\low} \\
       \expenv \high {\prim \high} \typ {\dir_\high} \\
       \typ_\low = \typ_\high = \bitWidthTyp \width \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expenv {\range \low \high} {\range {\prim \low} {\prim \high}} {\setTyp \typ} \dir }


\end{mathpar}
~~
~

### Petr4 Restrictions Compared to P4 Spec
conditional operatior (ternary exp). petr4 doesn't support the case where both tru and fls expression have the infinite precision integer type when the condition can be evaluated at compilation time. This is allowed by P4 spec.
Petr4 doesn't have the product operation where multiple sets can be combined using cartesian product and the type of a product of sets is a set of tuples. section 8.12.5. (question)
Petr4 uses Ocaml's field access of records as its field access for structs. NO! field access is expression member. 


### Petr4 Discrepencies with P4 Spec
P4 spec defines bitwise operations and concatenation for bit<w> but Petr4 also allows them for int<w>. bitwiseops and bitstringconcatenation rules. section 8.5. check_binary_op impl. 
p4 spec defines division and modulo only for arbitrary-precision integers but petr4 allows them for bit<w> too. divops rule. section 8.7. check_binary_op impl.
p4 spec defines bitwise complement only for bit<w> but petr4 also allows it for int<w>. type_unary_op bitnot impl. section 8.5 spec. bitwisecomplement rule.
p4 spec states during the cast between int and bit<w> or int<w> the compiler would complain about overflow (or conversion of negative value for bit<w>) but petr4's type system doesn't check this. I'm not sure if any other part of petr4 takes care of this. section 8.9.1 spec. cast_ok impl. explicit cast judgment.
p4 spec states that all expression of type int MUST be compile-time known values but petr4 doesn't always check this. section 8.7 spec. e.g., unaryminus or binaryops rules. 
at first glance, it might seem that petr4 allows mask operation to also operate on arbitrary precision integers while P4 spec doesn't. However, note that int can be implicitly casted to bit<w>. so the mask operation can also operate on int or combination of int and bit<w>. similarly this applies to the range operation. 


### Coerce Binary Operation Arguments Auxiliary Judgment
Let implicitCast typ typ be defined as follows to describe P4's implicit
casting behavior on operands in binary expressions:
        
cast typ exp produces a cast expression if the type of exp is different from the
type typ.

The restJ rule stands for all other binary operations. 

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[ShiftRight]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \shiftR \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}}  }

  \inferrule[ShiftLeft]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \shiftL \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}} }

  \inferrule[BitConcatenation]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \concat \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}} }

  \inferrule[Rest]
     { \expenv  {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
       \typ = \implicitCast {\typ_1} {\typ_2} \\
       \pprim {\exp_1} = \cast \typ {\prim {\exp_1}} \\
       \pprim {\exp_2} = \cast \typ {\prim {\exp_2}}}
     { \coerceBinArgsEnv {\exp_1 \restOps \exp_2} {\pprim {\exp_1}, {\typ_1}, {\dir_1}} {\pprim {\exp_2}, {\typ_2}, {\dir_2}} }

\end{mathpar}
~~
~

### Check Binary Operation Auxiliary Judgment 
reduce enums removes all the enums recursively after reducing a type.
in_or_dirless(typ1, typ2) retunrs direction of In if both typ1 and typ2 have In direction, o.w., it returns a directionless direction. 
is true if and only if expression type t1 is equivalent to expression type t2 under environment env. Alpha equivalent types are equal. it takes the list of variables of the two types.
is nonneg and is pos evaluate an expression at compile time and check if it's a nonneg or pos numeric.
compile time known determinez if the value of an expression can be known at compile time.
   it returns true for externs, packages, controls, and parsers..

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[LogicalOps($\ops=\&\&,\vert\vert$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \boolTyp}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[NumericOps($+, -, *$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \integerTyp \textOr \intWidthTyp \width }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[EqualityChecks($==, !=$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \typEq {\emp} {\typ_1} {\typ_2} \\
       \typHasEq {\typ_1} }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[OpSat($\plusSat,\subSat$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[BitwiseOps($\bitAnd, \bitOr, \bitXor, \bitComplement$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[BitstringConcatenation]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \so {\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2} \textOr \intWidthTyp {\width_2}} {\typ = \bitWidthTyp {\width_1 + \width_2}} \right) \\
       \textOr \left( \so {\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2} \textOr \intWidthTyp {\width_2}} {\typ = \intWidthTyp {\width_1 + \width_2}} \right) }
     { \binOpEnv {\exp_1 \concat \exp_2} {\exp_1 \concat \exp_2} {\typ} \dir }

  \inferrule[ComparisonOps($<, \leq, >, \geq$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \typ_1 = \typ_2 = \integerTyp \right) \\
       \textOr \left( \typ_1 = \typ_2 = \bitWidthTyp \width \right) \\
       \textOr \left( \typ_1 = \typ_2 = \intWidthTyp \width \right)}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[DivOps($\div, \mod$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \so {\typ_1 = \typ_2 = \integerTyp, \nonNeg {\exp_1}, \pos {\exp_2}}  {\typ = \integerTyp} \right) \\
       \textOr \left( \so {\typ_1 = \typ_2 = \bitWidthTyp \width, \nonNeg {\exp_1}, \pos {\exp_2}}  {\typ = \bitWidthTyp \width} \right) }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} \typ \dir }

  \inferrule[ShiftOps($\shiftL,\shiftR$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \nonNeg {\exp_2} \\
       \left( \typ_1 = \bitWidthTyp \width \textOr \intWidthTyp \width \right) \\
       \textOr \left( \typ_1 = \integerTyp, \compTimeKnown {\exp_2} \right) }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\exp_1 \restOps \exp_2} {\typ_1} \dir }

\end{mathpar}
~~
~

### Cast Auxiliary Judgment
The cast first saturates both types and then check if they can be explicitly casted. For simplicity, we omited the saturation from rules.
we use subscription of e or i to indicate if a rule only applies for explicit or implicit cast only, respecctively. o.w., the arrow doesn't have a subscription. 


P4 spec specifies casts up to Sets rule. The rest might be stated throughout the spec but I haven't found them yet.

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Bit<1>ToBool]
     {  }
     { \explCast {\bitWidthTyp 1} \boolTyp }

  \inferrule[BoolToBit<1>]
     {  }
     { \explCast \boolTyp {\bitWidthTyp 1} }

  \inferrule[UnsignedIntToSigned]
     { \width_1 = \width_2 }
     { \explCast {\bitWidthTyp {\width_1}} {\intWidthTyp {\width_2}}}

  \inferrule[SignedIntToUnsigned]
     { \width_1 = \width_2 }
     { \explCast {\intWidthTyp {\width_1}} {\bitWidthTyp {\width_2}}}

  \inferrule[UnsignedIntToUnsignedInt-Explicit]
     { }
     { \explCast {\bitWidthTyp {\width_1}} {\bitWidthTyp {\width_2}}}

  \inferrule[UnsignedIntToUnsignedInt-Implicit]
     { \width_1 = \width_2}
     { \implCast {\bitWidthTyp {\width_1}} {\bitWidthTyp {\width_2}}}

  \inferrule[SignedIntToSignedInt-Explicit]
     { }
     { \explCast {\intWidthTyp {\width_1}} {\intWidthTyp {\width_2}}}

  \inferrule[SignedIntToSignedInt-Implicit]
     { \width_1 = \width_2}
     { \explCast {\intWidthTyp {\width_1}} {\intWidthTyp {\width_2}}}

  \inferrule[ArbitraryPrecisionIntToUnsignedInt]
     {}
     { \castenv \  \integerTyp {\bitWidthTyp \width}}

  \inferrule[ArbitraryPrecisionIntToSignedInt]
     {}
     { \castenv \  \integerTyp {\intWidthTyp \width}}

  \inferrule[TypeDefs]
     { (\typEq \emp {\typ_1} {\newTypeTyp \name {\typ_2}}) \textOr (\typEq \emp {\typ_2} {\newTypeTyp \name {\typ_1}})}
     { \castenv \  {\newTypeTyp \name {\typ_1}} {\newTypeTyp \name {\typ_2}}}

  \inferrule[TypeDefToType-Explicit]
     { \explCast {\typ_1} {\typ_2}}
     { \explCast {\newTypeTyp \name {\typ_1}} {\typ_2}}

  \inferrule[TypeDefToType-Implicit]
     { \implCast {\typ_1} {\typ_2}}
     { \implCast {\newTypeTyp \name {\typ_1}} {\typ_2}}

  \inferrule[TypeToTypeDef-Explicit]
     { \explCast {\typ_1} {\typ_2}}
     { \explCast {\typ_1} {\newTypeTyp \name {\typ_2}}}

  \inferrule[TypeToTypeDef-Implicit]
     { \implCast {\typ_1} {\typ_2}}
     { \implCast {\typ_1} {\newTypeTyp \name {\typ_2}}}

  \inferrule[Enums]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\enumTyp {\typ_1} {\name_1} {\names_1}} {\enumTyp {\typ_2} {\name_2} {\names_2}}}

  \inferrule[EnumToUnderlyingType]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\enumTyp {\typ_1} {\name_1} {\names_1}} {\typ_2}}

  \inferrule[TypeToEnumWithUndrlyingType]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\typ_1} {\enumTyp {\typ_2} {\name_2} {\names_2}}}

  \inferrule[Sets]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\setTyp {\typ_1}} {\setTyp {\typ_2}} }

  \inferrule[TypeToSet]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \implCast {\typ_1} {\setTyp {\typ_2}}}

  \inferrule[ListToTuple]
     { \typEq \emp {\tupleTyps {\typs_1}} {\tupleTyps {\typs_2}}}
     { \castenv \  {\listTyps {\typs_1} } {\tupleTyps {\typs_2}}}

  \inferrule[ListToHeader-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\explCast {\listTyp {\typ_1} {\typ_n}} {\headerTypp 1 n }}

  \inferrule[ListToHeader-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\implCast {\listTyp {\typ_1} {\typ_n}} {\headerTypp 1 n }}

  \inferrule[ListToStruct-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\explCast {\listTyp {\typ_1} {\typ_n}} {\structTypp 1 n }}

  \inferrule[ListToStruct-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\implCast {\listTyp {\typ_1} {\typ_n}} {\structTypp 1 n }}

  \inferrule[RecordToHeader-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\explCast {\recordTyp 1 n } {\headerTypp 1 n}}

  \inferrule[RecordToHeader-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\implCast {\recordTyp 1 n } {\headerTypp 1 n}}

  \inferrule[RecordToStruct-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\explCast {\recordTyp 1 n } {\structTypp 1 n}}

  \inferrule[RecordToStruct-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\implCast {\recordTyp 1 n } {\structTypp 1 n}}

  \inferrule[HeaderToHeader-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\headerTyp 1 n} {\headerTypp 1 n})}
     {\explCast {\headerTyp 1 n } {\headerTypp 1 n}}

  \inferrule[HeaderToHeader-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\headerTyp 1 n} {\headerTypp 1 n})}
     {\implCast {\headerTyp 1 n } {\headerTypp 1 n}}

  \inferrule[StructToStruct-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\structTyp 1 n} {\structTypp 1 n})}
     {\explCast {\structTyp 1 n } {\structTypp 1 n}}

  \inferrule[StructToStruct-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\structTyp 1 n} {\structTypp 1 n})}
     {\implCast {\structTyp 1 n } {\structTypp 1 n}}

  \inferrule[ID]
    { \typ_1 == \typ_2}
    {\implCast {\typ_1} {\typ_2}}

\end{mathpar}
~~
~


### Field Access Builtin Methods Auxiliary Judgment
ref to type_expression_member_function_builtin.

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Control]
     {}
     { \fieldAccessEnv {\controlTyp \ \ } \apply {}}

  \inferrule[Parser]
     {}
     {blah}

  \inferrule[Table]
     {}
     {blah}

  \inferrule[Struct]
     {}
     {blah}

  \inferrule[Header]
     {}
     {blah}

  \inferrule[Array]
     {}
     {blah}

  \inferrule[HeaderUnion]
     {}
     {blah}

\end{mathpar}
~~
~


## Type Related Judgments

### Type Well-Formed Auxiliary Judgment
it saturates all types first and then checks well-formedness. for breviety, we don't
include the saturation in rules.
is valid nested type outer inner checks whether the nested type is taking valid types in its inner and outer type based on P4's description of type nesting rules section 7.2.7 (provide link).
insert type var adds a type variable to the env.
lookup extern in env returns an externMethods type which includes a list of strings as
type parameters which must be empty for it to be well-typed and a function type which doesn't care for function type.
getTypeParams get type parameters from types that have type parameters including package, control, parser, function, and it's equivalent to look up for extern.

names to type env. 
~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Bool]
     { }
     { \typWellFormed \boolTyp }

  \inferrule[String]
     { }
     { \typWellFormed \stringTyp }

  \inferrule[(InfinitPrecision)Integer]
     { }
     { \typWellFormed \integerTyp }

  \inferrule[SignedInteger]
     { 1 < \width}
     { \typWellFormed {\intWidthTyp \width} }

  \inferrule[BitString(UnsignedInteger)]
     { 0 \leq \width}
     { \typWellFormed {\bitWidthTyp \width} }

  \inferrule[VarBit(DynamicallySizedBitString)]
     { }
     { \typWellFormed {\varBitTyp \width} }

  \inferrule[Error]
     { }
     { \typWellFormed \errTyp}

  \inferrule[Void]
     { }
     { \typWellFormed \voidTyp}

  \inferrule[MatchKind]
     { }
     { \typWellFormed \matchKindTyp}

  \inferrule[Array]
     { \typWellFormed \typ \\
       \isValidNestedTyp {\arrayTyp \typ \size} {\typ}}
     { \typWellFormed {\arrayTyp \typ \size} }

  \inferrule[Tuple]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp {\tupleTyp {\typ_1} {\typ_n}} {\typ_i}}
     { \typWellFormed {\tupleTyp {\typ_1} {\typ_n}} }

  \inferrule[List]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp {\listTyp {\typ_1} {\typ_n}} {\typ_i}}
     { \typWellFormed {\listTyp {\typ_1} {\typ_n}} }

  \inferrule[Set]
     { \typWellFormed \typ }
     { \typWellFormed {\setTyp \typ} }

  \inferrule[EnumWithType]
     { \typWellFormed \typ }
     { \typWellFormed \enumTyp }

  \inferrule[EnumWithoutType]
     {  }
     { \typWellFormed \enumTypNoTyp }

  \inferrule[Record]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \recordTypDef {\typ_i} \\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \recordTypDef }

  \inferrule[HeaderUnion]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \headerUnionTyp {\typ_i} \\
       % \noDup {\field_1, \ldots, \field_n}\\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \headerUnionTyp }

  \inferrule[Struct]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \structTypDef {\typ_i} \\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \structTypDef }

  \inferrule[Header]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \headerTypDef {\typ_i} \\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \headerTypDef }

  \inferrule[NewType(typedef)]
     { \typWellFormed \typ }
     { \typWellFormed {\newTypeTyp \typ \name} }

  \inferrule[SpecializedType]
     { \prim \typ = \sat \typ \\
       \{\param_1, \ldots, \param_m \} = \getTypeParams {\prim \typ} \\
       % \prim \typ = \externTyp \name \\
       %  ([\param_1, \ldots, \param_m], _)= \lookup \name \\
        1 \leq i \leq n; \typWellFormed {\typ_i} \\
        n = m}
     { \typWellFormed {\spcTyp \typ {\typ_1, \ldots, \typ_n}} }

  \inferrule[Package]
     { \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \dir_i = \less \\
       1 \leq i \leq n; \typWellFormed {\typ_i}}
     { \typWellFormed {\packageTyp {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n} {\wildcardParam_1, \ldots, \wildcardParam_p}} }

  \inferrule[Control]
     { \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_i}}
     { \typWellFormed {\controlTyp {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n} } }

  \inferrule[Parser]
     { \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_i}}
     { \typWellFormed {\parserTyp {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n} } }

  \inferrule[Extern]
     { ([], {\funcTyp \typ {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n}} ) =\lookupEnv \name }
     { \typWellFormed {\externTyp \name} }

  \inferrule[Function]
     { \typWellFormed \typ \\
       \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_n} }
     % <return type> <function name>(x1,...,xn) {...}
     { \typWellFormed {\funcTyp \typ {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n}} }

  \inferrule[Action]
     { i < j \\
       1 \leq k \leq n; \typWellFormed {\typ_k} \\
       j \leq k \leq n; \dir_k = \less }
     { \typWellFormed {\actionTyp {\prm 1, \ldots, \prm i} {\prm j, \ldots, \prm n}} }

  \inferrule[Constructor]
     { \typWellFormed \typ \\
       \prim \env = \insertTypVars {\param_1, \ldots, \param_n} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_n} }
     { \typWellFormed {\constructorTyp \typ \name {\prm 1, \ldots, \prm n}} }

  \inferrule[Table]
     { \typ = \lookupEnv \name }
     { \typWellFormed {\tableTyp \name} }

  \inferrule[TypeName]
     { \typ = \lookupEnv \name }
     { \typWellFormed {\typNameTyp \name} }

% is_well_formed_type
\end{mathpar}
~~
~

### Type Equality Judgment
TODO: refer to type_equality and solve_types functions in impl. For type equality of p4 spec refer to to section 8, under each operation there's a one liner that talks about when two types are equal for the type it's covering. 

## Statement's Typing Rules
this judgment type checks a statment written in surface syntax, generates the IR statement from it and if applicable updates the env and ctxt.
is_lvalue checks if an IR expression is lvalue. 
cast_expr takes a type and surface syntax expression. after generating the IR expression by type_expression, it checks if the given type and type of IR expression are equal it just returns the IR exp o.w. it casts (if possible) the IR expression to the given type.
if void type  returns a void type if a (or two) type is (are) void and otherwise returns a unit type.
get enum typ takes a type and checks if it's an enum. if so it returns the enums of it. 

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Assignment]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \isLval {{\prim {\exp_1}}, {\typ_1}, {\dir_1}} \\ 
       ({\prim {\exp_2}}, {\typ_2}, {\dir_2}) = \castExpression {\typ_1} {\exp_2}\\
       % \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
       % \typ_1 = \typ_2 \\
       }
     { \stmtenv {\assign {\exp_1} {\exp_2}} {\assign {\prim {\exp_1}} {\prim {\exp_2}}} {\unitTyp} }


  \inferrule[Empty]
     { }
     { \stmtenv {\noop} {\noop} {\unitTyp}}

  \inferrule[Block]
     { \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 \\
       \prim \typ = \ifVoidTyp {\typ_1} \\
       \stmtenvv 2 {\stmts} {\prim \stmts} {\prim \typ} 3 }
     { \stmtenvv 1 {\block {\stmt_1; \stmts} } {\block {\prim {\stmt_1}; {\prim \stmts}} } {\prim \typ} 3 }

  \inferrule[Return(inApplyBlockOrAction)]
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \applyBlockCtxt \textOr \actionCtxt \\
       ({\prim {\exp}}, {\typ}, {\dir}) = \castExpression {\voidTyp} {\exp}\\
       }
     { \stmtenv {\return \exp} {\return {({\prim {\exp}}, {\typ}, {\dir})}} \voidTyp  }

  \inferrule[ReturnEmpty]
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \applyBlockCtxt \textOr \actionCtxt \textOr \funcCtxt \typ \\
       }
     { \stmtenv {\return {}} {\return {}} \voidTyp  }

  \inferrule[Return(inFunction)]
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \funcCtxt \typ \\
       ({\prim {\exp}}, {\prim \typ}, {\dir}) = \castExpression {\typ} {\exp}\\
       }
     { \stmtenv {\return \exp} {\return {({\prim {\exp}}, {\prim \typ}, {\dir})}} \voidTyp  }

  \inferrule[Exit]
     { \ctxt \neq \parserCtxt }
     { \stmtenv \exit \exit \voidTyp}

  \inferrule[IfThen]
     { \ctxt \neq \parserCtxt \\
       (\prim \exp, \boolTyp, \dir) = \castExpression \boolTyp \exp \\
       \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 }
     { \stmtenvv 1 {\ifthen \exp {\stmt}} {\ifthen {\prim \exp} {\prim \stmt} } {\unitTyp} 1 }

  \inferrule[IfThenElse]
     { \ctxt \neq \parserCtxt \\
       (\prim \exp, \boolTyp, \dir) = \castExpression \boolTyp \exp \\
       \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 \\
       \stmtenvv 1 {\stmt_2} {\prim {\stmt_2}} {\typ_2} 3 \\
       \prim \typ = \ifVoidTyp {\typ_1, \typ_2}}
     { \stmtenvv 1 {\ifthenelse \exp {\stmt_1} {\stmt_2}} {\ifthenelse {\prim \exp} {\prim {\stmt_1}} {\prim {\stmt_2}} } {\prim \typ} 1 }

  \inferrule[Switch]
     { \ctxt_0 = \applyBlockCtxt \\
       \expenvv \exp {\prim \exp} \typ \dir 0 \\
       \prim \typ = \reduce \typ \\
       \name_1, \ldots, \name_m = \getEnum {\prim \typ} \\
       \lbl \notin \overline \lbl \\
       \lbl \in \{\name_1, \ldots, \name_m \}\\
       \stmtenvv 0 {\block {\stmts}} {\block {\prim {\stmts}}} {\typ_0} 1 \\
       \stmtenvv 1 {\switch \exp {\overline {\actionCase \stmt}}} {\switch {\prim \exp} {\overline {\actionCase {\pprim \stmt} }}} \unitTyp 2
       }
     { \stmtenvv 0 {\switch \exp {\actionCase \stmts, \overline {\actionCase \stmt}} } {\switch {\prim \exp} {\actionCase {\prim \stmts}, {\overline {\actionCase {\pprim \stmt} }} } } \unitTyp 2 }

  \inferrule[Declaration]
     { \isConstant \dcl \textOr \isInstantiation \dcl \textOr \isVariable \dcl \\
       \dclenvv 0 \dcl {\prim \dcl} 1}
     { \stmtenvv 0 \dcl {\prim \dcl} \unitTyp 1 }

\end{mathpar}
~~
~


## Declaration's Typing Rules
is allowed type for variable checks if a type is allowed for declaring a variable. it includes all types after saturation except for string, integer, list, set, void, specialized type, package, control, parser, extern, function, action, constructor, and table.
check parameter shadowing takes two lists of paramets and checks if there is any duplicate in them. 

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Constant]
     { \prim \typ = \trans \typ \emp \\
       (\prim \exp, \pprim \typ, \dir) = \castExpression \exp {\prim \typ}\\
       \val = \compileTimeEval {\prim \exp} }
     { \dclenvvv {\const \typ \var \exp} {\const {\prim \typ} \var \val} {\addConstEnv \var \val} {\addTypeEnv \var {(\prim \typ, \less)}}}

  \inferrule[Instantiation]
     { \expenv {\instantiation {\var} \args} {\instantiation {\var} {\prim \args}} {\prim \typ} \dir \\
       \ctxt \neq \toplevel \textOr \ctxt = \toplevel, ({\prim \typ} \neq \controlTyp {\_} {\_} \textOr \parserTyp {\_} {\_} )}
     { \dclenvvv {\inst \typVar \args \var {\ } } {\inst \typVar \args \var {\ }} \constEnv {\addTypeEnv \var {(\prim \typ, \less)}} }

  \inferrule[Parser]
    {}
    {blah}
     % { \checkParamShadow param constructorparam \\
     %   }
     % { \dclenvvv {} {} {} {} }

  \inferrule[Control]
     { blah }
     { blah }

  \inferrule[Function]
     { blah }
     { blah }

  \inferrule[Action]
     { blah }
     { blah }

  \inferrule[ExternFunction]
     { blah }
     { blah }

  \inferrule[Variable]
     { \ctxt \neq \toplevel \\
       \prim \typ = \trans \typ \emp \\
       \allowedTypeForVar {\prim \typ} \\
       \typWellFormed {\prim \typ}}
     { \dclenvvv {\varDecl \typ \var } {\varDecl {\prim \typ} \var} \constEnv {\addTypeEnv \var {(\prim \typ, \inout)}} }

  \inferrule[VariableInit]
     { \ctxt \neq \toplevel \\
       \prim \typ = \trans \typ \emp \\
       \allowedTypeForVar {\prim \typ} \\
       \typWellFormed {\prim \typ} \\
       (\prim \exp, \prim \typ, \dir) = \castExpression  {\prim \typ} \exp}
     { \dclenvvv {\varInit \typ \var \exp} {\varInit {\prim \typ} \var {(\prim \exp, \prim \typ, \dir)}} \constEnv {\addTypeEnv \var {(\prim \typ, \inout)}} }

  \inferrule[ValueSet]
     { blah }
     { blah }

  \inferrule[Table]
     { blah }
     { blah }

\end{mathpar}
~~
~

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Header]
     { blah }
     { blah }

  \inferrule[HeaderUnion]
     { blah }
     { blah }

  \inferrule[Struct]
     { blah }
     { blah }

  \inferrule[Error]
     { blah }
     { blah }

  \inferrule[MatchKind]
     { blah }
     { blah }

  \inferrule[Enum]
     { blah }
     { blah }

  \inferrule[SerializableEnum]
     { blah }
     { blah }

  \inferrule[ExternObject]
     { blah }
     { blah }

  \inferrule[TypeDef]
     { blah }
     { blah }

  \inferrule[NewType]
     { blah }
     { blah }

\end{mathpar}
~~
~

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[ControlType]
     { blah }
     { blah }

  \inferrule[ParserType]
     { blah }
     { blah }

  \inferrule[PackageType]
     { blah }
     { blah }

  % \inferrule[ ]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

\end{mathpar}
~~
~


