Title         : Petr4 Type System Formalization
Title Footer  : &date;
Author        : Petr4 Team
Affiliation   : Cornell University
Heading depth : 5

Math Mode       : static
Pdf Latex       : xelatex
Math Latex Full : pdflatex

Document Class : [11pt]article

Package : amssymb
Package : amscd
Package : fancyhdr
Package : mathpartir


Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

~Aligned : replace:"~Math&nl;\begin{aligned}&nl;&source;&nl;\end{aligned}&nl;~" 


[TITLE]

~ TexRaw
\mdDefineUnicode{10214}{\ensuremath{\llbracket}}
\mdDefineUnicode{10215}{\ensuremath{\rrbracket}}
~

~ Begin Abstract
P4 is a language for programming the data plane of network
devices. Petr4 provides a clean-slate definitional interpreter
and a core calculus that models a fragment of P4. This document
provides a definition of Petr4's type system that is consistent
with its implementation. The target audience of this document
includes developers and debuggers who work on P4 implementations
such as Petr4 and P4C. In essence, this document may be of
interest to programmers who are interested in understanding
the implementation of Petr4 deeply. Additionally, it points out
the discrepencies of Petr4's type system with P4 spec and Petr4's
limitations. 
~ End Abstract

~ MathDefs
[INCLUDE="ops.tex"]
~

[TOC]

# Overview { #sec-overview }

This document defines the type system of Petr4. The type system
conducts three tasks simultaneously:

1. It type checks P4 programs.
2. It conducts type inference.
3. It does a pass from the surface syntax to the first IR. 


## Connecting To The Implementation { #sec-conn }

The following locates each data type in the implementation
(<https://github.com/verified-network-toolchain/petr4>):

- The surface AST is _types.program_
- The type of programs of the surface syntax is _types.type.t_
- The first IR is _prog.program_
- The type of the first IR is _prog.type.t_
- The type system is implemented in _checker.ml_ file. 

For simplicity, we have removed the information that is needed to report when an error
happens. Such information is passed around in the surface syntax as a field (called
`tags`) of record for all data types.

## Architecture { #sec-arch }

Figure [#fig-arch] depicts part of Petr4's architecture that contains the type system.
After lexing and parsing a P4 program we get a program in our surface syntax. This
program is then passed through the _elaborator_ where type variables are introduced
instead of underscore and new type variable names are generated for variables with the
same name but in different scopes. This document does not discuss the innerworkings of
`elaborate`. Then, the program is passed through the type system (encoded in `checker`).
This document discusses the innerworking of the type system extensively. Finally, the
program is evaluated.

~ Figure { #fig-arch; caption: "Part of Petr4's achitecture." }
![arch]
~
[arch]: figs/petr4/arch.png { width: 100%; page-align: forcehere }

# Type System

A P4 program is mainly a list of declarations. A declaration could be declaring a
parser or control plane, instantiating an object, calling a (extern) function or method,
and defining a type or an object. Each declaration may contain multiple statements and
expressions within it. Thus, Petr4's type system contains multiple typing judgments for
three main categories:
[expressions][#sec-exp-typing],
[statements][#sec-stmt-typing],
and [declarations][#sec-decl-typing].
In addition, types themselves have judgments for checking their [well-formness][#sec-type-well-formed] and [equality][#sec-type-eq].
Each typing judgment may use auxiliary judgment and helper functions. The auxiliary
judgments are included in this document while the helper functions are just explained
in plain English.

**PL Note:**
A _type system_ is made up of typing _judgments_
and each typing judgment contains multiple
_typing rules_. A typing rule, in essence, is an _inference rule_.
An inference rule contains zero or more _propositions_ above the line
and one _conclusion_ below the line
with the name of the rule on top or next to the line.
For example, the rule $RuleName$ below reads as
$C$ is concluded if propositions $A$ and $B$ hold.

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}

  \inferrule[RuleName]
    {A \\ B}
    {C}

\end{mathpar}
~~
~

## Expression's Typing Rules { #sec-exp-typing }

The judgment $\expenv {\exp} {\prim \exp} \typ \dir $ states that expression $\exp$
written in surface syntax translates to expression $\prim \exp$ in the IR syntax with
the type $\typ$ and direction $\dir$ under enviornment $\env$. For now, we do not
present the syntax of the surface syntax and IR. Note that there is not much difference
between the two. **TODO** We plan to add the abstract syntax of them in appendix later.

Note the following notes:

- We use $\overline x$ to denote a list of $x$.
- For simplicity, we omit mapping a function on a list of elements. Instead, we just apply the function to a list. So every time you see a function applied to a list, read it as mapping the function over all the elements of the list. 

There are multiple helper functions used in judgements that are explained below:

- $\sat \typ$ satuarates a type, that is, it eliminates all type references in type
$\typ$ and replaces them with the type they refer to. Thus, the result of saturation
contains no _TypeName_ constructors that are used to give a name to a new type.
- $\lookupEnv \name$ looks up a variable (indicated with $\name$ which is the variable
name) in the enviornment and it returns its type and direction. When we only need the
type or the direction of the variable we simply ignore the other one. So you could see
formalization such as $\typ = \lookupEnv \name$ which states that we looked up variable
$\name$ from the enviornment and we found out that its type is $\typ$. Similarly, the
formalization $(\typ, \dir) = \lookupEnv \name$ states that we looked up variable
$\name$ in the enviornment $\env$ and it has the type $\typ$ and direction $\dir$.
- $\mathit{is\_X} (\typ)$ checks if the type $\typ$ is of the specific kind of type $X$.
For example, $\isArray \typ$ checks if the type $\typ$ is an array. Or $\isNumeric \typ$
check is the type $\typ$ is of numeric nature, that is, if it is fixed length signed or
unsigned integer or arbitrary precision integer.
- $\compTimeKnown \exp$ checks if the value of expression $\exp$ is known during the
compilation. It does so by evaluating the expression $\exp$ at compile time, if that is
possible then we know the value at compile time. Otherwise, if the expression $\exp$ is
a specialized type, extern, package, control, or parser but we cannot evaluate it at
compile time we still consider it known at compile time.
- $\reduce \typ $ saturates the type $\typ$ ... **TODO** (reduce takes a type and saturates the type first and returns the base of a specialized type by removing all its type parameters as long as the number of type params and type args match..)
- The notation $\maybe x$ denotes an optional type, that is, the type of $x$ has been extended with bottom (maybe type in Haskell, or option type in Ocaml). So if $x$ denotes an integer $\maybe x$ could either be an integer number or bottom. 
- $\matchParArg \params \args$ matches parameters $\params$ to arguments $\args$. A parameter is used when defining a function/structure. It has a type and a variable name. Additionally, it can have a direction and an optional value. On the other hand, an argument is what is actually passed to the function/structure when it is called and it can either be an expression, a key-value, or don't care. So the role of this helper function is to match the parameters to the passed arguments. If all arguments are key-values it simply matches the arguments and parameters based on their names. If the arguments are expressions or don't care, it matches them based on their positions. Thus, it returns a list of pairs of parameter names and optional expressions.
- $\validatePars \params \env \kind$ validates parameters $\params$ under the enviornment $\env$, context $\ctxt$ and the function kind $\kind$, after saturating their types. For example, it ensures that parameters of type extern are directionless, or parameters that must be compile time known are directionless. It also checks that the parameter type is well-formed and that it is a valid parameter type under a certain context (refer to the function _is\_valid\_param\_type_ to see exactly when a type is valid for a parameter).
- $\castParArg {\overline {\param = \maybe \exp}}$ bundles up the parameter with the expression's IR representation if possible: if $\maybe \exp \neq \bot$, it bundles up the parameter with $\castExpression \typ \exp$ if the direction of the parameter is correct (refer to _check\_direction_ function). Otherwise, if the parameter type isn't void and the direction is out or parameter is optional, it bundles up the parameter with bottom.
- $\callOK \ctxt \kind$ checks if the function kind is valid in a context (refer to _call\_ok_ function). 
- Did I miss anything else? 

Additionally, some of the typing rules use auxiliary judgments. The following is a brief
explanatin of auxiliary judgments that are used in expression's typing rules:

- The [casting auxiliary judgment][#sec-cast] defines rules for implicitly
and/or explicitly casting one type to another. Sepcifically, the judgment
$\castenv \ {\typ_1} {\typ_2}$ states that under enviornment $\env$
the type $\typ_1$ can be casted to type $\typ_2$ either explicitly or implicitly.
However, if the arrow is subscripted with $i$ or $e$ it states that the cast is only
done implicitly or explicitly, respectively. 
- The [coerce binary operation's arguments auxiliary judgment][#sec-coerce-bin-args]
allows the operands of a binary operation to be casted to another type when applicable.
It has the judgment form
$\coerceBinArgsEnv {\exp} {\exp_1, \typ_1, \dir_1} {\exp_2, \typ_2, \dir_2}$
which statees that under enviornment $\env$ and context $\ctxt$
the expression $\exp$ written in the surface syntax has
two operands $\exp_1$ and $\exp_2$ in the IR with types and directions
$\typ_1$, $\typ_2$, $\dir_1$, $\dir_2$ where the types and expressions might have
resulted from casting. 
- The [binary operation judgment][#sec-bin-op] confirms that an expression using a
binary operation follows the constraints of that binary operation. For example, if
an expression is checking the equality of two subexpression it checks that both
subexpression are of a type that equality is meaningful for it. It has the judgment
form $\binOpEnv \exp \typ \dir $ which states that the expression $\exp$
written in the IR is well-typed (that is, it follows all the restrictions applied to the
binary operation $\exp$ is using) and it has the type $\typ$ and direction $\dir$.
- The [expression memeber builtin judgment][#sec-exp-mem-builtin] is a helper judgment
for expression member (field access) rule.
It has the form $\fieldAccessEnv \ctxt \exp \typ {\prim \typ}$
which states that under enviornment $\env$ and context $\ctxt$, the field $\name$
has the type $\prim \typ$ in the expression $\exp$ of type $\typ$.
Note that $\exp$ has to be an expression
that contains fields, such as a struct or a header. 
- The [type well-formedness judgment][#sec-type-well-formed] checks if a type is
well-formed. It has the form $\typWellFormed \typ$ which states that the type $\typ$
is well-formed under the enviornment $\env$, that is, the type is syntactically correct.
- The [type equality judgment][#sec-type-eq] checks the equality of two types. It has
the form $\typEqEnv {\typ_1} {\typ_2}$ which states that the types $\typ_1$ and $\typ_2$ are equaivalent under the enviornment $\env$.
- The [function call auxiliary judgment][#sec-func-call] carries out multiple roles: 1) it checks
if the expression $\exp$ called from the function call is a ...;
2) it checks if the expression $\exp$ either has a function type or an action typ, and if so it returns the type parameteres, parameters, kind, and return type;
and 3) it resolves function overload.
It has the judgment form $\resolveFuncOver \exp \args {\prim \exp} \typVars \params \kind {\typ_\ret}$ which states that the expression $\exp$ called as a function call with arguments $\args$ under enviornment $\env$ and context $\ctxt$ translates to expressio $\prim \exp$ in the IR and has the type parameters $\typVars$, parameteres $\params$, kind $\kind$, and the return type $\typ_\ret$.
- The [infer type arguments auxiliary judgment][#sec-infer-type-args] infers the type of type parameters of a function. It has the judgment form $\inferTypParArg {\typ_\ret} {\overline {\typVar : \typ}} {\overline {\param = {\maybe \exp}}} {\overline {\prim \typVar : \prim \typ}} {\overline {\typVar : \pprim \typ}}$ which states that the type parameters $\typVars$ have the type $\pprim \typ$ under enviornment $\env$ and context $\ctxt$ with the return type of $\typ_\ret$, the assignment of type parameters $\typVars$ to types $\typs$, the assignment of parameters $\params$ to optional expressions $\maybe \exp$, and constraints $fill\ later$.

**NOTE**: I couldn't find the followings in section 8 of p4 spec:
array access, bist string access, type member, anonymous instant (this is probably method invocation or sth).

**TODO** explanation of some of the rules. start with a couple of simple ones (bool and name), then
intermediate (biststringaccess, record, cast) and then complicated (function call, exp mem, instantiation). 


~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Bool]
     {}
     {\expenv \bool \bool \boolTyp \less}

  \inferrule[String]
     {}
     {\expenv \str \str \stringTyp \less}

  \inferrule[Integer]
     {}
     {\expenv \int \int \integerTyp \less}

  \inferrule[Bit]
     {}
     {\expenv {\bitWidth \bit \width} {\bitWidth \bit \width} {\bitWidthTyp \width} \less}

  \inferrule[Int]
     {}
     {\expenv {\intWidth \int \width} {\intWidth \int \width} {\intWidthTyp \width} {\less}}

  \inferrule[Name]
     {\lookupEnv \name = (\typ, \dir)}
     {\expenv \name \name \typ \dir}

  \inferrule[ArrayAccess]
     {\expenv {\array} {\prim \array} {\arrayTyp \typ \size} \dir \\
      \expenv \index {\prim \index} {\prim \typ} {\prim \dir} \\
      \isArray {\arrayTyp \typ \size} \\
      \isNumeric {\prim \typ}}
     {\expenv {\arrayAccess \array \index} {\arrayAccess {\prim \array} {\prim \index}} \typ \dir }

  \inferrule[BitStringAccess]
     {\expenvWithCtxt \cte \high {\prim \high} {\typ_\high} {\dir_\high} \\
      \isNumeric {\typ_\high} \\
      \pprim \high = \compileTimeEval {\prim \high} \\
      \expenvWithCtxt \cte \low {\prim \low} {\typ_\low} {\dir_\low} \\
      \isNumeric {\typ_\low} \\
      \pprim \low = \compileTimeEval {\prim \low} \\
      0 \leq \pprim \low < \width \\
      \pprim l \leq \pprim h < \width \\
      \expenv \bitString {\prim \bitString} \typ \dir \\
      \typ = \intWidthTyp \width \textOr \bitWidthTyp \width}
     {\expenv {\bitStringAccess \bitString \low \high} {\bitStringAccess \bitString {\pprim \low} {\pprim \high}} {\bitStringTyp {\pprim \high - \pprim \low}} \dir }

  \inferrule[List]
     {1 \leq i \leq n; \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}}
     {\expenv {\list {\exp_1, \ldots, \exp_n}} {\list {\exp_1, \ldots, \exp_n}} {\listTyp {\typ_1} {\typ_n}} \less }

  \inferrule[Record]
     {1 \leq i \leq n; \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}  }
     {\expenv {\record 1 n} {\recordd 1 n {\prim \exp}} {\recordTypDef} \less  }

  \inferrule[LogicalNegation]
     { \expenv \exp {\prim \exp} \boolTyp \dir }
     { \expenv {!\exp} {!\prim \exp} \boolTyp \dir }

  \inferrule[BitwiseComplement]
     { \expenv \exp {\prim \exp} \typ  \dir \\
       \typ = {\bitWidthTyp \width} \textOr \intWidthTyp \width}
     { \expenv {\bitComplement\!\exp} {\bitComplement\!\prim \exp} {\typ} \dir }

  \inferrule[UnaryMinus]
     { \expenv \exp {\prim \exp} \typ  \dir \\
       \typ = {\bitWidthTyp \width} \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expenv {-\exp} {-\prim \exp} {\intWidthTyp \width} \dir }

  \inferrule[BinaryOps]
     {\coerceBinArgsEnv {\exp_1 \oplus \exp_2} {\prim {\exp_1}} {\prim {\exp_2}} \\
      \binOpEnv {\prim {\exp_1} \oplus \prim {\exp_2}} \typ \dir }
     { \expenv {\exp_1 \oplus \exp_2} {\prim {\exp_1} \oplus \prim {\exp_2}} \typ \dir }

\end{mathpar}
~~
~

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Cast]
     { \expenv \exp {\exp_1} {\typ_1} \dir \\
       \typ_2 = \sat {\typ_1} \\
       \typ_3 = \trans {\typ_2} {\emp} \\
       \typ_4 = \sat {\typ_3} \\
       \typWellFormed {\typ_3} \\
       \explicitCastOK {\typ_1} {\typ_3}}
     { \expenv {\cast \typ \exp} {\cast {\typ_1} {\exp_1}} {\typ_3} \less  }

  \inferrule[TypeMember]
     {\lookupEnv {\typMem \typ \name} = (\typ, \dir)  }
     {\expenv {\typMem \typ \name} {\typMem \typ \name} \typ \less  }

  \inferrule[ErrorMember]
     {\lookupEnv {\errMem \name} = (\errTyp, \dir)  }
     {\expenv {\errMem \name} {\errMem \name} \errTyp \less  }

  \inferrule[ExpressionMember]
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \prim \typ = \reduce \typ \\
       % \structTypDef = \prim \typ\\
       \fieldAccessEnv \ctxt {\prim \typ} {\pprim \typ}
       }
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\pprim \typ} {\less} }

  \inferrule[Ternary]
     {\expenv {\exp_1} {\prim {\exp_1}} \boolTyp {\dir_1} \\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_1} {\dir_2} \\
      \expenv {\exp_3} {\prim {\exp_3}} {\typ_2} {\dir_3}\\
      \typ_1 = \typ_2 \\
      \typ_1 \neq \integerTyp}
     {\expenv {\ternary {\exp_1} {\exp_2} {\exp_3}} {\ternary {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\typ_1} \less }

  % \inferrule[ Ternary(AllowedInP4ButNotePetr4)]
     % {\expenv {\exp_1} {\prim {\exp_1}} \boolTyp {\dir_1} \\
     %  \expenv {\exp_2} {\prim {\exp_2}} {\integerTyp} {\dir_2} \\
     %  \expenv {\exp_3} {\prim {\exp_3}} {\integerTyp} {\dir_3}\\
     %  % \typ_1 = \typ_2 \\
     %  % \typ_1 \eq \integerTyp \\
     %  \compTimeKnown {\exp_1}}
     % {\expenv {\ternary {\exp_1} {\exp_2} {\exp_3}} {\ternary {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\typ_1} \less }


  \inferrule[FunctionCall]
     {
       \resolveFuncOver \exp \args {\prim \exp} \typVars \params \kind {\typ_\ret} \\
       % \expenv \exp {\prim \exp} {\funcType \kind \typVars {\prm 1, \ldots, \prm n} {\typ_\ret}}\\
       \overline {\prim \typ} = \trans \typs \emp \\
       % \match \params \args\\
       |\typs| = |\typVars|\\
       \overline {\typVar : \typ} = \zip \typVars {\overline {\prim \typ}}\\
       {\prim \typ}_{\ret} = \sat {\typ_\ret} \\
       \overline {\param = \pprim {\maybe \exp}} = \matchParArg \params \args\\
       \inferTypParArg {\typ_\ret} {\overline {\typVar : \prim \typ}} {\overline {\param = \pprim {\maybe \exp}}} {\overline {\typVar : \prim \typ}} {\overline {\typVar : \pprim \typ}}\\
       \validatePars {\params} {\addTypEnvv {\overline {\typVar : \pprim \typ}} } \kind \\
       \overline {\param = \maybe {(\ppprim \exp, \ppprim \typ, \dir)}} = \castParArg {\overline {\param = \pprim {\maybe \exp}}}\\ 
       \callOK \ctxt \kind 
       }
     { \expenv {\funcCall \exp \typs \args} {\funcCall {\prim \exp} {\overline {\pprim \typ}} {\overline{\maybe {(\ppprim \exp, \ppprim \typ, \dir)}}} } {{\prim \typ}_{\ret}} \less }

  \inferrule[AnonymousInstantiation]
     { (\prim {\arg_1}, \ldots, \prim {\arg_n}, \prim \typ) = typeConstInvoc  }
     { \expenv {\instantiation {\spcTyp \name {\typ_1, \ldots, \typ_m}} {\arg_1, \ldots, \arg_n}} {\instantiation {\spcTyp \name {\typ_1, \ldots, \typ_m}} {\prim {\arg_1}, \ldots, \prim {\arg_n}}} {\prim \typ} \less}

  \inferrule[AnonymousInstatnt2]
     { \expenv {\instantiation {\spcTyp \name {\ }} {\arg_1, \ldots, \arg_n}} {\prim \exp} \typ \dir}
     { \expenv {\instantiation {\name} {\arg_1, \ldots, \arg_n}} {\prim \exp} \typ \dir }

  \inferrule[Mask]
     {\expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
      \left( \so {\typ_1 = \typ_2 = \bitWidthTyp \width} {\typ = \bitWidthTyp \width}\right) \\
      \textOr
      \left( \so {\typ_1 = \typ_2 = \integerTyp} {\typ = \integerTyp}\right) \\
      \textOr
      \left( \so {\typ_1 = \bitWidthTyp \width, \typ_2 = \integerTyp} {\typ = \bitWidthTyp \width}\right) \\
      \textOr
      \left( \so {\typ_1 = \integerTyp, \typ_2 = \bitWidthTyp \width} {\typ = \bitWidthTyp \width}\right)
      }
     {\expenv {\mask {\exp_1} {\exp_2}} {\mask {\prim \exp_1} {\prim \exp_2}} {\setTyp \typ} \less  }

  \inferrule[Range]
     { \expenv \low {\prim \low} \typ {\dir_\low} \\
       \expenv \high {\prim \high} \typ {\dir_\high} \\
       \typ_\low = \typ_\high = \bitWidthTyp \width \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expenv {\range \low \high} {\range {\prim \low} {\prim \high}} {\setTyp \typ} \dir }


\end{mathpar}
~~
~

### Petr4 Restrictions Compared to P4 Spec { #sec-exp-restrictions }
Petr4 does not support all features of P4. This section gathers Petr4's restriction for
expressions:

- Petr4 doesn't support the case where both the
true and the false expressions have the infinite precision integer type when the
condition can be evaluated at compilation time. However, this is allowed by P4 spec.
- Petr4 doesn't have the product operation where multiple sets can be combined using
cartesian product and the type of a product of sets is a set of tuples. (refer to
section 8.12.5. of P4 spec (**DISCUSS**))


### Petr4 Discrepencies with P4 Spec { #sec-exp-discrepencies }
This section documents the discrepencies of Petr4 with P4 spec:

- P4 spec defines bitwise operations and concatenation for bit<w> but Petr4 also allows them for int<w>. (ref: bitwiseops and bitstringconcatenation rules. section 8.5. check_binary_op impl. )
- P4 spec defines division and modulo only for arbitrary-precision integers but petr4 allows them for bit<w> too. (ref: divops rule. section 8.7. check_binary_op impl.)
- P4 spec defines bitwise complement only for bit<w> but Petr4 also allows it for int<w>. (ref: type_unary_op bitnot impl. section 8.5 spec. bitwisecomplement rule.)
- P4 spec states during the cast between int and bit<w> or int<w> the compiler would complain about overflow (or conversion of negative value for bit<w>) but Petr4's type system doesn't check this. (ref: I'm not sure if any other part of petr4 takes care of this. section 8.9.1 spec. cast_ok impl. explicit cast judgment.)
- P4 spec states that all expressions of type int MUST be compile-time known values but
Petr4 doesn't always check this. (ref: section 8.7 spec. e.g., unaryminus or binaryops rules.)

### Side Notes { #sec-exp-note }
There are also small differencies between P4 and Petr4's terminologies:

- Petr4 calls field access for structs _expression member_.

For ease of understanding, we provide notes that help the reader understand some of
the differences of Petr4 and P4 spec that may seem as discrepencies in the first glance:

- It might seem that petr4 allows mask operation to also operate on arbitrary precision integers while P4 spec doesn't. However, note that int can be implicitly casted to bit<w>. so the mask operation can also operate on int or combination of int and bit<w>. similarly this applies to the range operation. 


### Coerce Binary Operation Arguments Auxiliary Judgment { #sec-coerce-bin-args }
Let implicitCast typ typ be defined as follows to describe P4's implicit
casting behavior on operands in binary expressions:
        
cast typ exp produces a cast expression if the type of exp is different from the
type typ.

The restJ rule stands for all other binary operations. 

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[ShiftRight]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \shiftR \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}}  }

  \inferrule[ShiftLeft]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \shiftL \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}} }

  \inferrule[BitConcatenation]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}}
     { \coerceBinArgsEnv {\exp_1 \concat \exp_2} {\prim {\exp_1}, {\typ_1}, {\dir_1}} {\prim {\exp_2}, {\typ_2}, {\dir_2}} }

  \inferrule[Rest]
     { \expenv  {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
       \typ = \implicitCast {\typ_1} {\typ_2} \\
       \pprim {\exp_1} = \cast \typ {\prim {\exp_1}} \\
       \pprim {\exp_2} = \cast \typ {\prim {\exp_2}}}
     { \coerceBinArgsEnv {\exp_1 \restOps \exp_2} {\pprim {\exp_1}, {\typ_1}, {\dir_1}} {\pprim {\exp_2}, {\typ_2}, {\dir_2}} }

\end{mathpar}
~~
~

### Binary Operation Auxiliary Judgment { #sec-bin-op }
reduce enums removes all the enums recursively after reducing a type.
in_or_dirless(typ1, typ2) retunrs direction of In if both typ1 and typ2 have In direction, o.w., it returns a directionless direction. 
is true if and only if expression type t1 is equivalent to expression type t2 under environment env. Alpha equivalent types are equal. it takes the list of variables of the two types.
is nonneg and is pos evaluate an expression at compile time and check if it's a nonneg or pos numeric.
compile time known determinez if the value of an expression can be known at compile time.
   it returns true for externs, packages, controls, and parsers..

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[LogicalOps($\ops=\&\&,\vert\vert$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \boolTyp}
     { \binOpEnv {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[NumericOps($+, -, *$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \integerTyp \textOr \intWidthTyp \width }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[EqualityChecks($==, !=$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \typEq {\emp} {\typ_1} {\typ_2} \\
       \typHasEq {\typ_1} }
     { \binOpEnv {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[OpSat($\plusSat,\subSat$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[BitwiseOps($\bitAnd, \bitOr, \bitXor, \bitComplement$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width}
     { \binOpEnv {\exp_1 \restOps \exp_2} {\typ_1} \dir }

  \inferrule[BitstringConcatenation]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \so {\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2} \textOr \intWidthTyp {\width_2}} {\typ = \bitWidthTyp {\width_1 + \width_2}} \right) \\
       \textOr \left( \so {\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2} \textOr \intWidthTyp {\width_2}} {\typ = \intWidthTyp {\width_1 + \width_2}} \right) }
     { \binOpEnv {\exp_1 \concat \exp_2} {\typ} \dir }

  \inferrule[ComparisonOps($<, \leq, >, \geq$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \typ_1 = \typ_2 = \integerTyp \right) \\
       \textOr \left( \typ_1 = \typ_2 = \bitWidthTyp \width \right) \\
       \textOr \left( \typ_1 = \typ_2 = \intWidthTyp \width \right)}
     { \binOpEnv {\exp_1 \restOps \exp_2} \boolTyp \dir }

  \inferrule[DivOps($\div, \mod$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \left( \so {\typ_1 = \typ_2 = \integerTyp, \nonNeg {\exp_1}, \pos {\exp_2}}  {\typ = \integerTyp} \right) \\
       \textOr \left( \so {\typ_1 = \typ_2 = \bitWidthTyp \width, \nonNeg {\exp_1}, \pos {\exp_2}}  {\typ = \bitWidthTyp \width} \right) }
     { \binOpEnv {\exp_1 \restOps \exp_2} \typ \dir }

  \inferrule[ShiftOps($\shiftL,\shiftR$)]
     { \typ_1 = \reduceEnums {\exp_1} \\
       \typ_2 = \reduceEnums {\exp_2} \\
       \dir = \inOrLess {\typ_1} {\typ_2} \\
       \nonNeg {\exp_2} \\
       \left( \typ_1 = \bitWidthTyp \width \textOr \intWidthTyp \width \right) \\
       \textOr \left( \typ_1 = \integerTyp, \compTimeKnown {\exp_2} \right) }
     { \binOpEnv {\exp_1 \restOps \exp_2} {\typ_1} \dir }

\end{mathpar}
~~
~

### Cast Auxiliary Judgment { #sec-cast }
The cast first saturates both types and then check if they can be explicitly casted. For simplicity, we omited the saturation from rules.
we use subscription of e or i to indicate if a rule only applies for explicit or implicit cast only, respecctively. o.w., the arrow doesn't have a subscription. 


P4 spec specifies casts up to Sets rule. The rest might be stated throughout the spec but I haven't found them yet.

~ Center  {padding:1ex} 
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Bit<1>ToBool]
     {  }
     { \explCast {\bitWidthTyp 1} \boolTyp }

  \inferrule[BoolToBit<1>]
     {  }
     { \explCast \boolTyp {\bitWidthTyp 1} }

  \inferrule[UnsignedIntToSigned]
     { \width_1 = \width_2 }
     { \explCast {\bitWidthTyp {\width_1}} {\intWidthTyp {\width_2}}}

  \inferrule[SignedIntToUnsigned]
     { \width_1 = \width_2 }
     { \explCast {\intWidthTyp {\width_1}} {\bitWidthTyp {\width_2}}}

  \inferrule[UnsignedIntToUnsignedInt-Explicit]
     { }
     { \explCast {\bitWidthTyp {\width_1}} {\bitWidthTyp {\width_2}}}

  \inferrule[UnsignedIntToUnsignedInt-Implicit]
     { \width_1 = \width_2}
     { \implCast {\bitWidthTyp {\width_1}} {\bitWidthTyp {\width_2}}}

  \inferrule[SignedIntToSignedInt-Explicit]
     { }
     { \explCast {\intWidthTyp {\width_1}} {\intWidthTyp {\width_2}}}

  \inferrule[SignedIntToSignedInt-Implicit]
     { \width_1 = \width_2}
     { \explCast {\intWidthTyp {\width_1}} {\intWidthTyp {\width_2}}}

  \inferrule[ArbitraryPrecisionIntToUnsignedInt]
     {}
     { \castenv \  \integerTyp {\bitWidthTyp \width}}

  \inferrule[ArbitraryPrecisionIntToSignedInt]
     {}
     { \castenv \  \integerTyp {\intWidthTyp \width}}

  \inferrule[TypeDefs]
     { (\typEq \emp {\typ_1} {\newTypeTyp \name {\typ_2}}) \textOr (\typEq \emp {\typ_2} {\newTypeTyp \name {\typ_1}})}
     { \castenv \  {\newTypeTyp \name {\typ_1}} {\newTypeTyp \name {\typ_2}}}

  \inferrule[TypeDefToType-Explicit]
     { \explCast {\typ_1} {\typ_2}}
     { \explCast {\newTypeTyp \name {\typ_1}} {\typ_2}}

  \inferrule[TypeDefToType-Implicit]
     { \implCast {\typ_1} {\typ_2}}
     { \implCast {\newTypeTyp \name {\typ_1}} {\typ_2}}

  \inferrule[TypeToTypeDef-Explicit]
     { \explCast {\typ_1} {\typ_2}}
     { \explCast {\typ_1} {\newTypeTyp \name {\typ_2}}}

  \inferrule[TypeToTypeDef-Implicit]
     { \implCast {\typ_1} {\typ_2}}
     { \implCast {\typ_1} {\newTypeTyp \name {\typ_2}}}

  \inferrule[Enums]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\enumTyp {\typ_1} {\name_1} {\names_1}} {\enumTyp {\typ_2} {\name_2} {\names_2}}}

  \inferrule[EnumToUnderlyingType]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\enumTyp {\typ_1} {\name_1} {\names_1}} {\typ_2}}

  \inferrule[TypeToEnumWithUndrlyingType]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\typ_1} {\enumTyp {\typ_2} {\name_2} {\names_2}}}

  \inferrule[Sets]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \castenv \ {\setTyp {\typ_1}} {\setTyp {\typ_2}} }

  \inferrule[TypeToSet]
     { \typEq \emp {\typ_1} {\typ_2}}
     { \implCast {\typ_1} {\setTyp {\typ_2}}}

  \inferrule[ListToTuple]
     { \typEq \emp {\tupleTyps {\typs_1}} {\tupleTyps {\typs_2}}}
     { \castenv \  {\listTyps {\typs_1} } {\tupleTyps {\typs_2}}}

  \inferrule[ListToHeader-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\explCast {\listTyp {\typ_1} {\typ_n}} {\headerTypp 1 n }}

  \inferrule[ListToHeader-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\implCast {\listTyp {\typ_1} {\typ_n}} {\headerTypp 1 n }}

  \inferrule[ListToStruct-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\explCast {\listTyp {\typ_1} {\typ_n}} {\structTypp 1 n }}

  \inferrule[ListToStruct-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\tupleTyp {\typ_1} {\typ_n}} {\tupleTyp {\prim {\typ_1}} {\prim {\typ_n}}})}
     {\implCast {\listTyp {\typ_1} {\typ_n}} {\structTypp 1 n }}

  \inferrule[RecordToHeader-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\explCast {\recordTyp 1 n } {\headerTypp 1 n}}

  \inferrule[RecordToHeader-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\implCast {\recordTyp 1 n } {\headerTypp 1 n}}

  \inferrule[RecordToStruct-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\explCast {\recordTyp 1 n } {\structTypp 1 n}}

  \inferrule[RecordToStruct-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\recordTyp 1 n} {\recordTypp 1 n})}
     {\implCast {\recordTyp 1 n } {\structTypp 1 n}}

  \inferrule[HeaderToHeader-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\headerTyp 1 n} {\headerTypp 1 n})}
     {\explCast {\headerTyp 1 n } {\headerTypp 1 n}}

  \inferrule[HeaderToHeader-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\headerTyp 1 n} {\headerTypp 1 n})}
     {\implCast {\headerTyp 1 n } {\headerTypp 1 n}}

  \inferrule[StructToStruct-Explicit]
     {(1 \leq i \leq n; \explCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\structTyp 1 n} {\structTypp 1 n})}
     {\explCast {\structTyp 1 n } {\structTypp 1 n}}

  \inferrule[StructToStruct-Implicit]
     {(1 \leq i \leq n; \implCast {\typ_i} {\prim {\typ_i}}) \textOr
      (\typEq \emp {\structTyp 1 n} {\structTypp 1 n})}
     {\implCast {\structTyp 1 n } {\structTypp 1 n}}

  \inferrule[ID]
    { \typ_1 == \typ_2}
    {\implCast {\typ_1} {\typ_2}}

\end{mathpar}
~~
~


### Field Access Builtin Methods Auxiliary Judgment { #sec-exp-mem-builtin }

**DISCUSSION** there is some dead code in the implementation of this judgment.
The function _type\_expression\_member_ calls the helper _type\_expression\_member\_builtin_ when it doesn't find the name of field that is to be accessed (that is, for size,
last index, next, or last) and there it checks if the type of the expression is an
array but it has already patterned matched on the type of the expression to be either
struct, header, header union, specilaized, or extern. Thus, the _None_ case would always
fail. what's the correct expected behavior here?

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[ExpressionMember-StructOrHeaderOrHeaderUnion]
     {
       % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \structTypDef = \reduce \typ \\
       % \structTypDef = \prim \typ\\
       (\field_{n+1},\typ_{n+1}) = (\isValid, \funcTyp \builtin \ \ \boolTyp )\\
       \exists 1 \leq i \leq n+1; \field_i = \name
       }
     { \fieldAccessEnv \ctxt \structTypDef {\typ_i} }

  \inferrule[ExpressionMember-StructOrHeaderOrHeaderUnion-SizeOrLastIndex]
     {
       % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \structTypDef = \reduce \typ \\
        % = \prim \typ\\
       % (\field_{n+1},\typ_{n+1}) = (\isValid, \funcTyp \builtin \ \ \boolTyp )\\
       % \isArray \typ \\
       \name = \sizeFlag \textOr \lastIndex\\
       \nexists 1 \leq i \leq n; \field_i = \name
       }
     { \fieldAccessEnv \ctxt {\arrayTyp \typ \size AND \ \structTypDef} {\bitWidthTyp {32}} }

  \inferrule[ExpressionMember-StructOrHeaderOrHeaderUnion-NextOrLast]
     {
       % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \structTypDef = \reduce \typ \\
        % = \prim \typ\\
       % (\field_{n+1},\typ_{n+1}) = (\isValid, \funcTyp \builtin \ \ \boolTyp )\\
       % \isArray {\reduce \typ} \\
       % \arrayTyp {\prim \typ} \size = \typ\\
       \name = \sizeFlag \textOr \lastIndex \\
       \nexists 1 \leq i \leq n; \field_i = \name
       }
     { \fieldAccessEnv \parserCtxt {\arrayTyp \typ \size AND \ \structTypDef} \typ }

  \inferrule[ExpressionMember-Specialized]
     {
       % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \spcTyp {\externTyp {\prim \name}} {\typs} = \reduce \typ \\
       % names in the following are actually methods. have to see what they contain.
       \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       % \prim \env = \insertToEnv  \typParams \typs \\
       \exists \name_i: \typ_i \in \overline {\name:\prim \typ}; \name_i = \name \\
       \pprim {\typ_i} = \reduceWithEnv {\insertToEnv  \typParams \typs} {\prim {\typ_i}}}
     { \fieldAccessEnv \ctxt {\spcTyp {\externTyp {\prim \name}} {\typs}} {\pprim {\typ_i}}}


  \inferrule[ExpressionMember-Specialized-SizeOrLastIndex]
     {
     % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \spcTyp {\externTyp {\prim \name}} {\typs} = \reduce \typ \\
       % names in the following are actually methods. have to see what they contain.
       % \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       \name = \sizeFlag \textOr \lastIndex\\
       \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       \nexists \name_i: \typ_i \in \overline {\name:\prim \typ}; \name_i = \name 
       }
     { \fieldAccessEnv \ctxt {\spcTyp {\externTyp {\prim \name}} {\typs} AND \ \arrayTyp \typ \size} {\bitWidthTyp {32}}}

  \inferrule[ExpressionMember-Specialized-NextOrLast]
     {
     % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \spcTyp {\externTyp {\prim \name}} {\typs} = \reduce \typ \\
       % names in the following are actually methods. have to see what they contain.
       % \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       \name = \sizeFlag \textOr \lastIndex\\
       \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
       \nexists \name_i: \typ_i \in \overline {\name:\prim \typ}; \name_i = \name 
       }
     { \fieldAccessEnv \parserCtxt {\spcTyp {\externTyp {\prim \name}} {\typs} AND \ \arrayTyp \typ \size} {\typ}}

  \inferrule[ExpressionMember-Extern]
     { \fieldAccessEnv \ctxt {\spcTyp {\externTyp {\prim \name}} \ } {\pprim \typ} }
     { \fieldAccessEnv \ctxt  {\externTyp {\prim \name}}  {\pprim \typ}}

  % \inferrule[ExpressionMember-Extern-SizeOrLastIndex]
  %    { \name = \sizeFlag \textOr \lastIndex\\
  %      \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
  %      \nexists \name_i: \typ_i \in \overline {\name:\prim \typ}; \name_i = \name \\
  %    % \expenv \exp {\prim \exp} {\typ} \dir \\
  %    %   \externTyp {\prim \name} = \reduce \typ \\
  %      % \lookupEnv {\prim \name} = (\typParams,\overline {\name:\prim \typ}) \\
  %      % \fieldAccessEnv \ {\spcTyp {\externTyp {\prim \name}} {\ }} \name {\prim \typ}}
  %    { \fieldAccessEnv \ctxt  {\externTyp {\prim \name} AND \ \arrayTyp \typ \size} }

  % \inferrule[ExpressionMember-Rest]
  %    {\expenv \exp {\prim \exp} {\typ} \dir \\
  %      \prim \typ = \reduce \typ \\
  %      \fieldAccessEnv {\prim \typ} \name {\pprim \typ}}
  %    { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\pprim \typ} {\less} }


\end{mathpar}
~~
~


### Function Call Auxiliary Judgment { #sec-func-call }

### Infer Type Arguments Auxiliary Judgment { #sec-infer-type-args }

## Type Related Judgments { #sec-types-typing }

### Type Well-Formed Auxiliary Judgment { #sec-type-well-formed }
it saturates all types first and then checks well-formedness. for breviety, we don't
include the saturation in rules.
is valid nested type outer inner checks whether the nested type is taking valid types in its inner and outer type based on P4's description of type nesting rules section 7.2.7 (provide link).
insert type var adds a type variable to the env.
lookup extern in env returns an externMethods type which includes a list of strings as
type parameters which must be empty for it to be well-typed and a function type which doesn't care for function type.
getTypeParams get type parameters from types that have type parameters including package, control, parser, function, and it's equivalent to look up for extern.

names to type env. 
~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Bool]
     { }
     { \typWellFormed \boolTyp }

  \inferrule[String]
     { }
     { \typWellFormed \stringTyp }

  \inferrule[(InfinitPrecision)Integer]
     { }
     { \typWellFormed \integerTyp }

  \inferrule[SignedInteger]
     { 1 < \width}
     { \typWellFormed {\intWidthTyp \width} }

  \inferrule[BitString(UnsignedInteger)]
     { 0 \leq \width}
     { \typWellFormed {\bitWidthTyp \width} }

  \inferrule[VarBit(DynamicallySizedBitString)]
     { }
     { \typWellFormed {\varBitTyp \width} }

  \inferrule[Error]
     { }
     { \typWellFormed \errTyp}

  \inferrule[Void]
     { }
     { \typWellFormed \voidTyp}

  \inferrule[MatchKind]
     { }
     { \typWellFormed \matchKindTyp}

  \inferrule[Array]
     { \typWellFormed \typ \\
       \isValidNestedTyp {\arrayTyp \typ \size} {\typ}}
     { \typWellFormed {\arrayTyp \typ \size} }

  \inferrule[Tuple]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp {\tupleTyp {\typ_1} {\typ_n}} {\typ_i}}
     { \typWellFormed {\tupleTyp {\typ_1} {\typ_n}} }

  \inferrule[List]
     { 1 \leq i \leq; \typWellFormed {\typ_i} \\
       1 \leq i \leq; \isValidNestedTyp {\listTyp {\typ_1} {\typ_n}} {\typ_i}}
     { \typWellFormed {\listTyp {\typ_1} {\typ_n}} }

  \inferrule[Set]
     { \typWellFormed \typ }
     { \typWellFormed {\setTyp \typ} }

  \inferrule[EnumWithType]
     { \typWellFormed \typ }
     { \typWellFormed \enumTyp }

  \inferrule[EnumWithoutType]
     {  }
     { \typWellFormed \enumTypNoTyp }

  \inferrule[Record]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \recordTypDef {\typ_i} \\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \recordTypDef }

  \inferrule[HeaderUnion]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \headerUnionTyp {\typ_i} \\
       % \noDup {\field_1, \ldots, \field_n}\\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \headerUnionTyp }

  \inferrule[Struct]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \structTypDef {\typ_i} \\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \structTypDef }

  \inferrule[Header]
     { 1 \leq i \leq n; \typWellFormed {\typ_i} \\
       1 \leq i \leq n; \isValidNestedTyp \headerTypDef {\typ_i} \\
       1 \leq i < j \leq n; \field_i \neq \field_j}
     { \typWellFormed \headerTypDef }

  \inferrule[NewType(typedef)]
     { \typWellFormed \typ }
     { \typWellFormed {\newTypeTyp \typ \name} }

\end{mathpar}
~~
~

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[SpecializedType]
     { \prim \typ = \sat \typ \\
       \{\param_1, \ldots, \param_m \} = \getTypeParams {\prim \typ} \\
       % \prim \typ = \externTyp \name \\
       %  ([\param_1, \ldots, \param_m], _)= \lookup \name \\
        1 \leq i \leq n; \typWellFormed {\typ_i} \\
        n = m}
     { \typWellFormed {\spcTyp \typ {\typ_1, \ldots, \typ_n}} }

  \inferrule[Package]
     { \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \dir_i = \less \\
       1 \leq i \leq n; \typWellFormed {\typ_i}}
     { \typWellFormed {\packageTyp {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n} {\wildcardParam_1, \ldots, \wildcardParam_p}} }

  \inferrule[Control]
     { \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_i}}
     { \typWellFormed {\controlTyp {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n} } }

  \inferrule[Parser]
     { \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_i}}
     { \typWellFormed {\parserTyp {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n} } }

  \inferrule[Extern]
     { ([], {\funcTyp \typ {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n}} ) =\lookupEnv \name }
     { \typWellFormed {\externTyp \name} }

  \inferrule[Function]
     { \typWellFormed \typ \\
       \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_n} }
     % <return type> <function name>(x1,...,xn) {...}
     { \typWellFormed {\funcTyp \typ {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n}} }

  \inferrule[Action]
     { i < j \\
       1 \leq k \leq n; \typWellFormed {\typ_k} \\
       j \leq k \leq n; \dir_k = \less }
     { \typWellFormed {\actionTyp {\prm 1, \ldots, \prm i} {\prm j, \ldots, \prm n}} }

  \inferrule[Constructor]
     { \typWellFormed \typ \\
       \prim \env = \insertTypVars {\param_1, \ldots, \param_n} \\
       1 \leq i \leq n; \typWellFormedWithEnv {\prim \env} {\typ_n} }
     { \typWellFormed {\constructorTyp \typ \name {\prm 1, \ldots, \prm n}} }

  \inferrule[Table]
     { \typ = \lookupEnv \name }
     { \typWellFormed {\tableTyp \name} }

  \inferrule[TypeName]
     { \typ = \lookupEnv \name }
     { \typWellFormed {\typNameTyp \name} }

% is_well_formed_type
\end{mathpar}
~~
~

### Type Equality Judgment { #sec-type-eq }
**TODO**: refer to type_equality and solve_types functions in impl. For type equality of p4 spec refer to to section 8, under each operation there's a one liner that talks about when two types are equal for the type it's covering. 

## Statement's Typing Rules { #sec-stmt-typing }
this judgment type checks a statment written in surface syntax, generates the IR statement from it and if applicable updates the env and ctxt.
is_lvalue checks if an IR expression is lvalue. 
cast_expr takes a type and surface syntax expression. after generating the IR expression by type_expression, it checks if the given type and type of IR expression are equal it just returns the IR exp o.w. it casts (if possible) the IR expression to the given type.
if void type  returns a void type if a (or two) type is (are) void and otherwise returns a unit type.
get enum typ takes a type and checks if it's an enum. if so it returns the enums of it. 

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Assignment]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \isLval {{\prim {\exp_1}}, {\typ_1}, {\dir_1}} \\ 
       ({\prim {\exp_2}}, {\typ_2}, {\dir_2}) = \castExpression {\typ_1} {\exp_2}\\
       % \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
       % \typ_1 = \typ_2 \\
       }
     { \stmtenv {\assign {\exp_1} {\exp_2}} {\assign {\prim {\exp_1}} {\prim {\exp_2}}} {\unitTyp} }


  \inferrule[Empty]
     { }
     { \stmtenv {\noop} {\noop} {\unitTyp}}

  \inferrule[Block]
     { \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 \\
       \prim \typ = \ifVoidTyp {\typ_1} \\
       \stmtenvv 2 {\stmts} {\prim \stmts} {\prim \typ} 3 }
     { \stmtenvv 1 {\block {\stmt_1; \stmts} } {\block {\prim {\stmt_1}; {\prim \stmts}} } {\prim \typ} 3 }

  \inferrule[Return(inApplyBlockOrAction)]
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \applyBlockCtxt \textOr \actionCtxt \\
       ({\prim {\exp}}, {\typ}, {\dir}) = \castExpression {\voidTyp} {\exp}\\
       }
     { \stmtenv {\return \exp} {\return {({\prim {\exp}}, {\typ}, {\dir})}} \voidTyp  }

  \inferrule[ReturnEmpty]
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \applyBlockCtxt \textOr \actionCtxt \textOr \funcCtxt \typ \\
       }
     { \stmtenv {\return {}} {\return {}} \voidTyp  }

  \inferrule[Return(inFunction)]
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \funcCtxt \typ \\
       ({\prim {\exp}}, {\prim \typ}, {\dir}) = \castExpression {\typ} {\exp}\\
       }
     { \stmtenv {\return \exp} {\return {({\prim {\exp}}, {\prim \typ}, {\dir})}} \voidTyp  }

  \inferrule[Exit]
     { \ctxt \neq \parserCtxt }
     { \stmtenv \exit \exit \voidTyp}

  \inferrule[IfThen]
     { \ctxt \neq \parserCtxt \\
       (\prim \exp, \boolTyp, \dir) = \castExpression \boolTyp \exp \\
       \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 }
     { \stmtenvv 1 {\ifthen \exp {\stmt}} {\ifthen {\prim \exp} {\prim \stmt} } {\unitTyp} 1 }

  \inferrule[IfThenElse]
     { \ctxt \neq \parserCtxt \\
       (\prim \exp, \boolTyp, \dir) = \castExpression \boolTyp \exp \\
       \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 \\
       \stmtenvv 1 {\stmt_2} {\prim {\stmt_2}} {\typ_2} 3 \\
       \prim \typ = \ifVoidTyp {\typ_1, \typ_2}}
     { \stmtenvv 1 {\ifthenelse \exp {\stmt_1} {\stmt_2}} {\ifthenelse {\prim \exp} {\prim {\stmt_1}} {\prim {\stmt_2}} } {\prim \typ} 1 }

  \inferrule[Switch]
     { \ctxt_0 = \applyBlockCtxt \\
       \expenvv \exp {\prim \exp} \typ \dir 0 \\
       \prim \typ = \reduce \typ \\
       \name_1, \ldots, \name_m = \getEnum {\prim \typ} \\
       \lbl \notin \overline \lbl \\
       \lbl \in \{\name_1, \ldots, \name_m \}\\
       \stmtenvv 0 {\block {\stmts}} {\block {\prim {\stmts}}} {\typ_0} 1 \\
       \stmtenvv 1 {\switch \exp {\overline {\actionCase \stmt}}} {\switch {\prim \exp} {\overline {\actionCase {\pprim \stmt} }}} \unitTyp 2
       }
     { \stmtenvv 0 {\switch \exp {\actionCase \stmts, \overline {\actionCase \stmt}} } {\switch {\prim \exp} {\actionCase {\prim \stmts}, {\overline {\actionCase {\pprim \stmt} }} } } \unitTyp 2 }

  \inferrule[Declaration]
     { \isConstant \dcl \textOr \isInstantiation \dcl \textOr \isVariable \dcl \\
       \dclenvv 0 \dcl {\prim \dcl} 1}
     { \stmtenvv 0 \dcl {\prim \dcl} \unitTyp 1 }

\end{mathpar}
~~
~


## Declaration's Typing Rules { #sec-decl-typing }
is allowed type for variable checks if a type is allowed for declaring a variable. it includes all types after saturation except for string, integer, list, set, void, specialized type, package, control, parser, extern, function, action, constructor, and table.
check parameter shadowing takes two lists of paramets and checks if there is any duplicate in them. 

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Constant]
     { \prim \typ = \trans \typ \emp \\
       (\prim \exp, \pprim \typ, \dir) = \castExpression \exp {\prim \typ}\\
       \val = \compileTimeEval {\prim \exp} }
     { \dclenvvv {\const \typ \var \exp} {\const {\prim \typ} \var \val} {\addConstEnv \var \val} {\addTypeEnv \var {(\prim \typ, \less)}}}

  \inferrule[Instantiation]
     { \expenv {\instantiation {\var} \args} {\instantiation {\var} {\prim \args}} {\prim \typ} \dir \\
       \ctxt \neq \toplevel \textOr \ctxt = \toplevel, ({\prim \typ} \neq \controlTyp {\_} {\_} \textOr \parserTyp {\_} {\_} )}
     { \dclenvvv {\inst \typVar \args \var {\ } } {\inst \typVar \args \var {\ }} \constEnv {\addTypeEnv \var {(\prim \typ, \less)}} }

  \inferrule[Parser]
    {}
    {blah}
     % { \checkParamShadow param constructorparam \\
     %   }
     % { \dclenvvv {} {} {} {} }

  \inferrule[Control]
     { blah }
     { blah }

  \inferrule[Function]
     { blah }
     { blah }

  \inferrule[Action]
     { blah }
     { blah }

  \inferrule[ExternFunction]
     { blah }
     { blah }

  \inferrule[Variable]
     { \ctxt \neq \toplevel \\
       \prim \typ = \trans \typ \emp \\
       \allowedTypeForVar {\prim \typ} \\
       \typWellFormed {\prim \typ}}
     { \dclenvvv {\varDecl \typ \var } {\varDecl {\prim \typ} \var} \constEnv {\addTypeEnv \var {(\prim \typ, \inout)}} }

  \inferrule[VariableInit]
     { \ctxt \neq \toplevel \\
       \prim \typ = \trans \typ \emp \\
       \allowedTypeForVar {\prim \typ} \\
       \typWellFormed {\prim \typ} \\
       (\prim \exp, \prim \typ, \dir) = \castExpression  {\prim \typ} \exp}
     { \dclenvvv {\varInit \typ \var \exp} {\varInit {\prim \typ} \var {(\prim \exp, \prim \typ, \dir)}} \constEnv {\addTypeEnv \var {(\prim \typ, \inout)}} }

  \inferrule[ValueSet]
     { blah }
     { blah }

  \inferrule[Table]
     { blah }
     { blah }

\end{mathpar}
~~
~

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[Header]
     { blah }
     { blah }

  \inferrule[HeaderUnion]
     { blah }
     { blah }

  \inferrule[Struct]
     { blah }
     { blah }

  \inferrule[Error]
     { blah }
     { blah }

  \inferrule[MatchKind]
     { blah }
     { blah }

  \inferrule[Enum]
     { blah }
     { blah }

  \inferrule[SerializableEnum]
     { blah }
     { blah }

  \inferrule[ExternObject]
     { blah }
     { blah }

  \inferrule[TypeDef]
     { blah }
     { blah }

  \inferrule[NewType]
     { blah }
     { blah }

\end{mathpar}
~~
~

~ Center  {padding:1ex}
~~ Snippet
\begin{mathpar}
  \small

  \inferrule[ControlType]
     { blah }
     { blah }

  \inferrule[ParserType]
     { blah }
     { blah }

  \inferrule[PackageType]
     { blah }
     { blah }

  % \inferrule[ ]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

\end{mathpar}
~~
~


