Title         : Petr4 Type System Formalization
Title Footer  : &date;
Author        : Petr4 Team
Affiliation   : Cornell University
Heading depth : 5
Cite Style    : numeric
BibTex        : False
Bib           : reference

Math Mode       : static
Pdf Latex       : xelatex
Math Latex Full : pdflatex

Document Class : [11pt]article

Package : mathtools
Package : fancyhdr
Package : mathpartir


Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

.code: background-color=Gainsboro
.code2: background-color=LightCoral
.code3: background-color=Fuchsia

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
infrule {
  replace: "~ Begin InfRuleBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #fffaf0;
  border-width: 0.5pt;
}
}

@if tex {
infrule {
  replace: "~ Begin InfRuleBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #fffaf0;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
infrulehelper {
  replace: "~ Begin InfRuleHelperBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleHelperBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #ECE1FB;
  border-width: 0.5pt;
}
}

@if tex {
infrulehelper {
  replace: "~ Begin InfRuleHelperBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleHelperBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #ECE1FB;
  border: solid;
  border-width: 0.5pt;
}
}


~Aligned : replace:"~Math&nl;\begin{aligned}&nl;&source;&nl;\end{aligned}&nl;~" 


[TITLE]


~ Begin Abstract
P4's type system is currently distributed between its language specification and its reference implementation p4c. Unfortunattely, this state of affairs results in ambiguity while reasoning through the behavior of a P4 program, evident from the many issues opened on P4's GitHub repo. 
In this document, we provide a formalization of P4's type system to unify the expected behavior of P4 programs. 
The target audience of this document includes language designers and compiler experts
that work (or starting to work) on P4 as well as developers and debuggers that work
with P4 and require a deep understanding of it.
~ End Abstract

~ MathDefs
[INCLUDE="ops.tex"]
~


[TOC]

# Introduction { #sec-intro }

P4's type system is currently distributed between its [language specification][p4spec] and its [reference implementation][p4cgit](p4c).
P4 spec explains the type of (sub)programs in plain English
while p4c implements a type system for P4.
There are multiple problems with both:

[p4spec]: https://p4.org/p4-spec/docs/P4-16-v1.2.0.html
[p4cgit]: https://p4.org/p4-spec/docs/P4-16-v1.2.0.html

1. Figuring out how a program behaves and whether it type checks or not is extremely hard. In P4 spec, one has to jump from place to place to find whether each part of the program type checks or not since information regarding type checking a program is staggered all over the place and even worse in some cases it is missing. In p4c, one has to either write a sample program and compile it to see if it type checks or they have to go through all p4c's code to figure out the behavior of their program. For example, ``todo: add github issues. add number of loc of p4c.``
2. Adding a new feature to P4 requires extending its type system and often times results in revising parts of the current type system as well. Doing so for both P4 spec and p4c is rather burdensome and error-prone due to the distribution of explanation in P4 spec and implementation in p4c. 
3. Even more concerning, despite lots of effort by the P4 language committee, there are discrepnecies between P4 spec and p4c's implementation. For example, ``TODO: add github issues``

In this document, we formalize P4's type system. Formalizing P4 benefits the communit in different ways

1. It makes working with and on P4 easier for both people who are just picking it up and those who have been working with/on it for some time. This is because clear formalization makes understanding a language and the behavior of programs written in it less cumbersome. 
2. It provides a place for experts and users to refer to check the behavior of a program. It also provides a unified place for ensuring all references and implementations of P4 are consistent with each other.
3. It provides the bases for formally verifying P4's compilers and interpretors.


# Overview { #sec-overview }

A P4 program is mainly a list of declarations and a declaration could be declaring a
parser or control plane, instantiating an object, calling a (extern) function or method,
and defining a type or an object. Each declaration may contain multiple statements and
expressions within it.
Thus, in order to formalize P4's type system we need to:

- have consisten and clear [notation][#sec-notation]
- formalize [P4's syntax][#sec-syntax]
- formalize type related rules, including [type well-formedness][#sec-type-well-formed], [type equality][#sec-type-eq], [type unification][#sec-type-unify]
- formalize [expressions typing][#sec-exp-typing]
- formalize [statements typing][#sec-stmt-typing]
- formalize [declarations typing][#sec-decl-typing]

Furthermore, for readers who are less familiar with programming languages fundamentals we provide a [summary of programming languages terminology][#sec-terminology] and a [developer's guide to reading inference rules][#sec-guide].

Additionally, for developers and experts starting to work on Petr4 we provide a summary of its architecture and connect P4's formalization to Petr4's implementation in Appendix[#sec-petr4].

# Notation { #sec-notation }

In this section, we introduce the notation and naming convention that we use throughout this document. 

## Naming Convention
Each typing judgment may use auxiliary judgment and helper functions. The auxiliary
judgments are included in this document while the helper functions are just explained
in plain English.

Conventionally, in this document we accompany rule names with four possible suffixes:

- $\ruleNameT$ indicates that the rule is describing a rule for a type
- $\ruleNameE$ and $\ruleNameAE$ indicate that the rules are for an expression and an auxiliary judgment for an expression
- $\ruleNameS$ indicates that the rule is describing a rule for a statement
- $\ruleNameD$ indicates that the rule is describing a rule for a declaration

## rest

``TODO: add followings.``

- $\overline {\overline \anyTyp}$
- $\overline {X:\typ}$ zips $\overline X$ and $\typs$.
- $\concatList a b$

Metavariables are place holders for values of a type. For example, $\bool$ stands for expressions $true$ or $false$. Keep in mind that $true$ and $false$ both are expressions that have the type $\boolTyp$. As another example, in most programming references $foo$, $bar$, and $baz$ are used as metavariables, often for functions. 

- $\overline x$ denotes a list of $x$.
- For simplicity, we omit mapping a function/judgment on a list of elements. Instead, we just apply the function/judgment to a list. So every time you see a function applied to a list, read it as mapping the function over all the elements of the list. 
- An underscore (that is, $\_$) is used when we do not need to use some specific information returned by some helper in judgements. 
- The notation $\maybe \anyTyp$ denotes an optional type, that is, the type of $\anyTyp$ has been extended with bottom (maybe type in Haskell, or option type in Ocaml). So if $\anyTyp$ denotes an integer, $\maybe \anyTyp$ could either be an integer number or bottom. 

The following describes the metavariables used in this document:

~ Center
| **metavariable**   |   **type represented** |
|:----------------:|:------------------|
| $\bool$ | booleans |
| $\str$ | strings |
| $\int$ | arbitrary length integer |
| $\width$ | width of a data structure |
| $\size$ | size of a data structure |
| $\bitWidth \bit \width$ | fixed length integer |
| $\intWidth \int \width$ | signed integer |
| $\name$ | strings represing any kinds of names |
| $\typ$ | types |
| $\dir$ | directions |
| $\typVar$ | type variables |
| $\wildcardParam$ | wild card type parameters |
| $\field$ | field names |
| $\env$ | environments |
| $\emp$ | empty list of elements |
| $\anyTyp$ | a value of any type |
| $\constraint$, $\optConstraint$, $\nonoptConstraint$ | constraints |
~


## Signatures
``TODO``
function signature. judgment signature. environment signature. 

## contexts and environments

# Syntax { #sec-syntax }

# Type Related Judgments { #sec-types-typing }

Types themselves are elements of a language and it is often needed to ensure the lack of specific errors in types, such a type is called _well-formed type_.
Additionally, it is sometimes required to check two types for equality. Petr4's type equality considers alpha equivalent[^alpha-equiv-wiki] types equal. 

[^alpha-equiv-wiki]: <<https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence>>


## Type Well-Formed Judgment { #sec-type-well-formed }

This judgment checks if a type is well-formed. Note that this judgment is defined over the types defined in the IR and not the surface syntax.
It has the form $\typWellFormed \typ$ which states that the type $\typ$
is well-formed under the environment $\env$, that is, the type is syntactically correct.

All typing rules first saturate all types,
that is, it eliminates all type references in type
$\typ$ and replaces them with the type they refer to. Thus, the result of saturation
contains no type synonym (_TypeName_ in Petr4) constructors that are used to give a name to a new type. Then it checks the well-formedness of the saturated type.
For breviety, we don't include the saturation in rules.

### Base Types { #sec-base-t }

The following base types are well-formed unconditionally since there is not any room for an error while constructing a value of these types. For example, the $\boolTyp$ only has two constructors $\mathit{true}$ and $\mathit{false}$ which do not take any arguement so there is no room to construct a value incorrectly.

~ Begin InfRule

  \inferrule
     { }
     { \typWellFormed \boolTyp }
     \quad (\boolT)

  \inferrule
     { }
     { \typWellFormed \stringTyp }
     \quad (\stringT)

  \inferrule
     { }
     { \typWellFormed \integerTyp }
     \quad (\intT)

  \inferrule
     { }
     { \typWellFormed {\varBitTyp \width} }
     \quad (\varbitT)

  \inferrule
     { }
     { \typWellFormed \errTyp}
     \quad (\errT)

  \inferrule
     { }
     { \typWellFormed \voidTyp}
     \quad (\voidT)

  \inferrule
     { }
     { \typWellFormed \matchKindTyp}
     \quad (\matchKindT)

~ End InfRule

``**DISCUSSION**
Petr4 doesn't check the length of a fixed-length integer, either signed or unsigned. However, P4 spec specifies that for signed integers the length must be more than 1 and for unsigned integers the length must be equal or more than zero.``

~ Begin InfRule

  \inferrule
     % { 1 < \width} % p4 spec has this
     { }
     { \typWellFormed {\intWidthTyp \width} }
     \quad (\intWidthT)

  \inferrule
     % { 0 \leq \width} % p4 spec has this
     { }
     { \typWellFormed {\bitWidthTyp \width} }
     \quad (\bitWidthT)

~ End InfRule

### Array Type { #sec-array-t }

An array type has a specific type and size.
The rule $\arrayT$ states that under environment $\env$, an array is well-formed if its
type is well-formed and it follows the nesting rules of P4.

- $\isValidNestedTyp \typ$ checks whether the nested type $\typ$ is valid, that is,
it checks if all the subtypes in the type $\typ$ can actually be inner types of $\typ$ based on [P4's description of type nesting rules][sec7-2-7].

[sec7-2-7]: https://p4.org/p4-spec/docs/P4-16-v1.2.0.html#sec-type-nesting 

~ Begin InfRule

  \inferrule
     { \typWellFormed \typ \\
       \isValidNestedTyp {\arrayTyp \typ \size}}
     { \typWellFormed {\arrayTyp \typ \size} }
     \quad (\arrayT)

~ End InfRule

### Tuple Type { #sec-tuple-t }

Each element of a tuple can have a distinct type so a tuple type is simply a list of types. Note that lists also have a tuple type. The rule $\tupleT$ states that under
environment $\env$, a tuple type is well-formed if all its types are well-formed and it
follows the nesting typing rules of P4. 

~ Begin InfRule

  \inferrule
     { \typWellFormed \typs \\
       % \forallcond \typ \typs
        \isValidNestedTyp {\tupleTyps \typs}}
     { \typWellFormed {\tupleTyps \typs} }
     \quad (\tupleT)

  % \inferrule[List]
  %    { 1 \leq i \leq n. \typWellFormed {\typ_i} \\
  %      1 \leq i \leq n.  \isValidNestedTyp {\listTyp {\typ_1} {\typ_n}} {\typ_i}}
  %    { \typWellFormed {\listTyp {\typ_1} {\typ_n}} }

~ End InfRule

### Set Type { #sec-set-t }

In P4, unlike tuples, elements of a set must all have the same type and the set type is well-formed if the type of its elements is well-formed, which is stated by the $\setT$ rule.

~ Begin InfRule

  \inferrule
     { \typWellFormed \typ }
     { \typWellFormed {\setTyp \typ} }
     \quad (\setT)

~ End InfRule

### Enumeration Type { #sec-enum-t }

An enumeration type contains a number of constants of string type and its declaration introduces a new identifier in the current naming scope. It could also have an underlying representation which states what is the type of its constants.
The rules below state that an enum type is well-formed if the underlying representation is well-formed, if it has one. 


``**DISCREPENCY**``
Petr4 doesn't allow for an enum to have default values for constants, however, P4 spec does. Here's an [example][enum-ex].

[enum-ex]: https://p4.org/p4-spec/docs/P4-16-v1.2.0.html#sec-enum-types


~ Begin InfRule

  \inferrule
     { }
     { \typWellFormed \enumTypNoTypDef }
     \quad (\enumOneT)

  \inferrule
     { \typWellFormed \typ }
     { \typWellFormed \enumTypDef }
     \quad (\enumTwoT)

~ End InfRule

### Record Type { #sec-record-t }

A record has zero or more fields, which each field has a name and a type.
The rule $\recordT$ states that a record type is well-formed if all its fields have well-formed types, all fields have types that can be nested in a record, and fields have distinct names. 

Note that headers, header unions, and struct also have a record type.

- $\noDup \names$ checks that there is no duplicate name in $\names$.

~ Begin InfRule
  \inferrule
     { \typWellFormed \typs \\
       \isValidNestedTyp \recordTyps \\
       \noDup \fields}
       % 1 \leq i \leq n. \typWellFormed {\typ_i} \\
       % 1 \leq i \leq n. \isValidNestedTyp \recordTypDef \\
       % 1 \leq i < j \leq n. \field_i \neq \field_j}
     { \typWellFormed \recordTyps }
     \quad (\recordT)

  % \inferrule[HeaderUnion]
  %    { 1 \leq i \leq n. \typWellFormed {\typ_i} \\
  %      1 \leq i \leq n. \isValidNestedTyp \headerUnionTyp {\typ_i} \\
  %      % \noDup {\field_1, \ldots, \field_n}\\
  %      1 \leq i < j \leq n. \field_i \neq \field_j}
  %    { \typWellFormed \headerUnionTyp }

  % \inferrule[Struct]
  %    { 1 \leq i \leq n. \typWellFormed {\typ_i} \\
  %      1 \leq i \leq n. \isValidNestedTyp \structTypDef {\typ_i} \\
  %      1 \leq i < j \leq n. \field_i \neq \field_j}
  %    { \typWellFormed \structTypDef }

  % \inferrule[Header]
  %    { 1 \leq i \leq n. \typWellFormed {\typ_i} \\
  %      1 \leq i \leq n. \isValidNestedTyp \headerTypDef {\typ_i} \\
  %      1 \leq i < j \leq n. \field_i \neq \field_j}
  %    { \typWellFormed \headerTypDef }

~ End InfRule

### New Type Type { #sec-newtype-t }

New type assings a name to a type. So the $\newTypeT$ checks if the assignee type $\typ$ is well-formed.

~ Begin InfRule

  \inferrule
     { \typWellFormed \typ }
     { \typWellFormed {\newTypeTyp \typ \name} }
     \quad (\newTypeT)

~ End InfRule

### Specialized Type { #sec-specialized-t }

An specialized type specifies the types of parameters in a generic type, the underlying generic type in an specialized type is called the base type. An specialized type is necessary when the compiler cannot infer type arguments.

The rule $\specializedExternT$ states that the specialization of an extern type is well-formed if the extern $\name$ exists in the environment $\env$ and the specialization specifies the type of all its type parameters. Similarly, the rule $\specializedRestT$ states that the specialization of a package/control/parser/function is well-formed if it specifies the type of all its type parameters.

- Looking up an extern in the environment (that is, $\lookupEnv \name$) returns its type parameters and methods. Since the rule $\specializedExternT$ only cares about the parameters we do not care about the methods, thus, we don't assign a variable name to it and use an underscore instead of it. 


- $\lookupEnv \name$ looks up a variable $\name$ in environment $\env$ and depending on what $\name$ represents returns what is assigned to the variable in the environments. In case of an extern, it returns the type parameters and methods of the extern. 
- $\getTypeParams \typ$ returns the type parameters from types that have type parameters including package, control, parser, and function.

~ Begin InfRule

  \inferrule
     { \lookupEnv \name = ([\params], \_ ) \\
        % 1 \leq i \leq n. \typWellFormed {\typ_i} \\
        \typWellFormed \typs\\
        |\typs| = |\params|}
     { \typWellFormed {\spcTyp {\externTyp \name} \typs} }
     \quad (\specializedExternT)


  \inferrule
     { \getTypeParams \typ = \{\params\}\\
        \typWellFormed {\typs} \\
        |\params| = |\typs|}
     { \typWellFormed {\spcTyp \typ {\typs}} }
     \quad (\specializedRestT)

~ End InfRule

### Package Type { #sec-package-t }

A package type describes the signature of a package and it defines the type parameters and parameters of a package. It may also have wildcard parameters. ```TODO: question for Ryan, what's the purpose of them?```
The rule $\packageT$ states that a package type is well-formed under the environment $\env$ extended with the package's type parameters if all its parameters are directionless and their types are well-formed. 

- A parameter $\singleprm$ has direction $\dir$, type $\typ$, and name $\name$. 
- $\insertToEnvv {\overline {\typParam : \typNameTyp \typParam}}$ extends the environment $\env$ with type variables $\typParams$. Note that the type inserted in the environement for type variables is a type name.
- $\isDirectionless \dir$ checks that the direction $\dir$ is $\less$, that is, $\dir = \less$.

~ Begin InfRule

  \inferrule
     { \isDirectionless \dirs \\
       % 1 \leq i \leq n. \dir_i = \less \\
       1 \leq i \leq n. \typWellFormedWithEnv {\insertToEnvv {\overline {\typParam : \typNameTyp \typParam}}} {\typ_i}}
     { \typWellFormed {\packageTyp {\typParams} {\prms} {\wildcardParams}} }
     \quad (\packageT)

~ End InfRule

### Control Type { #sec-control-t }

A control type is similar to a type signature of a function in that it defines the type parameters used in the control and its parameters, however, it does not have a return type. The rule $\controlT$ states that the control type is well-formed under the environment $\env$ extended with type variables $\typParams$ if all the types of its parameters are well-formed.

Parsers also have a control type.

``**DISCREPENCY**
P4 spec states that "The types parser, control, and package cannot be used as types of arguments for methods, parsers, controls, tables, actions. They can be used as types for the arguments passed to constructors." We could check this in the well-formedness of types or even when we're declaring a method, parser, control, table, or action, instead of when we're defining their type (make sure we're not checking it then).`` ([p4 spec ref][parser-type])

[parser-type]: https://p4.org/p4-spec/docs/P4-16-v1.2.0.html#sec-parser-control-types

~ Begin InfRule

  \inferrule
     {\typWellFormedWithEnv {\insertToEnvv {\overline {\typParam : \typNameTyp \typParam}}} {\typs}}
       { \typWellFormed {\controlTyp {\typParams} {\prms} } }
       \quad (\controlT)

  % \inferrule[Parser]
  %    { \prim \env = \insertTypVars {\typParam_1, \ldots, \typParam_m} \\
  %      1 \leq i \leq n. \typWellFormedWithEnv {\prim \env} {\typ_i}}
  %    { \typWellFormed {\parserTyp {\typParam_1, \ldots, \typParam_m} {\prm 1, \ldots, \prm n} } }

~ End InfRule

### Extern Type { #sec-extern-t }

The rule $\externT$ states that an extern type is well-formed if it has no type parameter in the environment. 
lookup extern in env returns an externMethods type which includes a list of strings as
type parameters which must be empty for it to be well-typed and a function type which doesn't care for function type.

```**DISCUSSION**
This seems way too simple and loose.```

~ Begin InfRule

  \inferrule
     { \lookupEnv \name = (\emp, \_ )}
     { \typWellFormed {\externTyp \name} }
     \quad (\externT)

~ End InfRule

### Function Type { #sec-func-t }

A function type describes the return type of the function, its type parameters, and its parameters. The rule $\functionT$ states that the function type is well-formed if its return type is well-formed and the types of its parameters are well-formed under environment $\env$, extended with function's type parameters. 

~ Begin InfRule

  \inferrule
     { \typWellFormed \typ \\
       \typWellFormedWithEnv {\insertToEnvv {\overline {\typParam : \typNameTyp \typParam}}} \typs}
       % 1 \leq i \leq n. \typWellFormedWithEnv {\insertToEnvv {\overline {\typParam : \typNameTyp \typParam}}} {\typ_i} }
     % <return type> <function name>(x1,...,xn) {...}
     { \typWellFormed {\funcTyp \typ {\typParams} {\prms}} }
     \quad (\functionT)

~ End InfRule

### Action Type { #sec-action-t }

An action type defines data and control parameters and it is well-formed if the types of all parameters are well-formed and the control parameters are directionless.

~ Begin InfRule

  \inferrule
     {  \typWellFormed {\typs} \\
        \typWellFormed {\overline {\prim \typ}} \\
       \isDirectionless \dirs \\
       \isDirectionless {\overline {\prim \dir}}}
     { \typWellFormed {\actionTyp {\prms} {\prmss}} }
     \quad (\actionT)

~ End InfRule

### Constructor Type { #sec-constructor-t }

The rule $\constructorT$ states that a constructor type is well-formed if its return type $\typ$ is well formed and the types of its parameters are well-formed under the environment $\env$ extended with the constructor's type parameters. Note that \_ indicates the wildcard parameters. 

~ Begin InfRule

  \inferrule
     { \typWellFormed {\typ_\ret} \\
       % \prim \env = \insertTypVars {\param_1, \ldots, \param_n} \\
       \typWellFormedWithEnv {\insertToEnvv {\overline {\typParam : \typNameTyp \typParam}}} {\typs} \\
       \isDirectionless {\dirs}}
     { \typWellFormed {\constructorTyp \typParams \prms \wildcardParams {\typ_\ret}}}
     \quad (\constructorT)

~ End InfRule

### Table Type { #sec-table-t }

A table type is well-formed under an environment if it exists in the environment.

- Looking up type variables returns the type assigned to it.

~ Begin InfRule

  \inferrule
     { \lookupEnv \name = \typ}
     { \typWellFormed {\tableTyp \name} }
     \quad (\tableT)

~ End InfRule

### Typename Type { #sec-typename-t }

The rule $\typeNameT$ states that the type name $\name$ is well-formed under the environment $\env$ if it exists in the environment.

~ Begin InfRule

  \inferrule
     { \lookupEnv \name = \typ}
     { \typWellFormed {\typNameTyp \name} }
     \quad (\typeNameT)

~ End InfRule

## Type Equality Judgment { #sec-type-eq }
```**TODO**: refer to type_equality and solve_types functions in impl. For type equality of p4 spec refer to to section 8, under each operation there's a one liner that talks about when two types are equal for the type it's covering. ```

- The [type equality judgment][#sec-type-eq] checks the equality of two types. It has
the form $\typEqEnv {\overline {(\var, \prim \var)}} {\typ_1} {\typ_2} $ which states that the types $\typ_1$ and $\typ_2$ are equaivalent under the environment $\env$ with equivalent variable pairs $\overline {(\var, \prim \var)}$. Note that Alpha equivalent types are equivalent. 


## Type Unification { #sec-type-unify }

- type unification for type produces by type checking, i.e., typed.type.t
- both types are reduced first. for breviety we omit the reduction from rules. so type 1 and type 2 in rules are already reduced.

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \boolTyp \boolTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Bools})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \stringTyp \stringTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Strings})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \integerTyp \integerTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Integers})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \errTyp \errTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Errors})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \matchKindTyp \matchKindTyp {\overline {\typVar : \bot}}}
     \quad (\rn{MatchKinds})}

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \voidTyp \voidTyp {\overline {\typVar : \bot}}}
     \quad (\rn{Voids})}

~ End InfRule


~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Specializeds})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{TypeNames})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{NewTypes})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{FixedLengths})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Arrays})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Tuples})}

~ End InfRule

~ Begin InfRule

% check which one of record, header, header union, struct you used in well-formedness.
  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Records})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Sets})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Enums})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Packages})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Controls})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Parsers})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Externs})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Actions})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Functions})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Constructors})}

~ End InfRule

~ Begin InfRule

  \mprset {vskip=0.7ex}
    {\inferrule
       { }
       { \unify \env \typeEqs \typVars \ \ {\overline {\typVar : \bot}}}
     \quad (\rn{Tables})}

~ End InfRule

``TODO: check see if you need implicit casting incorporated in unification of types.``

# Expression's Typing Rules { #sec-exp-typing }

The judgment form
$\expenv {\exp} {\prim \exp} \typ \dir $ states that expression $\exp$
written in surface syntax translates to expression $\prim \exp$ in the IR syntax with
the type $\typ$ and direction $\dir$ under environment $\env$. For now, we do not
present the syntax of the surface syntax and IR. Note that there is not much difference
between the two.

``**Restriction**``
Petr4 doesn't have the product operation where multiple sets can be combined using
cartesian product and the type of a product of sets is a set of tuples. (refer to
section 8.12.5. of P4 spec (**DISCUSS**))

``**NOTE**``
I couldn't find the followings in section 8 of p4 spec:
array access, bist string access, type member, anonymous instant (this is probably method invocation or sth).


## Boolean, String, and Integer Constructor Rules { #sec-base-const-e }

Base constructors such as boolean, string, and all integer constructors simply construct values of their type. 
The rule $\boolE$ states that a boolean expression in surface syntax has the type $\boolTyp$, it translates to the same boolean expression in the IR syntax, and has the $\less$ direction.
The rules $\stringE$, $\integerE$, $\bitStringE$, and $\signedIntE$ are similar to $\boolE$. 

~ Begin InfRule

  \inferrule
     { }
     {\expenv \bool \bool \boolTyp \less}
     \quad (\boolE)

  \inferrule
     { }
     {\expenv \str \str \stringTyp \less}
     \quad (\stringE)

  \inferrule
     { }
     {\expenv \int \int \integerTyp \less}
     \quad (\integerE)

  \inferrule
     { }
     {\expenv {\bitWidth \bit \width} {\bitWidth \bit \width} {\bitWidthTyp \width} \less}
     \quad (\bitStringE)

  \inferrule
     { }
     {\expenv {\intWidth \int \width} {\intWidth \int \width} {\intWidthTyp \width} {\less}}
     \quad (\signedIntE)

~ End InfRule

## Name Rule { #sec-name-e }

The rule $\nameE$ looks up the name of a variable from the environment and returns its type and direction. Note that if the environment doesn't contain the name the rule will fail.

- When $\lookupEnv \name$ looks up a variable name in the environment, it returns its type and direction. When we only need the
type or the direction of the variable we simply ignore the other one by using an underscore for it. So you could see
formalization such as $\lookupEnv \name = (\typ, \_ )$ which states that we looked up variable
$\name$ from the environment and we found out that its type is $\typ$. Similarly, the
formalization $\lookupEnv \name = (\typ, \dir)$ states that we looked up variable
$\name$ in the environment $\env$ and it has the type $\typ$ and direction $\dir$.

~ Begin InfRule

  \inferrule
     {\lookupEnv \name = (\typ, \dir)}
     {\expenv \name \name \typ \dir}
     \quad (\nameE)

~ End InfRule

## Array Access Rule { #sec-array-access-e }

$\arrayAccess {\exp_1} {\exp_2}$ denotes accessing the $\exp_2$^th^ element from the array $\exp_1$. 
The rule $\arrayAccessE$ states that expression $\arrayAccess {\exp_1} {\exp_2}$
translates to $\arrayAccess {\prim {\exp_1}} {\prim {\exp_2}}$
when $\exp_1$ has the array type $\arrayTyp \typ \size$ and $\exp_2$ has a numeric type. 

- $\mathit{is\_X} (\typ)$ checks if the type $\typ$ is of the specific kind/type/structure $X$.
For example, $\isNumeric \typ$
checks that the type $\typ$ is of numeric nature, that is, if it is fixed length signed or
unsigned integer or arbitrary precision integer.

~ Begin InfRule

  \inferrule
     {\expenv {\exp_1} {\prim {\exp_1}} {\arrayTyp \typ \size} \dir \\\\
      \expenv {\exp_2} {\prim {\exp_2}} {\prim \typ} {\prim \dir} \\\\
      % \isArray {\arrayTyp \typ \size} \\
      \isNumeric {\prim \typ}}
     {\expenv {\arrayAccess {\exp_1} {\exp_2}} {\arrayAccess {\prim {\exp_1}} {\prim {\exp_2}}} \typ \dir }
     \quad (\arrayAccessE)

~ End InfRule

## Bitstring Access (Slice) Rule { #sec-bitstring-slice-e }

$\bitStringAccess {\exp_1} {\exp_2} {\exp_3}$ denotes slicing a the bitstring $\exp_1$ from bit $\exp_2$ to $\exp_3$.
The rule $\bitStringAccessE$ states that accessing $\exp_2$ to $\exp_1$ from the bit string $\exp_1$ translates to accessing $\int_1$ to $\int_2$ from the bit string $\prim {\exp_1}$ which has the type bit string of length $\int_2 - \int_1$ if $\exp_1$ either has the type $\bitWidthTyp \width$ or $\intWidthTyp \width$ and both expressions $\exp_2$ and $\exp_3$ are of numeric types under the $\cte$ context and their values can be known at the compile time and the values respectively are $\int_1$ and $\int_2$. It only makes sense that when slicing (accessing) a bit string, the start $\int_1$ must be smaller than or equal to the end of access $\int_2$ and both must be smaller than the length of the bit string $\width$. 

- $\widthInt \typ$ checks if the type $\typ$ is a fixed-length integer, that is,
if it is either $\bitWidthTyp \width$ or $\intWidthTyp \width$ and returns its width. 
- $\sat \typ$ satuarates a type.
Remember that saturating a type eliminates all type references in type
$\typ$ and replaces them with the type they refer to. Thus, the result of saturation
contains no type synonym (_TypeName_ in Petr4) constructors that are used to give a name to a new type.
- $\reduce \typ $ saturates the type $\typ$ saturates a type first and then applies the arguments to the parameters of a specialized type that its base has parameters.
- $\compileTimeEval \exp$ evaluates the expression $\exp$ at compile time and returns its value if $\exp$ is a well-typed expression. 

~ Begin InfRule

  \inferrule
     {\expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\\\
      \expenvWithCtxt \cte {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\\\
      \expenvWithCtxt \cte {\exp_3} {\prim {\exp_3}} {\typ_3} {\dir_3} \\\\
      \widthInt {\reduce {\typ_1}} = \width \\\\
      % = \intWidthTyp \width \textOr \bitWidthTyp \width\\
      \isNumeric {\sat {\typ_2}} \\
      \isNumeric {\sat {\typ_3}} \\\\
      \compileTimeEval {\prim {\exp_2}} = \int_1 \\
      \compileTimeEval {\prim {\exp_3}} = \int_2 \\\\
      0 \leq \int_1 < \width \\
      \int_1 \leq \int_2 < \width
      }
     {\expenv {\bitStringAccess {\exp_1} {\exp_2} {\exp_3}} {\bitStringAccess {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\bitStringTyp {\int_2 - \int_1}} {\dir_1} }
     \quad (\bitStringAccessE)

~ End InfRule

## List Constructor Rule { #sec-list-e }

$\list {\exps}$ constructs a list of expressions.
The rule $\listE$ states that under environment $\env$ and context $\ctxt$,
the list $\list {\exps}$ translates to
$\list {\overline {\prim \exp}}$ in the IR and has the tuple type
$\listTyps \typ$ with direction $\less$ if its expressions translate to
$\overline {\prim \exp}$ with types $\typs$ and directions $\dirs$ under the
same enviroment and context.

~ Begin InfRule

  % \inferrule
  %    {1 \leq i \leq n. \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}}
  %    {\expenv {\list {\exp_1, \ldots, \exp_n}} {\list {\prim {\exp_1}, \ldots, \prim {\exp_n}}} {\listTyp {\typ_1} {\typ_n}} \less }
  %    \quad (\listE)

  \inferrule
     {\expenv {\exps} {\overline {\prim \exp}} {\typs} {\dirs}}
     {\expenv {\list \exps} {\list {\overline {\prim \exp} }} {\listTyps \typ} \less }
     \quad (\listE)

~ End InfRule

## Record Constructor Rule { #sec-record-e }

$\records \exp$ denotes a record where an expression is assigned to each field of the record.
The rule $\recordE$ is similar to $\listE$ rule. 

~ Begin InfRule

  % \inferrule[\recordE]
  %    {1 \leq i \leq n. \expenv {\exp_i} {\prim {\exp_i}} {\typ_i} {\dir_i}  }
  %    {\expenv {\record 1 n} {\recordd 1 n {\prim \exp}} {\recordTypDef} \less  }

  \inferrule
     {\expenv {\exps} {\overline {\prim \exp}} {\typs} {\dirs}}
     {\expenv {\records \exp} {\records {\prim \exp}} {\recordTyps} \less  }
     \quad (\recordE)

~ End InfRule

## Unary Operations Rules { #sec-unary-ops-e }

The rule $\logicalNegE$ states that under the environment $\env$ and context $\ctxt$
the expression $!\exp$ translates to the expression $!\prim\exp$ with the type $\boolTyp$ and direction $\dir$ if expression $\exp$ translates to $\prim\exp$ with type $\boolTyp$ and direction $\dir$ under the same environment and context.

Rules $\bitwiseComplementE$ and $\unaryMinusE$ are similar to the rule $\logicalNegE$.
Additionally, they restrict the type of the $\exp$. 

- $\isInt \typ$ checks if the type $\typ$ is either $\bitWidthTyp \width$, $\intWidthTyp \width$, or $\integerTyp$.

``**Discrepency**``
P4 spec states that all expressions of type int MUST be compile-time known values but
Petr4 doesn't always check this. (ref: section 8.7 spec. e.g., unaryminus or binaryops rules.)

~ Begin InfRule

  \inferrule
     { \expenv \exp {\prim \exp} \boolTyp \dir }
     { \expenv {!\exp} {!\prim \exp} \boolTyp \dir }
     \quad (\logicalNegE)

  \inferrule
     { \expenv \exp {\prim \exp} \typ  \dir \\
       \widthInt \typ = \_}
       % \typ = {\bitWidthTyp \width} \textOr \intWidthTyp \width}
     { \expenv {\bitComplement\!\exp} {\bitComplement\!\prim \exp} {\typ} \dir }
     \quad (\bitwiseComplementE)

  \inferrule
     { \expenv \exp {\prim \exp} \typ  \dir \\
       \isInt \typ}
       % \typ = {\bitWidthTyp \width} \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expenv {-\exp} {-\prim \exp} {\typ} \dir }
     \quad (\unaryMinusE)

~ End InfRule

``**DISCREPENCY**``

- P4 spec defines bitwise complement only for bit<w> but Petr4 also allows it for int<w>. (ref: type_unary_op bitnot impl. section 8.5 spec. bitwisecomplement rule.)

## Binary Operation Rules { #sec-bin-ops-e }

A binary operation is applied to two operands and it is written as $\exp_1 \restOps \exp_2$ where $\restOps$ indicates one or more operators. The binary operation rules are organized line-by-line for readability:

- The name of each rule is located on top of the rule and it contains the operators
that it covers. For example, the rule
$\rn{LogicalOps}\rAE(\ops=\&\&,\vert\vert)$
applies to both **logical and** and **logical or**, that is, while reading the rule,
one can substitute $\ops$ for either $\&\&$ or $\vert\vert$.
- In all the binary operation rules, the first line states that the expression typing judgment is applied recursively to the operands.
- Then if applicable in second line, the rule checks whether the type of one of the operands can be implicitly casted to the other one. If so, it casts the said operand. This is done for all binary operation rules **except** for $\rn{BitstringConcatenation}\rE$ and $\rn{ShiftOps}\rE(\ops=\shiftL,\shiftR)$.
- Then, the type of the operands are reduced to remove all enums recursively and any condition that must hold for the operator(s) of the rule is checked.
- Finally, the direction of the expression is determined. 

The following helpers are used in the binary operation rules:

- $\implicitCast {\typ_1} {\typ_2}$ denotes possible implicit casts between different kinds of integers and returns the type that the other type can be casted to. It is described below (Note that it follows P4's implicit
casting behavior and it is defined in more details in [cast auxiliary judgment][#sec-cast-helper].):
  * $\implicitCast {\bitWidthTyp \width} \integerTyp   = \bitWidthTyp \width$
  * $\implicitCast \integerTyp  {\bitWidthTyp \width}  = \bitWidthTyp \width$
  * $\implicitCast {\intWidthTyp \width} \integerTyp   = \intWidthTyp \width$
  * $\implicitCast \integerTyp {\intWidthTyp \width}   = \intWidthTyp \width$
- $\cast \typ \exp$ synthesizes a cast expression if the type of the expression $\exp$ is different from the type $\typ$.
- $\reduceEnums \typ$ removes all the enums recursively from a type after reducing it.
- $\inOrLess {\dir_1} {\dir_2}$ retunrs the $\inDir$ direction if both directions $\dir_1$ and $\dir_2$ are $\inDir$, otherwise, it returns the $\less$ direction.
- $\typHasEq \typ$ checks if equality of two expressions from the type $\typ$ has been defined. Note that it first reduces the type $\typ$.
- $\concatCond {\typ_1} {\typ_2}$ is a helper function that determines the type of a concatenation expression based on the types of its two operands:
  + if $\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \bitWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \intWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \bitWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \intWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \intWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \intWidthTyp {\width_1 + \width_2}$
- $\bothInt  {\typ_1} {\typ_2}$ is a helper function that checks if both types are a fixed-length or arbitrary precision integer type. That is, it checks the conditions below and returns $\tr$ if one of them holds:
  + $\typ_1 = \typ_2 = \integerTyp$
  + $\typ_1 = \typ_2 = \bitWidthTyp \width$
  + $\typ_1 = \typ_2 = \intWidthTyp \width$
- $\nonNeg \exp$ and $\pos \exp$ evaluate an expression at compile time and check if it is a non-negative or positive number, respectively.
- $\divCond {\typ_1} {\typ_2}$ is a helper function that checks the following conditions for a division/modulo expression and returns $\tr$ if one of them holds:
  + if $\typ_1 = \typ_2 = \integerTyp$, then
    $\divCond {\typ_1} {\typ_2} = \integerTyp$
  + if $\typ_1 = \typ_2 = \bitWidthTyp \width$, then
    $\divCond {\typ_1} {\typ_2} = \bitWidthTyp \width$
- $\shiftCond {\typ} {\exp}$ is a helper function that checks the following conditions of the first expression and it returns $\tr$ if one of them holds:
  + $\typ = \bitWidthTyp \width$
  + $\typ = \intWidthTyp \width$
  + $\typ = \integerTyp$ and $\compTimeKnown \exp$
- $\compTimeKnown \exp$ checks if the value of expression $\exp$ is known during the
compilation. It does so by evaluating the expression $\exp$ at compile time, if that is
possible then we know the value at compile time. Otherwise, if the expression $\exp$ is
a specialized type, extern, package, control, or parser but we cannot evaluate it at
compile time we still consider it known at compile time.

~ Begin InfRule

  \inferrule[\rn{LogicalOps}\rAE($\ops=\&\&,\vert\vert$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}\\\\
       \implicitCast {\typ_1} {\typ_2} = \typ \\
       \cast \typ {\prim {\exp_1}} = \pprim {\exp_1}\\
       \cast \typ {\prim {\exp_2}} = \pprim {\exp_2}\\\\
       \reduceEnums {\typ_1} =
       \reduceEnums {\typ_2} = \boolTyp \\\\
       \inOrLess {\dir_1} {\dir_2} = \dir}
     {\expenv {\exp_1 \restOps \exp_2} {\pprim {\exp_1} \restOps \pprim {\exp_2}} \boolTyp \dir }
     % { \binOpEnv {\exp_1 \restOps \exp_2} \boolTyp \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2} }

  \inferrule[\rn{NumericOps}\rE($\ops=+, -, *$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}\\\\
       \implicitCast {\typ_1} {\typ_2} = \typ \\
       \cast \typ {\prim {\exp_1}} = \pprim {\exp_1}\\
       \cast \typ {\prim {\exp_2}} = \pprim {\exp_2}\\\\
       \reduceEnums {\typ_1} = \reduceEnums {\typ_2} = \typ \\\\
       \isInt \typ\\\\
       \inOrLess {\dir_1} {\dir_2} = \dir 
       }
     {\expenv {\exp_1 \ops \exp_2} {\pprim {\exp_1} \ops \pprim {\exp_2}} \typ \dir }
     % { \binOpEnv {\exp_1 \restOps \exp_2} {\typ} \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2}}

  \inferrule[\rn{EqualityChecks}\rE($\ops=\ ==, !=$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}\\\\
       \implicitCast {\typ_1} {\typ_2} = \typ \\
       \cast \typ {\prim {\exp_1}} = \pprim {\exp_1}\\
       \cast \typ {\prim {\exp_2}} = \pprim {\exp_2}\\\\
       \typEqEnv {\emp} {\reduceEnums {\typ_1}} {\reduceEnums {\typ_2}} \\\\
       % \typEq {\emp} {\typ_1} {\typ_2} \\
       \typHasEq {\typ_1} \\\\
       \inOrLess {\dir_1} {\dir_2} = \dir}
     { \expenv {\exp_1 \ops \exp_2} {\pprim {\exp_1} \ops \pprim {\exp_2}} \boolTyp \dir }
     % { \binOpEnv {\exp_1 \restOps \exp_2} \boolTyp \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2} }

  \inferrule[\rn{OpSat}\rE($\ops = \plusSat,\subSat$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}\\\\
       \implicitCast {\typ_1} {\typ_2} = \typ \\
       \cast \typ {\prim {\exp_1}} = \pprim {\exp_1}\\
       \cast \typ {\prim {\exp_2}} = \pprim {\exp_2}\\\\
       \reduceEnums {\typ_1} = \reduceEnums {\typ_2} = \typ \\\\
       \widthInt {\typ} = \_ \\\\
       % \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width \\
       \inOrLess {\dir_1} {\dir_2} = \dir}
     {\expenv {\exp_1 \ops \exp_2} {\pprim {\exp_1} \ops \pprim {\exp_2}} \typ \dir }
       % { \binOpEnv {\exp_1 \restOps \exp_2} {\typ} \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2}}

  \inferrule[\rn{BitwiseOps}\rE($\ops=\bitAnd, \bitOr, \bitXor, \bitComplement$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}\\\\
       \implicitCast {\typ_1} {\typ_2} = \typ \\
       \cast \typ {\prim {\exp_1}} = \pprim {\exp_1}\\
       \cast \typ {\prim {\exp_2}} = \pprim {\exp_2}\\\\
       \reduceEnums {\typ_1} = \reduceEnums {\typ_2} = \typ\\\\
       \widthInt {\typ} = \_ \\\\
       % \typ = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width \\
       \inOrLess {\dir_1} {\dir_2} = \dir}
     {\expenv {\exp_1 \ops \exp_2} {\pprim {\exp_1} \ops \pprim {\exp_2}} \typ \dir }
       % { \binOpEnv {\exp_1 \restOps \exp_2} {\typ} \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2}}

  \inferrule[\rn{BitstringConcatenation}\rE]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\\\
       \reduceEnums {\typ_1} = \prim {\typ_1} \\
       \reduceEnums {\typ_2} = \prim {\typ_2} \\\\
       \concatCond {\prim {\typ_1}} {\prim {\typ_2}} = \typ\\\\
       \inOrLess {\dir_1} {\dir_2} = \dir}
     {\expenv {\exp_1 \concat \exp_2} {\pprim {\exp_1} \concat \pprim {\exp_2}} \typ \dir }
     % { \binOpEnv {\exp_1 \concat \exp_2} {\typ} \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2}}

  \inferrule[\rn{ComparisonOps}\rE($\ops= <, \leq, >, \geq$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}\\\\
       \implicitCast {\typ_1} {\typ_2} = \typ \\
       \cast \typ {\prim {\exp_1}} = \pprim {\exp_1}\\
       \cast \typ {\prim {\exp_2}} = \pprim {\exp_2}\\\\
       \reduceEnums {\typ_1} = \prim {\typ_1} \\
       \reduceEnums {\typ_2} = \prim {\typ_2} \\\\
       \bothInt {\prim {\typ_1}} {\prim {\typ_2}}\\\\
       \inOrLess {\dir_1} {\dir_2} = \dir
      }
    { \expenv {\exp_1 \ops \exp_2} {\pprim {\exp_1} \ops \pprim {\exp_2}} \boolTyp \dir }
     % { \binOpEnv {\exp_1 \restOps \exp_2} \boolTyp \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2}}

  \inferrule[\rn{DivOps\rE}($\ops=\div, \mod$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2}\\\\
       \implicitCast {\typ_1} {\typ_2} = \typ \\
       \cast \typ {\prim {\exp_1}} = \pprim {\exp_1}\\
       \cast \typ {\prim {\exp_2}} = \pprim {\exp_2}\\\\
       \reduceEnums {\typ_1} = \prim {\typ_1}\\
       \reduceEnums {\typ_2} = \prim {\typ_2}\\\\
       \divCond {\prim {\typ_1}} {\prim {\typ_2}} = \typ \\
       \nonNeg {\exp_1} \\
       \pos {\exp_2}\\\\
       \inOrLess {\dir_1} {\dir_2} = \dir}
     {\expenv {\exp_1 \ops \exp_2} {\pprim {\exp_1} \ops \pprim {\exp_2}} \typ \dir }
     % { \binOpEnv {\exp_1 \restOps \exp_2} \typ \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2}}

  \inferrule[\rn{ShiftOps}\rE($\ops=\shiftL,\shiftR$)]
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\\\
       \reduceEnums {\typ_1} = \prim {\typ_1}\\\\
       % \typ_2 = \reduceEnums {\typ_2} \\
       \nonNeg {\exp_2} \\
       \shiftCond {\prim {\typ_1}} {\exp_2}\\\\
       \inOrLess {\dir_1} {\dir_2} = \dir}
     {\expenv {\exp_1 \ops \exp_2} {\pprim {\exp_1} \ops \pprim {\exp_2}} {\prim {\typ_1}} \dir }
     % { \binOpEnv {\exp_1 \restOps \exp_2} {\prim {\typ_1}} \dir {\typ_1} {\typ_2} {\dir_1} {\dir_2}}

~ End InfRule

``**DISCREPENCY**``

- P4 spec states that all expressions of type int MUST be compile-time known values but
Petr4 doesn't always check this. (ref: section 8.7 spec. e.g., unaryminus or binaryops rules.)
- P4 spec defines bitwise operations and concatenation for bit<w> but Petr4 also allows them for int<w>. (ref: bitwiseops and bitstringconcatenation rules. section 8.5. check_binary_op impl. )
- P4 spec defines division and modulo only for arbitrary-precision integers but petr4 allows them for bit<w> too. (ref: divops rule. section 8.7. check_binary_op impl.)

## Cast Rule { #sec-cast-e }

The expression $\cast \typ \exp$ casts expression $\exp$ to type $\typ$. However, it is
not possible to cast an expression from every type to another type. Thus, the $\castE$
rule states which casts are possible. Specifically, it states that the cast expression
$\cast \typ \exp$ translates to the expression $\cast {\typ_1} {\exp_1}$ in the IR with
the type $\typ_3$ and direction $\less$ if expression $\exp$ is translated to $\exp_1$,
the translation of type $\typ$ to types in the IR is well-formed, and the explicit cast
of the type of expression $\exp_1$ (that is, $\typ_1$) to the
translated type of casting type $\typ$ (that is, $\prim \typ$) is valid.

- $\explicitCastOK {\typ_1} {\typ_2}$ is an auxiliary judgment for valid explicit cast
of types.
The [casting auxiliary judgment][#sec-cast-helper] defines rules for implicitly
and/or explicitly casting one type to another. Sepcifically, the judgment
$\castenv \ {\typ_1} {\typ_2}$ states that under environment $\env$,
the type $\typ_1$ can be casted to type $\typ_2$ either explicitly or implicitly.
However, if the arrow is subscripted with $i$ or $e$ it states that the cast is only
done implicitly or explicitly, respectively.
- $\trans \typ \emp$ ``TODO: complete``

``**TODO**``
The implementation saturates types both in the $\castE$ rule as well as saturating them
in the helper judgment. Fix this later. 

~ Begin InfRule

  \inferrule
     { \expenv \exp {\exp_1} {\typ_1} \dir \\
       % \typ_2 = \sat {\typ_1} \\
       \prim \typ = \trans {\typ} {\emp} \\
       % \pprim \typ = \sat {\prim \typ} \\
       \typWellFormed {\prim \typ} \\
       \explicitCastOK {\typ_1} {\prim \typ}}
       % \explicitCastOK {\typ_2} {\pprim \typ}}
     { \expenv {\cast \typ \exp} {\cast {\prim \typ} {\exp_1}} {\prim \typ} \less  }
     \quad (\castE)

~ End InfRule

### Cast Auxiliary Judgment { #sec-cast-helper }

This auxiliary judgment states if casting of a type to another, either explicitly or implicitly or both, is valid. 
The arrow subscription with $e$ or $i$ indicates if a rule only applies for explicit or implicit cast only, respecctively. Otherwise, the arrow does not have a subscription,
meaning that it applies for both explicit and implicit casts. 
The cast first saturates both types and then checks if the cast is valid. For simplicity, we omited type saturations from the rules.

``**NOTE**``
P4 spec specifies casts up to Sets rule. The rest might be stated throughout the spec but I haven't found them yet.

``**Discrepency**``
P4 spec states during the cast between int and bit<w> or int<w> the compiler would complain about overflow (or conversion of negative value for bit<w>) but Petr4's type system doesn't check this. (ref: I'm not sure if any other part of petr4 takes care of this. section 8.9.1 spec. cast_ok impl. explicit cast judgment.)


~ Begin InfRuleHelper

  \inferrule
     { }
     { \explCast {\bitWidthTyp 1} \boolTyp }
     \quad (\rn{BitToBool}\rAE)

  \inferrule
     { }
     { \explCast \boolTyp {\bitWidthTyp 1} }
     \quad (\rn{BoolToBit}\rAE)

  \inferrule
     { \width = \prim \width }
     { \explCast {\bitWidthTyp {\width}} {\intWidthTyp {\prim \width}}}
     \quad (\rn{UnsignedIntToSigned}\rAE)

  \inferrule
     { \width = \prim \width }
     { \explCast {\intWidthTyp {\width}} {\bitWidthTyp {\prim \width}}}
     \quad (\rn{SignedIntToUnsigned}\rAE)

  \inferrule
     { }
     { \explCast {\bitWidthTyp {\width}} {\bitWidthTyp {\prim \width}}}
     \quad (\rn{UnsignedIntToUnsignedInt}\rSep\rn{Explicit}\rAE)

  \inferrule
     { \width = \prim \width}
     { \implCast {\bitWidthTyp {\width}} {\bitWidthTyp {\prim \width}}}
     \quad (\rn{UnsignedIntToUnsignedInt}\rSep\rn{Implicit}\rAE)

  \inferrule
     { }
     { \explCast {\intWidthTyp {\width}} {\intWidthTyp {\prim \width}}}
     \quad (\rn{SignedIntToSignedInt}\rSep\rn{Explicit}\rAE)

  \inferrule
     { \width = \prim \width}
     { \explCast {\intWidthTyp {\width}} {\intWidthTyp {\prim \width}}}
     \quad (\rn{SignedIntToSignedInt}\rSep\rn{Implicit}\rAE)

  \inferrule
     { }
     { \castenv \  \integerTyp {\bitWidthTyp \width}}
     \quad (\rn{ArbitraryPrecisionIntToUnsignedInt}\rAE)

  \inferrule
     { }
     { \castenv \  \integerTyp {\intWidthTyp \width}}
     \quad (\rn{ArbitraryPrecisionIntToSignedInt}\rAE)

  \inferrule
     { (\typEqEnv \emp {\prim \typ} {\newTypeTyp \name { \typ}})}
     { \castenv \  {\newTypeTyp \name {\typ}} {\newTypeTyp \name {\prim \typ}}}
     \quad (\rn{TypeDefs}\rAE\rSep\rn{1})

  \inferrule
     { (\typEqEnv \emp {\typ} {\newTypeTyp \name {\prim \typ}})}
     { \castenv \  {\newTypeTyp \name {\typ}} {\newTypeTyp \name {\prim \typ}}}
     \quad (\rn{TypeDefs}\rAE\rSep\rn{2})

  \inferrule
     { \explCast {\typ} {\prim \typ}}
     { \explCast {\newTypeTyp \name {\typ}} {\prim \typ}}
     \quad (\rn{TypeDefToType}\rSep\rn{Explicit}\rAE)

  \inferrule
     { \implCast {\typ} {\prim \typ}}
     { \implCast {\newTypeTyp \name {\typ}} {\prim \typ}}
     \quad (\rn{TypeDefToType}\rSep\rn{Implicit}\rAE)

  \inferrule
     { \explCast {\typ} {\prim \typ}}
     { \explCast {\typ} {\newTypeTyp \name {\prim \typ}}}
     \quad (\rn{TypeToTypeDef}\rSep\rn{Explicit}\rAE)

  \inferrule
     { \implCast {\typ} {\prim \typ}}
     { \implCast {\typ} {\newTypeTyp \name {\prim \typ}}}
     \quad (\rn{TypeToTypeDef}\rSep\rn{Implicit}\rAE)

  \inferrule
     { \typEqEnv \emp {\typ} {\prim \typ}}
     { \castenv \ {\enumTypDef} {\enumTyp {\prim \typ} {\prim \name} {\overline {\prim \name}}}}
     \quad (\rn{Enums}\rAE)

  \inferrule
     { \typEqEnv \emp {\typ} {\prim \typ}}
     { \castenv \ {\enumTypDef} {\prim \typ}}
     \quad (\rn{EnumToUnderlyingType}\rAE)

  \inferrule
     { \typEqEnv \emp {\typ} {\prim \typ}}
     { \castenv \ {\typ} {\enumTyp {\prim \typ} {\name} {\names}}}
     \quad (\rn{TypeToEnumWithUndrlyingType}\rAE)

  \inferrule
     { \typEqEnv \emp {\typ} {\prim \typ}}
     { \castenv \ {\setTyp {\typ}} {\setTyp {\prim \typ}} }
     \quad (\rn{Sets}\rAE)

  \inferrule
     { \typEqEnv \emp {\typ} {\prim \typ}}
     { \implCast {\typ} {\setTyp {\prim \typ}}}
     \quad (\rn{TypeToSet}\rSep\rn{Implicit}\rAE)

  \inferrule
     { \typEqEnv \emp {\tupleTyps {\typs}} {\tupleTyps {\overline {\prim \typ}}}}
     { \castenv \  {\listTyps {\typs} } {\tupleTyps {\overline {\prim \typ}}}}
     \quad (\rn{ListToTuple}\rAE)

  \inferrule
     {\explCast {\typs} {\overline {\prim \typ}} }
     {\explCast {\listTyps {\typs}} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{ListToHeader}\rSep\rn{Explicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\tupleTyps \typs} {\tupleTyps {\overline {\prim \typ}}}}
     {\explCast {\listTyps \typs} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{ListToHeader}\rSep\rn{Explicit}\rAE\rSep\rn{2})

  \inferrule
     {\implCast {\typs} {\overline {\prim \typ}}}
     {\implCast {\listTyps \typs} {\headerTyps \field {\prim \typ} }}
     \quad (\rn{ListToHeader}\rSep\rn{Implicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\tupleTyps {\typs}} {\tupleTyps {\overline {\prim \typ}}}}
     {\implCast {\listTyps \typs} {\headerTyps \field {\prim \typ} }}
     \quad (\rn{ListToHeader}\rSep\rn{Implicit}\rAE\rSep\rn{2})

  \inferrule
     {\explCast {\typs} {\overline {\prim \typ}}}
     {\explCast {\listTyps \typs} {\structTyps \field {\prim \typ}}}
     \quad (\rn{ListToStruct}\rSep\rn{Explicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\tupleTyps \typs} {\tupleTyps {\overline {\prim \typ}}}}
     {\explCast {\listTyps \typs} {\structTyps \field {\prim \typ}}}
     \quad (\rn{ListToStruct}\rSep\rn{Explicit}\rAE\rSep\rn{2})

  \inferrule
     {\implCast {\typs} {\overline {\prim \typ}}}
     {\implCast {\listTyps \typs} {\structTyps \field {\prim \typ}}}
     \quad (\rn{ListToStruct}\rSep\rn{Implicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\tupleTyps \typs} {\tupleTyps {\overline {\prim \typ}}}}
     {\implCast {\listTyps \typs} {\structTyps \field {\prim \typ}}}
     \quad (\rn{ListToStruct}\rSep\rn{Implicit}\rAE\rSep\rn{2})

  \inferrule
     {\explCast {\typs} {\overline {\prim \typ}}}
     {\explCast {\recordTyps} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{RecordToHeader}\rSep\rn{Explicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\recordTyps} {\recordTypss \field {\prim \typ}}}
     {\explCast {\recordTyps} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{RecordToHeader}\rSep\rn{Explicit}\rAE\rSep\rn{2})

  \inferrule
     {\implCast {\typs} {\overline {\prim \typ}}}
     {\implCast {\recordTyps} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{RecordToHeader}\rSep\rn{Implicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\recordTyps} {\recordTypss \field {\prim \typ}}}
     {\implCast {\recordTyps} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{RecordToHeader}\rSep\rn{Implicit}\rAE\rSep\rn{2})

  \inferrule
     {\explCast {\typs} {\overline {\prim \typ}}}
     {\explCast {\recordTyps } {\structTyps \field {\prim \typ}}}
     \quad (\rn{RecordToStruct}\rSep\rn{Explicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\recordTyps} {\recordTypss \field {\prim \typ}}}
     {\explCast {\recordTyps } {\structTyps \field {\prim \typ}}}
     \quad (\rn{RecordToStruct}\rSep\rn{Explicit}\rAE\rSep\rn{2})

  \inferrule
     {\implCast {\typs} {\overline {\prim \typ}}}
     {\implCast {\recordTyps } {\structTyps \field {\prim \typ}}}
     \quad (\rn{RecordToStruct}\rSep\rn{Implicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\recordTyps} {\recordTypss \field {\prim \typ}}}
     {\implCast {\recordTyps } {\structTyps \field {\prim \typ}}}
     \quad (\rn{RecordToStruct}\rSep\rn{Implicit}\rAE\rSep\rn{2})

  \inferrule
     {\explCast {\typs} {\overline {\prim \typ}}}
     {\explCast {\headerTyps \field \typ } {\headerTyps \field {\prim \typ}}}
     \quad (\rn{HeaderToHeader}\rSep\rn{Explicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\headerTyps \field \typ} {\headerTyps \field {\prim \typ}}}
     {\explCast {\headerTyps \field \typ } {\headerTyps \field {\prim \typ}}}
     \quad (\rn{HeaderToHeader}\rSep\rn{Explicit}\rAE\rSep\rn{2})

  \inferrule
     {\implCast \typs {\overline {\prim \typ}}}
     {\implCast {\headerTyps \field \typ} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{HeaderToHeader}\rSep\rn{Implicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\headerTyps \field \typ} {\headerTyps \field {\prim \typ}}}
     {\implCast {\headerTyps \field \typ} {\headerTyps \field {\prim \typ}}}
     \quad (\rn{HeaderToHeader}\rSep\rn{Implicit}\rAE\rSep\rn{2})

  \inferrule
     {\explCast {\typs} {\overline {\prim {\typ}}}}
     {\explCast {\structTyps \field \typ} {\structTyps \field {\prim \typ}}}
     \quad (\rn{StructToStruct}\rSep\rn{Explicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\structTyps \field \typ} {\structTyps \field {\prim \typ}}}
     {\explCast {\structTyps \field \typ} {\structTyps \field {\prim \typ}}}
     \quad (\rn{StructToStruct}\rSep\rn{Explicit}\rAE\rSep\rn{2})

  \inferrule
     {\implCast {\typs} {\overline {\prim \typ}}}
     {\implCast {\structTyps \field \typ} {\structTyps \field {\prim \typ}}}
     \quad (\rn{StructToStruct}\rSep\rn{Implicit}\rAE\rSep\rn{1})

  \inferrule
     {\typEqEnv \emp {\structTyps \field \typ} {\structTyps \field {\prim \typ}}}
     {\implCast {\structTyps \field \typ} {\structTyps \field {\prim \typ}}}
     \quad (\rn{StructToStruct}\rSep\rn{Implicit}\rAE\rSep\rn{2})

  \inferrule
    { \typ = \prim \typ}
    {\implCast {\typ} {\prim \typ}}
    \quad (\rn{ID}\rSep\rn{Implicit}\rAE)

~ End InfRuleHelper

## Membership Rules { #sec-mem-e }

A membership expression denoted by a dot, that is, $a.\name$ looks if $\name$ exists in $a$. And it can be a type, error, or expression membership depending on what $a$ is.
An expression member looks up a _member_ in an expression.
The member could be a field in
a record type such as struct and header, or it could be a method in an extern or specialized type, or a special look up of an element of an array such as next, last, size, and last index.  


The rules $\typeMemE$ and $\errMemE$ are rather simple.
They just look up $\name$ extended with the type or error, respectively, in the environment. For example, the $\typeMemE$ states that under the environment $\env$ and context $\ctxt$, the expression $\typMem \typ \name$ is the same in the IR and has the type $\typ$ and direction $\less$ if $\typMem \typ \name$ exists in $\env$.

The rule $\expMemE$ states that under the environment $\env$ and context $\ctxt$, the
expression $\expMem \exp \name$ translates to the expression $\expMem {\prim \exp} \name$ with type $\pprim \typ$ and direction $\less$ where $\prim \exp$ is the translation of the expression $\exp$ and $\pprim \typ$ is the type of the member $\name$ from the reduced type of expression $\exp$ (that is, $\reduce \typ$) which is returned by the expression member auxiliary judgment. 

- The [expression member auxiliary judgment][#sec-exp-mem-helper] is a helper judgment
for the $\expMemE$ rule.
It has the form $\fieldAccessEnv \ctxt \name \typ {\prim \typ}$
which states that under environment $\env$ and context $\ctxt$, the member $\name$
has the type $\prim \typ$ in an expression of type $\typ$.
Simply stated, it looks up the type of the member from the expression passed from the $\expMemE$ rule. 
Note that the expression has to be of a one of the types: record, extern, speciliazed, or arry.

~ Begin InfRule

  \inferrule
     {\lookupEnv {\typMem \typ \name} = (\typ, \dir)  }
     {\expenv {\typMem \typ \name} {\typMem \typ \name} \typ \less  }
     \quad (\typeMemE)

  \inferrule
     {\lookupEnv {\errMem \name} = (\errTyp, \dir)  }
     {\expenv {\errMem \name} {\errMem \name} \errTyp \less  }
     \quad (\errMemE)

  \inferrule
     { \expenv \exp {\prim \exp} {\typ} \dir \\
       \reduce \typ = \prim \typ \\
       % \structTypDef = \prim \typ\\
       \fieldAccessEnv \ctxt \name {\prim \typ} {\pprim \typ}
       }
     { \expenv {\expMem \exp \name} {\expMem {\prim \exp} \name} {\pprim \typ} {\less} }
     \quad (\expMemE)

~ End InfRule

### Expression Member Auxiliary Judgment { #sec-exp-mem-helper }

This judgment ensures that the type of an expression in an expression member is either
a record type, a specialized type, an extern type, or an array. Then, it looks up the member that is being accessed by the expression member. 

~ Begin InfRuleHelper

  \inferrule
     {
       % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \structTypDef = \reduce \typ \\
       % \structTypDef = \prim \typ\\
       % (\field_{n+1},\typ_{n+1}) = (\isValid, \funcTyp \builtin \ \ \boolTyp )\\
       (\field, \typ) \in \overline {\field, \typ} 
       % \exists 1 \leq i \leq n+1. \field_i = \field
       }
     { \fieldAccessEnv \ctxt \field {\structTyps \field \typ} {\typ} }
     \quad (\rn{Type:Struct}\rAE)

  \inferrule
     {
       % \expenv \exp {\prim \exp} {\typ} \dir \\
       % \structTypDef = \reduce \typ \\
       % \structTypDef = \prim \typ\\
       % (\field_{n+1},\typ_{n+1}) = (\isValid, \funcTyp \builtin \ \ \boolTyp )\\
       % \exists 1 \leq i \leq n+1. \field_i = \field
       }
     { \fieldAccessEnv \ctxt \field {\structTyps \field \typ} {\funcTyp \builtin \ \ \boolTyp} }
     \quad (\rn{Type:Struct}\rSep\rn{Mem:isValid}\rAE)

  \inferrule
     {
       % names in the following are actually methods. have to see what they contain.
       \lookupEnv {\prim \name} = (\typParams,\overline {\name:\simpFuncTyp {\typ_{\mathit{in}}} {\typ_{\mathit{out}}}}) \\
       % \prim \env = \insertToEnv  \typParams \typs \\
       \suchThat {\exists \name_i: \prim {\typ_i} \in \overline {\name:\simpFuncTyp {\typ_{\mathit{in}}} {\typ_{\mathit{out}}}}} {\name_i = \name} \\
        \reduceWithEnv {\insertToEnvv  {\overline {\typParam : \typ}}} {\prim {\typ_i}} = \pprim {\typ_i}}
     { \fieldAccessEnv \ctxt \name {\spcTyp {\externTyp {\prim \name}} {\typs}} {\pprim {\typ_i}}}
     \quad (\rn{Type:Specialized}\rAE)

  \inferrule
     { \fieldAccessEnv \ctxt \name {\spcTyp {\externTyp {\prim \name}} \ } {\pprim \typ} }
     { \fieldAccessEnv \ctxt  \name {\externTyp {\prim \name}}  {\pprim \typ}}
     \quad (\rn{Type:Extern}\rAE)

  \inferrule
     { }
     { \fieldAccessEnv \ctxt \sizeMem {\arrayTyp \typ \size} {\bitWidthTyp {32}}}
     \quad (\rn{Type:Array}\rSep\rn{Mem:Size}\rAE)

  \inferrule
     { }
     { \fieldAccessEnv \ctxt \lastIndex {\arrayTyp \typ \size} {\bitWidthTyp {32}}}
     \quad (\rn{Type:Array}\rSep\rn{Mem:LastIndex}\rAE)

  \inferrule
     { }
     { \fieldAccessEnv \parserCtxt \next {\arrayTyp \typ \size} {\typ}}
     \quad (\rn{Type:Array}\rSep\rn{Mem:Next}\rAE)

  \inferrule
     { }
     { \fieldAccessEnv \parserCtxt \last {\arrayTyp \typ \size} {\typ}}
     \quad (\rn{Type:Array}\rSep\rn{Mem:Last}\rAE)

~ End InfRuleHelper

## Ternary Rule { #sec-ternary-e }

The expression $\ternary {\exp_1} {\exp_2} {\exp_3}$ is a conditional expression.
The rule $\ternaryE$ states that $\exp_1$ must be a boolean and expressions $\exp_2$
and $\exp_3$ must have the same type but they cannot have the $\integerTyp$ type. In
that case it translates the conditional expression by translating all its subexpressions. 

~ Begin InfRule

  \inferrule
     {\expenv {\exp_1} {\prim {\exp_1}} \boolTyp {\dir_1} \\\\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_1} {\dir_2} \\\\
      \expenv {\exp_3} {\prim {\exp_3}} {\typ_2} {\dir_3}\\\\
      \typ_1 = \typ_2 \\
      \typ_1 \neq \integerTyp}
     {\expenv {\ternary {\exp_1} {\exp_2} {\exp_3}} {\ternary {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\typ_1} \less }
     \quad (\ternaryE)

  % \inferrule[ Ternary(AllowedInP4ButNotePetr4)]
     % {\expenv {\exp_1} {\prim {\exp_1}} \boolTyp {\dir_1} \\
     %  \expenv {\exp_2} {\prim {\exp_2}} {\integerTyp} {\dir_2} \\
     %  \expenv {\exp_3} {\prim {\exp_3}} {\integerTyp} {\dir_3}\\
     %  % \typ_1 = \typ_2 \\
     %  % \typ_1 \eq \integerTyp \\
     %  \compTimeKnown {\exp_1}}
     % {\expenv {\ternary {\exp_1} {\exp_2} {\exp_3}} {\ternary {\prim {\exp_1}} {\prim {\exp_2}} {\prim {\exp_3}}} {\typ_1} \less }

~ End InfRule

``**Restriction**``
Petr4 doesn't support the case where both the
true and the false expressions have the infinite precision integer type when the
condition can be evaluated at compilation time. However, this is allowed by P4 spec.


## Function Call Rule

Expressions $\funcCall \exp {\typs} \args$ and
$\funcCallNoTypArgs \exp \args$ both indicate a function call where

- $\exp$ is either a name or an expression member that is bein called
- $\args$ is the arguments passed to the function and they could be matched with parameters either based on name or position
- $\typs$ is the type arguments passed to the function.

A function call is well-typed if the called expression is an accepted function call and is well-typed and the passed (type) arguments do not violate any restrictions of (type) parameters. ``Ryan: better way of summarizing function call rule?``

- The [function call auxiliary judgment][#sec-func-call] carries out multiple roles:
  1. it checks if the expression as a function call is acceptable, that is, if it is either a name or expression member
  2. it checks if the type of the expression is either a function, an action, an extern, or a specialized type
  3. it checks if the parameters and arguments match either based on their position or name.

  And has the judgment form $\resolveFuncOver \exp \args {\prim \exp} \typVars \prms \kind {\typ_\ret}$ which states that the expression $\exp$ called as a function with arguments $\args$ under environment $\env$ and context $\ctxt$, translates to the expression $\prim \exp$ in the IR and has the type parameters $\typVars$, parameteres $\prms$, kind $\kind$, and the return type $\typ_\ret$.
- $\transMaybe \typ$ translates the surface type $\typ$ to underlying types and if the surface type is $\dontcareTyp$ it assigns $\bot$ to it. ``TODO: rewrite after adding syntax.``
- $\matchParArg \prms \args$ matches parameters $\params$ to arguments $\args$. A parameter is used when defining a function/structure. It has a type and a variable name. Additionally, it can have a direction and an optional value. On the other hand, an argument is what is actually passed to the function/structure when it is called and it can either be an expression, a key-value, or don't care. So the role of this helper function is to match the parameters to the passed arguments. If all arguments are key-values it simply matches the arguments and parameters based on their names. If the arguments are expressions or don't care, it matches them based on their positions. Thus, it returns a list of pairs of parameter names and optional expressions.
- $\validatePars \singleprm \env \kind$ validates the parameter $\singleprm$ under the environment $\env$ and the function kind $\kind$. That is, it confirms that the parameter is valid if **none** of the following cases hold:
  + $(\sat \typ) = \externTyp \whatevs$ and $\dir \neq \less$
  + $\compTimeKnown {\sat \typ}$ and $\dir \neq \less$
  + $\typNotWellFormed (\sat \typ)$

  And **one** of the following holds:
  + $\kind = \parserKind$ and  $\sat \typ=\externTyp \whatevs$
  + $\kind = \controlKind$ and  $\sat \typ=\externTyp \whatevs$
  + $\kind = \methodKind$ and  $\sat \typ=\externTyp \whatevs$
- The [infer type arguments auxiliary judgment][#sec-infer-type-args] infers the type of type parameters of a function call using the
arguments passed to it and to ensure that they all match.
It has the judgment form $\inferTypParArg {{\maybe \constraint}} {\overline {\singleprm := {\maybe \exp}}} {\prim \constraint}$ which states that under environment $\env$ and context $\ctxt$,
the assignment of arguments $\overline {\maybe \exp}$ to parameters $prms$ is valid under the constraints $\prim \constraint$ as long as the constraints $\prim \constraint$ do not contradict the constraints $\maybe \constraint$.
Constraints $\constraint$ are assignments of types to type variables and optional constraints $\maybe \constraint$ are assignments of optional types to type variable. Note that constraints denoted by a letter have the same fixed vector of type variables. 
- $\castParArg {\overline {\param := \maybe \exp}}$ bundles up the parameter with the expression's IR representation if possible: if $\maybe \exp \neq \bot$, it bundles up the parameter with $\castExpression \typ \exp$ if the direction of the parameter is correct (refer to _check\_direction_ function). Otherwise, if the parameter type isn't void and the direction is out or parameter is optional, it bundles up the parameter with bottom.
- $\callOK \ctxt \kind$ checks if the function kind is valid in a context. The following cases valid: ``TODO: break up ctxt. here ctxt is exprctxt.``
  + $\ctxt = \parserCtxt$ and $\kind = \parserKind$
  + $\ctxt = \applyBlockCtxt$ and $\kind = \controlKind$
  + $\ctxt \neq \funcCtxt \whatevs$ and $\kind = \externKind$
  + $\ctxt = \applyBlockCtxt$ and $\kind = \tableKind$
  + $\ctxt = \applyBlockCtxt$ and $\kind = \actionKind$
  + $\ctxt = \actionCtxt$ and $\kind = \actionKind$
  + $\ctxt = \tableActionCtxt$ and $\kind = \actionKind$
  + $\ctxt = \parserCtxt$ and $\kind = \funcKind$
  + $\ctxt = \applyBlockCtxt$ and $\kind = \funcKind$
  + $\ctxt = \actionCtxt$ and $\kind = \funcKind$
  + $\ctxt = \funcCtxt \whatevs$ and $\kind = \funcKind$
  + $\ctxt = \declLocalCtxt$ and $\kind = \funcKind$
  + $\kind = \builtin$


~ Begin InfRule

%   \mprset {vskip=0.7ex}
%   {\inferrule 
%      {
%        \resolveFuncOver \exp \args {\prim \exp} \typVars \prms \kind {\typ_\ret} \\\\
%        \trans {\overline {\typ_0}} \emp = \overline {\typ_1}\\
%        |\overline {\typ_0}| = |\typVars|\\\\
%        % \overline {\typVar : \typ} = \zip \typVars {\overline {\prim \typ}}\\
%        \matchParArg \prms \args = \overline {\singleprm = \pprim {\maybe \exp}}\\
%        % \inferTypParArg {\typ_\ret} {\overline {\typVar : \typ_1}} {\overline {\param = \pprim {\maybe \exp}}} {\overline {\typVar :\typ_1}} {\overline {\typVar : \typ_2}}\\\\
%        \inferTypParArg {\overline {\typVar : \maybe {\typ_1}}} {\overline {\singleprm = \pprim {\maybe \exp}}} {\overline {\typVar : \typ_2}}\\\\
%        \validatePars {\typs} {\addTypEnvv {\overline {\typVar : \typ_2}} } \kind \\
%        \castParArg {\overline {\param = \pprim {\maybe \exp}}} = \overline {\param = \maybe {(\ppprim \exp, \prim \typ, \dir)}}\\\\
%        \callOK \ctxt \kind \\
%        \sat {\typ_\ret} = {\prim \typ}_{\ret} 
%        }
%      { \expenv {\funcCall \exp {\overline {\typ_0}} \args} {\funcCall {\prim \exp} {\overline { \typ_2}} {\overline{\maybe {(\ppprim \exp, \prim \typ, \dir)}}} } {{\prim \typ}_{\ret}} \less }
%      \quad (\funcCallE)}

% \\

  \mprset {vskip=0.7ex}
  {\inferrule 
     {
       \resolveFuncOver \exp \args {\prim \exp} \typVars \prms \kind {\typ_\ret} \\\\
       \transMaybe {\overline {\typ_0}} = \overline {\maybe {\typ_1}}\\
       |\overline {\typ_0}| = |\typVars|\\\\
       % \overline {\typVar : \typ} = \zip \typVars {\overline {\prim \typ}}\\
       \matchParArg \prms \args = \overline {\singleprm := \pprim {\maybe \exp}}\\
        % {\overline {\typVar : \maybe {\typ_1}}} = \constraint\\
       \inferTypParArg {\overline {\typVar : \maybe {\typ_1}}} {\overline {\singleprm := \pprim {\maybe \exp}}} { \constraint}\\\\
       \validatePars {\typs} {\unionEnv \env { \constraint} }  \kind \\
       \castParArg {\overline {\param := \pprim {\maybe \exp}}} = \overline {\param := \maybe {(\ppprim \exp, \prim \typ, \dir)}}\\\\
       \callOK \ctxt \kind \\
       \sat {\typ_\ret} = {\prim \typ}_{\ret} 
       }
     { \expenv {\funcCall \exp {\overline {\typ_0}} \args} {\funcCall {\prim \exp} {\overline { \typ_2}} {\overline{\maybe {(\ppprim \exp, \prim \typ, \dir)}}} } {{\prim \typ}_{\ret}} \less }
     \quad (\funcCallE)}

\\

  \mprset {vskip=0.7ex}
  {\inferrule 
     {
       \resolveFuncOver \exp \args {\prim \exp} \typVars \prms \kind {\typ_\ret} \\\\
       \matchParArg \params \args = \overline {\singleprm := \pprim {\maybe \exp}}\\
       \inferTypParArg {\overline {\typVar : \bot }} {\overline {\singleprm := \pprim {\maybe \exp}}} \constraint \\\\
       % \inferTypParArg {\overline {\typVar : \bot }} {\overline {\singleprm = \pprim {\maybe \exp}}} {\overline {\typVar : \prim \typ}}\\\\
       \validatePars {\params} {\unionEnv \env {\constraint} } \kind \\
       \castParArg {\overline {\param := \pprim {\maybe \exp}}} = \overline {\param := \maybe {(\ppprim \exp, \pprim \typ, \dir)}}\\\\
       \callOK \ctxt \kind \\
       \sat {\typ_\ret} = {\prim \typ}_{\ret} 
       }
     { \expenv {\funcCallNoTypArgs \exp \args} {\funcCall {\prim \exp} {\overline {\prim \typ}} {\overline{\maybe {(\ppprim \exp, \pprim \typ, \dir)}}} } {{\prim \typ}_{\ret}} \less }
     \quad (\funcCallNoTypeArgE)}

~ End InfRule

### Function Call Auxiliary Judgment { #sec-func-call }

This judgment checks the details of a function call:

1) it checks if the expression as a function call is acceptable, that is, if it is either a name or expression member
2) it checks if the type of the expression is either a function, an action, an extern, or a specialized type
3) the parameters and arguments either match based on their position or name.

It has the form $\resolveFuncOver \exp \args {\prim \exp} \typVars \prms \kind {\typ_\ret} $ which states that the expression $\exp$ called as a function with arguments $\args$ under environment $\env$ and context $\ctxt$, translates to the expression $\prim \exp$ in the IR and has the type parameters $\typVars$, parameteres $\prms$, kind $\kind$, and the return type $\typ_\ret$.

- Remember that parameters could be optional or have some default expression set as their expression. $\removeOptionalPars \params$ removes those parameters.
- $\concatList {\overline \anyTyp} {\overline {\prim \anyTyp}}$ denotes concatenating two lists.

~ Begin InfRuleHelper

  \mprset {vskip=0.5ex}
  {\inferrule
     % [\nameFuncNameE]
     { \lookupEnv {\name_0} = \overline {(\typ, \dir)}\\
       \exists (\funcType \kind \typParams {\overline {\prm 1}} {\typ_\ret},\dir_2)\in \overline {(\typ, \dir)}}
       % \exists (\typ,\dir) \in (\overline {\typ, \dir}). \typ = \funcType \kind \typParams {\pars 1 n} {\typ_\ret} }
     { \resolveFuncOver {\name_0} {\overline {\var_1 = \exp}} {\name_0} \typParams {\overline {\prm 1}} \kind {\typ_\ret} }
     \quad (\nameFuncNameE)
  }

\\
  \mprset {vskip=0.5ex}
  {\inferrule
     % [\nameFuncCountE]
     { \lookupEnv {\name_0} = \overline {(\typ, \dir)}\\
       \exists (\funcType \kind \typParams {\overline {\prm 1}} {\typ_\ret},\dir_2) \in \overline {(\typ, \dir)}\\
       % \exists (\typ,\dir) \in (\overline {\typ, \dir}). \typ = \funcType \kind \typParams \params {\typ_\ret}\\
       |\removeOptionalPars \params| = |\argexps|}
    { \resolveFuncOver {\name_0} {\argexps} {\name_0} \typParams {\overline {\prm 1}} \kind {\typ_\ret} }
    \quad (\nameFuncCountE)
  }

\\
  \mprset {vskip=0.5ex}
  {\inferrule
     { \expenv {\name_0} \exp {\actionTyp {\overline {\prm 1} } {\overline {\prm 2}}} \dir \\
       \overline {\prm 3} = \concatList {\overline {\prm 1}} {\overline {\prm 2}}}
     {\resolveFuncOver {\name_0} {\args} {\name_0} \emp {\overline {\prm 3}} \actionKind \voidTyp }
     \quad (\nameActionE)
   }


\\
  \mprset {vskip=0.5ex}
  {\inferrule
     % [\expMemExternNameE]
     { \expenv {\expMem {\name_0} {\exp_0}} {\exp_1} {\typ_1} {\dir_1}\\
       \reduce {\typ_1} = \externTyp {\name_1}\\\\
       \lookupEnv { \name_1} = (\typParams, \methods {\name_2} {\typ_2})\\\\
       \exists (\name_0, \funcType \kind {\overline {\prim \typParam}} {\prms} {\typ_\ret}) \in {(\methods {\name_2} {\typ_2})}
       }
    {\resolveFuncOver {\expMem {\name_0} {\exp_0}} \argkvs {\exp_1} {\overline {\prim \typParam}} \prms \kind {\typ_\ret}}
    \quad (\expMemExternNameE)
  }

\\
  \mprset {vskip=0.5ex}
  {\inferrule
     % [\expMemExternCountE]
     { \expenv {\expMem {\name_0} {\exp_0}} {\exp_1} {\typ_1} {\dir_1}\\
       \reduce {\typ_1} = \externTyp {\name_1}\\\\
       \lookupEnv { \name_1} = (\typParams, \methods {\name_2} {\typ_2})\\\\
       \exists (\name_0, \funcType \kind {\overline {\prim \typParam}} {\prms} {\typ_\ret}) \in {(\methods {\name_2} {\typ_2})}\\\\
       |\prms| = |\argexps|
       }
    {\resolveFuncOver {\expMem {\name_0} {\exp_0}} \argexps {\exp_1} {\overline {\prim \typParam}} \prms \kind {\typ_\ret} }
     \quad (\expMemExternCountE)
   }

\\
  \mprset {vskip=0.5ex}
  {\inferrule
     % [\expMemSpcE]
     { \expenv {\expMem {\name_0} {\exp_0}} {\exp_1} {\typ_1} {\dir_1}\\
       \reduce {\typ_1} = \spcTyp {\name_1} {\overline {\prim \arg}} \\\\
       \isExtern {\name_1} \\\\
       \resolveFuncOver {\expMem {\name_0} {\name_1}} \args {\overline {\prim \typParam}} \prms \kind {\typ_\ret} {\dir_2} \\\\
       \reduceWithEnv {\addTypEnvv {\overline {\prim \typParam} {\prim \arg}}} {\typ_\ret} = \prim {\typ_\ret}
     }
    {\resolveFuncOver {\expMem {\name_0} {\exp_0}} \args {\exp_1} {\overline {\prim \typParam}} \prms \kind {\prim {\typ_\ret}} }
     \quad (\expMemSpcE)
   }

~ End InfRuleHelper

### Infer Type Arguments Auxiliary Judgment { #sec-infer-type-args }

This auxiliary judgment is used to infer the type of type parameters of a function call using the
arguments passed to it and to ensure that there are no conflicts in the inferred types.
It has the judgment form $\inferTypParArg {\maybe \constraint} {\overline {\singleprm = {\maybe \exp}}} {\prim \constraint}$ which reads as under environment $\env$ and context $\ctxt$, the types of type parameters in the constraints $\maybe \constraint$ are inferred and returned in constraints $\prim \constraint$ given the assignment of parameters $\prms$ to optional expressions $\overline {\maybe \exp}$.
As a reminder, constraints $\constraint$ are assignment of type parameters to types and optional constraints $\maybe \constraint$ are assignment of type parameters to optional types. The vector of type parameters in each constraint denoted by a letter is fixed. Hence, we additionally use $\optConstraint$ and $\nonoptConstraint$ to denote constraints when we have different vectors of type parameters. This means, for example, $\maybe \constraint$ and $\prim \constraint$ have the same vector of type parameters but the assignment of types to type parameters has changed.

The rule $\inferTypeArgAE$ states that
under environment $\env$ and context $\ctxt$, the types of type parameters in the constraints $\maybe \constraint$ are inferred and returned in constraints $\prim \constraint$ given the assignment of parameters $\prms$ to optional expressions $\overline {\maybe \exp}$
if the result of the unification of the type of arguments and their parameter types (which is the assignment of type parameters to types) does not include any incosistency. For example, one does not state that type parameter $\typVar$ is $\integerTyp$ while the other states that it is $\tupleTyps \integerTyp$.


- $\breakMaybes {\overline {\maybe \anyTyp}} {\overline {\prim \anyTyp}} {\overline {\pprim {\maybe \anyTyp}}}$ breaks down a list of optional things (reminder: $\anyTyp$ is a metavariable of any type you want) into two lists: one that only contains values other than $\bot$ (that is, $\overline {\prim \anyTyp}$) and another that only contains the ones that are $\bot$ (that is, $\overline {\pprim {\maybe \anyTyp}}$). So in the rule $\inferTypeArgAE$, the $\maybe \optConstraint$ is the list of type parameters that do not have a type assigned to them.
- As a reminder $\unify \env \typeEqs {{\typVars}} \typ { {\prim \typ}} {\maybe \constraint}$ unifies the types $\typ$ and $\prim \typ$ under environment $\env$, equivalent type variables $\typeEqs$ (which expanded is ${\overline {\typVar_1 = \typVar_2}}$), and type variables $\typVars$ that do not have any type assigned to them yet and returns the constraints $\maybe \constraint$ that is required for the two types to be unified.
For detailed rules of this judgment refer to Section [#sec-type-unify].
- $\mergeConst {\overline {\maybe \constraint}}$ merges the types assigned to type variables in the list of constraints $\overline {\maybe \constraint}$ recursively. It starts from no assignment to any of the type variables as the base and recursively folds the merge of assigned types to a type variable from the list of assignments $\overline {\maybe \constraint}$. The merging of types, that is, $\mathit{merge}(\typVar_1 : \typ_1, \typVar_1 :\typ_2)$, tries the following and if none of them matches it fails:
  + if $\typEqEnv \emp {\typ_1} {\typ_2}$, then $\typ_1$
  + if $\implCast {\typ_1} {\typ_2}$, then $\typ_2$
  + if $\implCast {\typ_2} {\typ_1}$, then $\typ_1$
- $\toVoid {\overline {\maybe \constraint}}$ assigns the $\voidTyp$ type to the type variables in constraints $\maybe \constraint$ that do not have a type assigned to them, i.e., $\bot$ is assigned to them. It leaves the type variables that have type assignments untouched.


~ Begin InfRuleHelper

  % \mprset {vskip=0.5ex}
%   {\inferrule
%      { \breakMaybes {\overline {\typVar_1 : \maybe {\typ_1}}} {\overline {\typVar_2 : \typ_2}} {\overline {\typVar_3 : \bot}}\\\\
%        \expenvvv {\addTypEnvv {\overline {\typVar_2 : \typ_2}}} {\exps} {\overline {\prim \exp, \prim \typ, \prim \dir}} \\\\
%        \unify {\addTypEnvv {\overline {\typVar_2 : \typ_2}}} \emp {\overline {\typVar_3}} \typs {\overline {\prim \typ}} {\overline {\overline {\typVar_3 : \maybe {\typ_4}}}} \\\\
%        \mergeConst {\overline {\typVar_3 : \bot}} {\overline {\overline {\typVar_3 : \maybe {\typ_4}}}} = {\overline {\typVar_3 : \maybe {\typ_5}}}\\\\
%        \concatList {\overline {\typVar_2 : {\typ_2}}} { \toVoid {\overline {\typVar_3 : \maybe {\typ_5}}}} = {\overline {\typVar_1 : {\typ_6}}} }
%      {\inferTypParArg {\overline {\typVar_1 : \maybe {\typ_1}}} {\overline {\singleprm = {\maybe \exp}}}  {\overline {\typVar_1 : {\typ_6}}}}
%      \quad (\inferTypeArgAE)
%   }

% \\

  \mprset {vskip=0.5ex}
  {\inferrule
     { \breakMaybes {\maybe \constraint} {\nonoptConstraint} {\maybe \optConstraint}\\\\
       \prim \env = \unionEnv \env {\nonoptConstraint}\\
       \expenvvv {\prim \env} {\exps} {\overline {\prim \exp, \prim \typ, \prim \dir}} \\\\
       \unify {\prim \env} \emp {\maybe \optConstraint} \typs {\overline {\prim \typ}} {\overline {\maybe {\prim \optConstraint}}} \\\\
       \mergeConst {\overline {\maybe {\prim \optConstraint}}} = \maybe {\pprim \optConstraint}\\\\
       \unionEnv {\nonoptConstraint} {\toVoid{\maybe {\pprim \optConstraint}}} = \prim \constraint }
       % \concatList {\overline {\typVar_2 : {\typ_2}}} { \toVoid {\overline {\typVar_3 : \maybe {\typ_5}}}} = {\overline {\typVar_1 : {\typ_6}}} }
     {\inferTypParArg {\maybe \constraint} {\overline {\singleprm := {\maybe \exp}}}  {\prim \constraint}}
     \quad (\inferTypeArgAE)
  }


~ End InfRuleHelper

## Anonymous Instantiation Rule { #sec-inst-e }

``TODO: complete this thu aug 11``

- validate par arg checks if optional is some and it passes if expression is compile time known or if it is none and parameter is none.

~ Begin InfRule

  \inferrule
     % { (\prim {\arg_1}, \ldots, \prim {\arg_n}, \prim \typ) = typeConstInvoc  }
     { \transMaybe \typs = \overline {\prim {\maybe \typ}} \\
       \resolveConstOver \name \args \typParams \wildcardParams \prms \retTyp \\
       \matchParArg \prms \args = \overline {\singleprm := \pprim {\maybe \exp}}\\
       |\typs| = |\typParams| \\
       \inferTypParArg {\concatList {\overline {\typVar : \maybe {\typ_1}}} {\overline {\wildcardParam : \bot}}} {\overline {\singleprm := \pprim {\maybe \exp}}} { \constraint}\\\\
       \prim \env = \unionEnv \env \constraint \\
       \castParArg {\overline {\param := \pprim {\maybe \exp}}} = \overline {\param := \maybe {(\ppprim \exp, \prim \typ, \dir)}}\\\\
       \validateParArg {\overline {\param := \maybe {(\ppprim \exp, \prim \typ, \dir)}}}\\
       \sat \retTyp = \prim \retTyp}
     { \expenv {\instantiation {\spcTyp \name {\typs}} {\args}} {\instantiation {\spcTyp \name {\typs}} {\overline {\prim \arg}}} {\pprim \typ} \less}
  \quad (\instE\rSep\rn{1})

% typename of type_nameless_instantiation
  \inferrule
     { \expenv {\instantiation {\spcTyp \name {\ }} {\args}} {\prim \exp} \typ \dir}
     %name in the following is typename
     { \expenv {\instantiation {\name} {\args}} {\prim \exp} \typ \dir }
     \quad (\instE\rSep\rn{2})

~ End InfRule

~ Begin InfRuleHelper

  \mprset {vskip=0.5ex}
  {  \inferrule
         { \lookupEnv \name = \overline {(\typ, \dir)} \\
           \exists (\constructorTyp \typParams \wildcardParams \prms \retTyp, \dir) \in \overline {(\typ, \dir)}}
         { \resolveConstOver \name {\overline {\var = \exp}} \typParams \wildcardParams \prms \retTyp  }
         \quad (blah)
  }

  \mprset {vskip=0.5ex}
  {  \inferrule
         { \lookupEnv \name = \overline {(\typ, \dir)} \\
           \exists (\constructorTyp \typParams \wildcardParams \prms \retTyp, \dir) \in \overline {(\typ, \dir)} \\
           |\removeOptionalPars \params| = |\argexps|}
         { \resolveConstOver \name \argexps \typParams \wildcardParams \prms \retTyp  }
         \quad (blah)
  }

~ End InfRuleHelper

## Mask Rule { #sec-mask-e }

The expression $\mask {\exp_1} {\exp_2}$ denotes a masking expression where every 0 bit in $\exp_2$ is turned into don't care and the rest of the bits of expressions $\exp_1$ and $\exp_2$ are conjuncted. Thus, it returns a set of expressions:
$\mask {\exp_1} {\exp_2} = \{\exp_3 | \exp_1\ \&\ \exp_2 = \exp_3\ \&\ \exp_2 \}$. Thus, as
stated by the rule $\maskE$ both expressions $\exp_1$ and $\exp_2$ must have the same type of $\bitWidthTyp \width$, $\intWidthTyp \width$, or $\integerTyp$. 

- $\maskTypeIs {\typ_1} {\typ_2}$ is a helper function that determines the type of a
mask expression based on the type of its two operands and it is defined for the following cases:
  + if $\typ_1 = \typ_2 = \bitWidthTyp \width$,
  then $\maskTypeIs {\typ_1} {\typ_2} = \bitWidthTyp \width$
  + if $\typ_1 = \bitWidthTyp \width, \typ_2 = \integerTyp$,
  then $\maskTypeIs {\typ_1} {\typ_2} = \integerTyp$
  + if $\typ_1 = \integerTyp, \typ_2 =  \bitWidthTyp \width$,
  then $\maskTypeIs {\typ_1} {\typ_2} = \bitWidthTyp \width$

``**ENSURE**``
It might seem that petr4 allows mask operation to also operate on arbitrary precision integers while P4 spec doesn't. However, note that int can be implicitly casted to bit<w>. So the mask operation can also operate on int or combination of int and bit<w>. Similarly this applies to the range operation. 

~ Begin InfRule

  \inferrule
     {\expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\\\
      \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
      \maskTypeIs {\typ_1} {\typ_2} = \typ}
     {\expenv {\mask {\exp_1} {\exp_2}} {\mask {\prim \exp_1} {\prim \exp_2}} {\setTyp \typ} \less  }
     \quad (\maskE)

~ End InfRule

## Range Rule { #sec-range-e }

The expression $\range {\exp_1} {\exp_2}$ is a range expression and it returns the values between $\exp_1$ and $\exp_2$, inclusively. The rule $\rangeE$ states that the type of expression $\exp_1$ and $\exp_2$ must be the same and it must either be $\bitWidthTyp \width$ or $\intWidthTyp \width$ (and by extension of implicit cast of types it can also be $\integerTyp$). 

- As a reminder, the $\bothInt {\typ_1} {\typ_2}$ function checks the conditions
  $\typ_1 = \typ_2 = \bitWidthTyp \width$ or $\typ_1 = \typ_2 = \intWidthTyp \width$ or
  $\typ_1 = \typ_2 = \integerTyp$ and if one of them holds it returns $\tr$.

``**ENSURE**``
p4 spec only states that the type can be bit<w> or int<W> but petr4 also allows integer. It's because of implicit cast, right?

~ Begin InfRule

  \inferrule
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\\\
       \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
       \bothInt {\typ_1} {\typ_2}}
       % \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expenv {\range {\exp_1} {\exp_2}} {\range {\prim {\exp_1}} {\prim {\exp_2}}} {\setTyp {\typ_1}} \dir }
     \quad (\rangeE)

~ End InfRule

# Statement's Typing Rules { #sec-stmt-typing }
this judgment type checks a statment written in surface syntax, generates the IR statement from it and if applicable updates the env and ctxt.
is_lvalue checks if an IR expression is lvalue. 
cast_expr takes a type and surface syntax expression. after generating the IR expression by type_expression, it checks if the given type and type of IR expression are equal it just returns the IR exp o.w. it casts (if possible) the IR expression to the given type.
if void type  returns a void type if a (or two) type is (are) void and otherwise returns a unit type.
get enum typ takes a type and checks if it's an enum. if so it returns the enums of it. 

~ Begin InfRule

  \inferrule
     { \expenv {\exp_1} {\prim {\exp_1}} {\typ_1} {\dir_1} \\
       \isLval {{\prim {\exp_1}}, {\typ_1}, {\dir_1}} \\ 
       ({\prim {\exp_2}}, {\typ_2}, {\dir_2}) = \castExpression {\typ_1} {\exp_2}\\
       % \expenv {\exp_2} {\prim {\exp_2}} {\typ_2} {\dir_2} \\
       % \typ_1 = \typ_2 \\
       }
     { \stmtenv {\assign {\exp_1} {\exp_2}} {\assign {\prim {\exp_1}} {\prim {\exp_2}}} {\unitTyp} }
     \quad (\assignmentS)


  \inferrule
     { }
     { \stmtenv {\noop} {\noop} {\unitTyp}}
     \quad (\emptyS)

  \inferrule
     { \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 \\
       \prim \typ = \ifVoidTyp {\typ_1} \\
       \stmtenvv 2 {\stmts} {\prim \stmts} {\prim \typ} 3 }
     { \stmtenvv 1 {\block {\stmt_1; \stmts} } {\block {\prim {\stmt_1}; {\prim \stmts}} } {\prim \typ} 3 }
     \quad (\blockS)

  \inferrule
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \applyBlockCtxt \textOr \actionCtxt \\
       ({\prim {\exp}}, {\typ}, {\dir}) = \castExpression {\voidTyp} {\exp}\\
       }
     { \stmtenv {\return \exp} {\return {({\prim {\exp}}, {\typ}, {\dir})}} \voidTyp  }
     \quad (\returnS)

  \inferrule
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \applyBlockCtxt \textOr \actionCtxt \textOr \funcCtxt \typ \\
       }
     { \stmtenv {\return {}} {\return {}} \voidTyp  }
     \quad (\returnEmpS)

  \inferrule
     {
     % \expenv \exp {\prim \exp} \typ \dir \\
       \ctxt = \funcCtxt \typ \\
       ({\prim {\exp}}, {\prim \typ}, {\dir}) = \castExpression {\typ} {\exp}\\
       }
     { \stmtenv {\return \exp} {\return {({\prim {\exp}}, {\prim \typ}, {\dir})}} \voidTyp  }
     \quad (\returnFuncS)

  \inferrule
     { \ctxt \neq \parserCtxt }
     { \stmtenv \exit \exit \voidTyp}
     \quad (\exitS)

  \inferrule
     { \ctxt \neq \parserCtxt \\
       (\prim \exp, \boolTyp, \dir) = \castExpression \boolTyp \exp \\
       \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 }
     { \stmtenvv 1 {\ifthen \exp {\stmt}} {\ifthen {\prim \exp} {\prim \stmt} } {\unitTyp} 1 }
     \quad (\ifthenS)

  \inferrule
     { \ctxt \neq \parserCtxt \\
       (\prim \exp, \boolTyp, \dir) = \castExpression \boolTyp \exp \\
       \stmtenvv 1 {\stmt_1} {\prim {\stmt_1}} {\typ_1} 2 \\
       \stmtenvv 1 {\stmt_2} {\prim {\stmt_2}} {\typ_2} 3 \\
       \prim \typ = \ifVoidTyp {\typ_1, \typ_2}}
     { \stmtenvv 1 {\ifthenelse \exp {\stmt_1} {\stmt_2}} {\ifthenelse {\prim \exp} {\prim {\stmt_1}} {\prim {\stmt_2}} } {\prim \typ} 1 }
     \quad (\ifthenelseS)

  \inferrule
     { \ctxt_0 = \applyBlockCtxt \\
       \expenvv \exp {\prim \exp} \typ \dir 0 \\
       \prim \typ = \reduce \typ \\
       \name_1, \ldots, \name_m = \getEnum {\prim \typ} \\
       \lbl \notin \overline \lbl \\
       \lbl \in \{\name_1, \ldots, \name_m \}\\
       \stmtenvv 0 {\block {\stmts}} {\block {\prim {\stmts}}} {\typ_0} 1 \\
       \stmtenvv 1 {\switch \exp {\overline {\actionCase \stmt}}} {\switch {\prim \exp} {\overline {\actionCase {\pprim \stmt} }}} \unitTyp 2
       }
     { \stmtenvv 0 {\switch \exp {\actionCase \stmts, \overline {\actionCase \stmt}} } {\switch {\prim \exp} {\actionCase {\prim \stmts}, {\overline {\actionCase {\pprim \stmt} }} } } \unitTyp 2 }
     \quad (\switchS)

  \inferrule
     { \isConstant \dcl \textOr \isInstantiation \dcl \textOr \isVariable \dcl \\
       \dclenvv 0 \dcl {\prim \dcl} 1}
     { \stmtenvv 0 \dcl {\prim \dcl} \unitTyp 1 }
     \quad (\declS)

~ End InfRule


# Declaration's Typing Rules { #sec-decl-typing }
is allowed type for variable checks if a type is allowed for declaring a variable. it includes all types after saturation except for string, integer, list, set, void, specialized type, package, control, parser, extern, function, action, constructor, and table.
check parameter shadowing takes two lists of paramets and checks if there is any duplicate in them. 

~ Begin InfRule

  \inferrule
     { \prim \typ = \trans \typ \emp \\
       (\prim \exp, \pprim \typ, \dir) = \castExpression \exp {\prim \typ}\\
       \val = \compileTimeEval {\prim \exp} }
     { \dclenvvv {\const \typ \var \exp} {\const {\prim \typ} \var \val} {\addConstEnv \var \val} {\addTypeEnv \var {(\prim \typ, \less)}}}
     \quad (\constantD)

  \inferrule
     { \expenv {\instantiation {\var} \args} {\instantiation {\var} {\prim \args}} {\prim \typ} \dir \\
       \ctxt \neq \toplevel \textOr \ctxt = \toplevel, ({\prim \typ} \neq \controlTyp {\_} {\_} \textOr \parserTyp {\_} {\_} )}
     { \dclenvvv {\inst \typVar \args \var {\ } } {\inst \typVar \args \var {\ }} \constEnv {\addTypeEnv \var {(\prim \typ, \less)}} }
     \quad (\instantD)

  \inferrule
    {}
    {blah}
    \quad (\parserD)
     % { \checkParamShadow param constructorparam \\
     %   }
     % { \dclenvvv {} {} {} {} }

  \inferrule
     { blah }
     { blah }
     \quad (\controlD)

  \inferrule
     { blah }
     { blah }
     \quad (\funcD)

  \inferrule
     { blah }
     { blah }
     \quad (\actionD)

  \inferrule
     { blah }
     { blah }
     \quad (\externFuncD)

  \inferrule
     { \ctxt \neq \toplevel \\
       \prim \typ = \trans \typ \emp \\
       \allowedTypeForVar {\prim \typ} \\
       \typWellFormed {\prim \typ}}
     { \dclenvvv {\varDecl \typ \var } {\varDecl {\prim \typ} \var} \constEnv {\addTypeEnv \var {(\prim \typ, \inout)}} }
     \quad (\varD)

  \inferrule
     { \ctxt \neq \toplevel \\
       \prim \typ = \trans \typ \emp \\
       \allowedTypeForVar {\prim \typ} \\
       \typWellFormed {\prim \typ} \\
       (\prim \exp, \prim \typ, \dir) = \castExpression  {\prim \typ} \exp}
     { \dclenvvv {\varInit \typ \var \exp} {\varInit {\prim \typ} \var {(\prim \exp, \prim \typ, \dir)}} \constEnv {\addTypeEnv \var {(\prim \typ, \inout)}} }
     \quad (\varInitD)

  \inferrule
     { blah }
     { blah }
     \quad (\valueSetD)

  \inferrule
     { blah }
     { blah }
     \quad (\tableD)

~ End InfRule

~ Begin InfRule

  \inferrule
     { blah }
     { blah }
     \quad (\headerD)

  \inferrule
     { blah }
     { blah }
     \quad (\headerUnionD)

  \inferrule
     { blah }
     { blah }
     \quad (\structD)

  \inferrule
     { blah }
     { blah }
     \quad (\errD)

  \inferrule
     { blah }
     { blah }
     \quad (\matchkindD)

  \inferrule
     { blah }
     { blah }
     \quad (\enumD)

  \inferrule
     { blah }
     { blah }
     \quad (\serEnumD)

  \inferrule
     { blah }
     { blah }
     \quad (\externObjD)

  \inferrule
     { blah }
     { blah }
     \quad (\typDefD)

  \inferrule
     { blah }
     { blah }
     \quad (\newtypeD)

~ End InfRule

~ Begin InfRule

  \inferrule
     { blah }
     { blah }
     \quad (\controlTypD)

  \inferrule
     { blah }
     { blah }
     \quad (\parserTypD)

  \inferrule
     { blah }
     { blah }
     \quad (\packageTypD)

  % \inferrule[ ]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

  % \inferrule[]
  %    {  }
  %    {  }

~ End InfRule

# References    { #sec-references }

~ Bibliography { caption:"00" }
~~Bibitem {#harper-types-PL}
Rober Harper.
Types and Prgarmming Languages.
<http://www.cs.cmu.edu/~rwh/courses/typesys/>
~~
~~Bibitem {#wiki-type-sys}
Type System.
<https://en.wikipedia.org/wiki/Type_system>
~~
~

# Appendix: Programming Languages Terminology { #sec-terminology }

It is important that the reader is familiar with the basic programming languages terminology. And more importantly, it is crucial for them to understand the reason for having a type system and what its role is. To this end, we introduce the main programming languages terminology used in this document.

**First, what is a type?**
You can simply think of types as a set of language elements that share some features.
For example, the type natural number is the set of numbers that is either zero or an increment of zero for multiple repetitions.
Grouping language elements into a set (called type) abstracts out some unncessary details when reasoning about programs.
That is why Harper states: "The central organizing principle of language design is the identitfication of language features with types."[@harper-types-PL]
``TODO: add an example here of what a type looks like.``

**Second, what is a type system?**
A _type system_ is a collection of rules that assign a property called type to the various language constructs, such as variables, functions, expressions, etc.[@wiki-type-sys]
Thus, a type system can be used as a simple reasoning tool for programs of a language.
A type system formally defines many aspects of a programming language.
Most importantly, it states which programs are allowed in the langauge, also known as a _well-typed_ program and if possible it assigns a type to such a program. Alternatively, you can think of a type system as a system that ensures the absence of certain group of errors in well-typed programs.

**Third, what is surface syntax and intermediate representation (IR)?**
The _surface syntax_ is the syntax used to write the source program by the developer
which eventually will be passed to the compiler. 
The compiler does multiple _passes_ between different representations to add or omit
information that it may or may not need. Each of these representations is called an
_intermediate representation_. 

``this paragraph is disconnected from the rest.``
Additionally, it is important for the reader to be able to read and understand typing
rules which in essence are _inference rules_. Thus, we introduce inference rules by
building a toy language gradually
and providing its various typing rules at each step (Section [#sec-guide]).

## A Developer's Guide to Reading Inference Rules { #sec-guide }

- ``maybe highlight the new feature and rule as you're adding them``
- ``say and show name can also be on the side of the rule.``
- ``state your type system changes based on your need``
- ``have explanation on inductive relation, grammar, and judgment``
- ``what we're basically doing is writing function/relation. it's a mathematical format for historical reasons we werite it this way.``
- ``do not do build up``
- ``have type checking with psudolang and show boilerplate and see how ugly. then massage it into inf rules and appeal to people's conciseness``
- ``sigma v to t is total but the env itself is partial``
- ``idea on some organization:``
  + grammars are inductively defined. a complier/rewritter can be inductively defined.
  + these are a bunch of relation/function. eg: exp to type. then add env. wellformedness is also a function but it has a different judgment.
  + the toatligy of it. the set of wel-typed terms is everything you can build with these rules. you can have a set.
  + start at the bottom to show something type checkes. 

A type system is made up of typing _rules_. A typing rule has a specific _judgment form_ (which is the format it is written in and guides the reader on how to read all the typing rules using the judgement).
A typing rule, in essence, is an _inference rule_.
An inference rule contains zero or more _premises_ above the line
and one _conclusion_ below the line
with the name of the rule on top or next to the line.
For example, the rule $\ruleName$ below reads as
$C$ is concluded if premises $A$ and $B$ hold.

~ Begin InfRule
  \inferrule[\ruleName]
    {A \\ B}
    {C}
~ End InfRule

A rule without any premises is called an _axiom_ and it states that
the conclusion holds uncoditionally.

Consider the simple toy expression language below that only consists of integers for now. Note
that $i$ is a _metavariable_ that represents any possible integer values. 

~ Begin P4Grammar
i := (any integer) 
e := i
~ End P4Grammar

We can have different typing systems for a language. For example, for our toy language we present two type systems.
The first one has the judgment form $e$ which states that the expression $e$ is well-typed.
For example, the rule $\rn{Integer1}\rE$ states that the expression $i$ is well-typed. Note that it does not 
state what its type is. 

~ Begin InfRule
  \inferrule[\rn{Integer1}\rE]
     {\ \ \ \ }
     {i}
~ End InfRule

We can have a more detailed type system for our langauge.
The second type system has the judgment form $e:t$ which states that the expression $e$
is well-typed and it has the type $t$. Note that $t$ is a metavariable for all possible types of expressions. 
The rule $\rn{Integer2}\rE$ states that the
expression $i$ is well-typed and it has the type $\mathsf{int}$.

~ Begin InfRule
  \inferrule[\rn{Integer2}\rE]
     { }
     {i:\mathsf{int}}
~ End InfRule

We now extend our toy language by adding variable reference to expression which are
simply strings. 

~ Begin P4Grammar
i := (any integer) 
v := (any string)
e := i
   | v
~ End P4Grammar

``explain expression vs statement``
``explain sigma: v to e is the type signature of env and say how to read it``

Now our type systems have to include an environment.
The environment $\Sigma$ is needed to keep track of variables that have been declared and assigned a value/expression. The environment is a mapping of variables to a feature about the variable. This feature can be the type of the variable, the expression it has been assigned, or the value resulting from evaluating the expression it has been assigned.

Here, we consider the environment to be a mapping of variables to their assigned expressions, that is, $\Sigma : v \rightarrow e$. Note that assigning expressions to variables is done in statements and not expressions and that is where the environment is built up. We only focus on expression's typing here.

``differentiate between the value of v which is a string and what it holds which is an expression and then it has the type int.``

The judgment form of our first type systems changes to $\Sigma \vdash e$ which states that under the environment $\Sigma$, the expression $e$ is well-typed.
The rule $\rn{Integer1}\rE$ states that under environment $\Sigma$, the expression $i$ is well-typed.
The typing system is also extended by a rule for variable reference.
The rule $\rn{Variable1}\rE$ states that under environment $\Sigma$, the expression $v$ is
well-typed if it exists in the environment. Note that $\Sigma(v)$ looks up variable $v$ from the environment $\Sigma$ and returns the expression assigned to it but since the rule does not need to do anything with that expression we use \_ to denote that the variable $v$ exists in the environment $\Sigma$ but we don't care about its asignee expression.
Note that in rule $\rn{Integer1}\rE$ we do not need to check the type of $i$ since $i$ only stands for integers and can only be constructed by integer values.

~ Begin InfRule
  \inferrule[\rn{Integer1}\rE]
     { }
     {\Sigma \vdash i}

  \inferrule[\rn{Variable1}\rE]
     {\Sigma(v)=\_}
     {\Sigma \vdash v}
~ End InfRule

The judgment form of our second type system also changes to $\Sigma \vdash e:t$ which states that under the environment $\Sigma$, the expression $e$ has the type $t$.
The rule $\rn{Integer2}\rE$ states that under environment $\Sigma$, the expression $i$ has the type $\mathsf{int}$.
The rule $\rn{Variable2}\rE$ states that under environment $\Sigma$, the expression $v$ has the type $\mathsf{int}$ if it exists in the environment $\Sigma$.

~ Begin InfRule
  \inferrule[\rn{Integer2}\rE]
     { }
     {\Sigma \vdash i:\mathsf{int}}

  \inferrule[\rn{Variable2}\rE]
     {\Sigma(v)=\_}
     {\Sigma \vdash v:\mathsf{int}}
~ End InfRule

Now we add booleans to our language.

~ Begin P4Grammar
i := (any integer)
v := (any string)
b := (any boolean)
e := i
   | v
   | b
~ End P4Grammar

The $\rn{Integer1}\rE$ and $\rn{Variable1}\rE$ rules do not change.
The rule $\rn{Boolean1}\rE$ states that under environment $\Sigma$, the expression $b$ is
well-typed.

~ Begin InfRule
  \inferrule[\rn{Integer1}\rE]
     { }
     {\Sigma \vdash i}

  \inferrule[\rn{Variable1}\rE]
     {\Sigma(v)=\_}
     {\Sigma \vdash v}

\inferrule[\rn{Boolean1}\rE]
     {\ \ \ \ }
     {\Sigma \vdash b}
~ End InfRule

The $\rn{Integer2}\rE$ stays the same. However, the type of the expression assigned to
a variable now matters. This is stated in the $\rn{Variable2}\rE$. It particularly states that under the environment $\Sigma$, the expression $v$ has the type $t$ if the type of the expression $e$ assigned to the variable $v$ is $t$. Note that in this rule, we can no longer ignore the expression assigned to variable $v$ which is returned by looking $v$ up in the environment since we need to know its type. 
The $\rn{Boolean2}\rE$ simply states that under the environment $\Sigma$, the expression $b$ has the type $\mathsf{bool}$.

~ Begin InfRule
  \inferrule[\rn{Integer2}\rE]
     { }
     {\Sigma \vdash i:\mathsf{int}}

  \inferrule[\rn{Variable2}\rE]
     {\Sigma(v)=e \\
      \Sigma \vdash e:t}
     {\Sigma \vdash v:t}

  \inferrule[\rn{Boolean2}\rE]
     { }
     {\Sigma \vdash b:\mathsf{bool}}
~ End InfRule

Now we extend our language by adding the integer addition operation.

~ Begin P4Grammar
i := (any integer)
v := (any string)
b := (any boolean)
e := i
   | v
   | b
   | e + e
~ End P4Grammar

The first type system (that consists of rules $\rn{Integer1}\rE$, $\rn{Variable1}\rE$, and $\rn{Boolean1}\rE$ is no longer sufficient because the addition operator requires both operands not only to be well-typed but also to be an integer.

The typing rules of the second type system stay the same.
The rule $\rn{Addition2}\rE$ states that under the environment $\Sigma$, the expression
$e_1 + e_2$ has the type $\mathsf{int}$ if both expressions $e_1$ and $e_2$ have the type $\mathsf{int}$. 

~ Begin InfRule
  \inferrule[\rn{Integer2}\rE]
     { }
     {\Sigma \vdash i:\mathsf{int}}

  \inferrule[\rn{Variable2}\rE]
     {\Sigma(v)=e\\
     \Sigma \vdash e:t}
     {\Sigma \vdash v:t}

  \inferrule[\rn{Boolean2}\rE]
     { }
     {\Sigma \vdash b:\mathsf{bool}}

  \inferrule[\rn{Addition2}\rE]
     {\Sigma \vdash e_1:\mathsf{int} \\
      \Sigma \vdash e_2:\mathsf{int} }
     {\Sigma \vdash e_1 + e_2 : \mathsf{int}}
~ End InfRule

We could have restrictions on the types of subexpression. For example, assume we extend
our toy language with equality checking which checks the equality of two subexpressions of the same type. 

~ Begin P4Grammar
i := (any integer)
v := (any string)
b := (any boolean)
e := i
   | v
   | b
   | e + e
   | e == e
~ End P4Grammar

The $\rn{Equality2}\rE$ rule states that under the environment $\Sigma$, the expression
$e_1 == e_2$ has the $\mathsf{bool}$ type if expressions $e_1$ and $e_2$ both have the same type. 

~ Begin InfRule
  \inferrule[\rn{Integer2}\rE]
     { }
     {\Sigma \vdash i:\mathsf{int}}

  \inferrule[\rn{Variable2}\rE]
     {\Sigma(v)=e\\
     \Sigma \vdash e:t}
     {\Sigma \vdash v:t}

  \inferrule[\rn{Boolean2}\rE]
     { }
     {\Sigma \vdash b:\mathsf{bool}}

  \inferrule[\rn{Addition2}\rE]
     {\Sigma \vdash e_1:\mathsf{int} \\
      \Sigma \vdash e_2:\mathsf{int} }
     {\Sigma \vdash e_1 + e_2 : \mathsf{int}}

  \inferrule[\rn{Equality2}\rE]
     {\Sigma \vdash e_1:t_1 \\
      \Sigma \vdash e_2:t_2 \\
      t_1 = t_2}
     {\Sigma \vdash e_1 == e_2 : \mathsf{bool}}
~ End InfRule

An inference rule is not only used for specifying types of programs. In fact, inference
rules are used to write translation of programs from one representation to another,
program syntesis, type inference, program semantics, etc.
For example, the rules below rewrite expressions in our toy language (which uses infix ordering of operators) to one that uses prefix ordering of operators
and they have the judgment form $\Sigma \vdash e \rightarrow \prim e$ which states that under the environment $\Sigma$, the expression $e$ written in the infix ordering translates to expression $\prim e$ written in the prefix ordering.

The rules $\rn{Integer3}\rE$, $\rn{Variable3}\rE$, and $\rn{Boolean3}\rE$ are rather simple. For example, the $\rn{Integer3}\rE$ rule states that under the environment $\Sigma$, the expression $i$ translates to $i$.
The rules $\rn{Addition3}\rE$ and $\rn{Equality3}\rE$ recursively translate their subexpressions and reorder their operators.
For example, the $\rn{Addition3}\rE$ rule states that the expression $e_1 + e_2$ translates to the expression $+ \ \prim {e_1} \ \prim {e_2}$ where expressions $\prim {e_1}$ and $\prim {e_2}$ are the translations of expressions $e_1$ and $e_2$, respectively. 

~ Begin InfRule
  \inferrule[\rn{Integer3}\rE]
     { }
     {\Sigma \vdash i \rightarrow i}

  \inferrule[\rn{Variable3}\rE]
     {\Sigma(v)=\_}
     {\Sigma \vdash v \rightarrow v}

  \inferrule[\rn{Boolean3}\rE]
     { }
     {\Sigma \vdash b \rightarrow b}

  \inferrule[\rn{Addition3}\rE]
     {\Sigma \vdash e_1 \rightarrow \prim {e_1} \\
      \Sigma \vdash e_2 \rightarrow \prim {e_2}}
     {\Sigma \vdash e_1 + e_2 \rightarrow \ + \ \prim {e_1} \ \prim {e_2}}

  \inferrule[\rn{Equality3}\rE]
     {\Sigma \vdash e_1 \rightarrow \prim {e_1}\\
      \Sigma \vdash e_2 \rightarrow \prim {e_2} }
     {\Sigma \vdash e_1 == e_2 \rightarrow \ == \prim {e_1} \ \prim {e_2}}
~ End InfRule

``phrase the following paragraph and its point differently: the main point is that inference rules define inductively defined relation. these relations can be simple or complicated. eg, so far we have had simple ones but below we have more complicated ones. also use wiggly arrow and use colon for type, that is, i wiggly arrow i colon int``
An inference rule can conduct multiple tasks at the same time. In other words, an inference rule can be a combination of two inference rules. For example, the typing rules below combine the typing and rewritting rules shown above and they have the judgment form
$\Sigma \vdash e \rightarrow \prim e, t$ which states that under the environment $\Sigma$, the expression $e$ written in the infix ordering translates to the expression $\prim e$ written in the prefix ordering and has the type $t$. 
As an example , the $\rn{Variable4}\rE$ rule reads as under the environment $\Sigma$, the expression $v$ translates to itself and has the type $t$ if the variable $v$ exists in environment $\Sigma$ and expression $e$ is assigned to it which has the type $t$. 

~ Begin InfRule
  \inferrule[\rn{Integer4}\rE]
     { }
     {\Sigma \vdash i \rightarrow i, \mathsf{int}}

  \inferrule[\rn{Variable4}\rE]
     {\Sigma(v)=e\\
     \Sigma \vdash e \rightarrow \_, t}
     {\Sigma \vdash v \rightarrow v, t}

  \inferrule[\rn{Boolean4}\rE]
     { }
     {\Sigma \vdash b \rightarrow b, \mathsf{bool}}

  \inferrule[\rn{Addition4}\rE]
     {\Sigma \vdash e_1 \rightarrow \prim {e_1}, \mathsf{int} \\
      \Sigma \vdash e_2 \rightarrow \prim {e_2}, \mathsf{int} }
     {\Sigma \vdash e_1 + e_2 \rightarrow + \ \prim {e_1} \ \prim {e_2}, \mathsf{int}}

  \inferrule[\rn{Equality4}\rE]
     {\Sigma \vdash e_1 \rightarrow \prim {e_1}, t_1 \\
      \Sigma \vdash e_2 \rightarrow \prim {e_2}, t_2 \\
      t_1 = t_2}
     {\Sigma \vdash e_1 == e_2 \rightarrow \ == \ \prim {e_1} \ \prim {e_2}, \mathsf{bool}}
~ End InfRule

# Appendix: Petr4 { #sec-petr4 }

## Petr4's Architecture { #sec-arch }

Figure [#fig-arch] depicts part of Petr4's architecture that contains the type system.
After lexing and parsing a P4 program we get a program in our surface syntax. This
program is then passed through the _elaborator_ where type variables are introduced
instead of underscore and new type variable names are generated for variables with the
same name but in different scopes. This document does not discuss the innerworkings of
`elaborate`. Then, the program is passed through the type system (encoded in `checker`).
This document discusses the innerworking of the type system extensively. Finally, the
program is evaluated.

~ Figure { #fig-arch; caption: "Part of Petr4's achitecture." }
![arch]
~
[arch]: figs/petr4/arch.png { width: 100%; page-align: forcehere }


## Petr4's Type System { #sec-petr4-type-sys }

The type system conducts three tasks simultaneously:

1. It type checks P4 programs.
2. It conducts type inference.
3. It does a pass from the surface syntax to the first IR.

```**TODO** maybe have more explanation on IR.```

## Connecting Formalization to Petr4's Implementation { #sec-conn }

The following locates each data type in the implementation
(<https://github.com/verified-network-toolchain/petr4>):

- The surface AST is _types.program_
- The type of programs of the surface syntax is _types.type.t_
- The first IR is _prog.program_
- The type of the first IR is _prog.type.t_
- The type system is implemented in _checker.ml_ file. 

For simplicity, we have removed the information that is needed to report when an error
happens. Such information is passed around in the surface syntax as a field (called
`tags`) of record for all data types.

