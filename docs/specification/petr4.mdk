Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp
Package: mathtools
Package: xspace

.math, .mathpre, .math-inline {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/( +)-\|( +)/\1\dashv{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/~\>/\rightsquigarrow{}/g";
  replace: "/\bG([^a-zA-Z])/\Gamma{}\1/g";
  replace: "/\bD([^a-zA-Z])/\Delta{}\1/g";
  replace: "/\bS([^a-zA-Z])/\Sigma{}\1/g";
  replace: "/\bt([^a-z])/\tau{}\1/g";
  replace: "/</\langle{}/g";
  replace: "/>/\rangle{}/g";
  replace: "/\b:=\b/\coloneqq{}/g";
}

Judgment {
  replace:"~ Begin MathPre {.infer}&nl;&nl;\boxed{&source;}&nl;\
           ~ End MathPre";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

p4mathgrammar {
  replace:"/\/\/(.*)/\/\/ &\text{\1}/g";
  replace: "~ Begin P4MathGrammarBlock&nl;\
                 ~ Begin MathPre&nl;&source;&nl;~ End MathPre&nl;\
                 ~ End P4MathGrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expression Syntax

~ Begin P4MathGrammar
e ::= @true
    | @false
    | a // arbitrary width integer literal
    | nwa // unsigned integer literal of size n
    | nsa // signed integer literal of size n
    | u // strings
    | x // name
    | .x // top level name
    | e1[e2] // array access
    | e1[e2:e3] // bitslice
    | \{ \overline{e} \} // list
    | \{ \overline{name=e} \} // records
    | uop e
    | e1 binop e2
    | (t) e // explicit cast
    | X.name // type member
    | @error.name // errors
    | e.name // expression member
    | e1 ? e2 : e3 // ternary operator
    | f<\overline{t}>(\overline{e}) // function call
    | t(\overline{e}) // nameless instantiation
    | e1 \texttt{\&\&\&} e2 // mask
    | e1 .. e2 // range
~ End P4MathGrammar

~ Begin P4Grammar
// unary operators
uop ::= ! // not
      | - // unary minus
      | ~ // bitwise complement/not

// binary operators
binop ::= +
        | |+|
        | -
        | |-|
        | *
        | /
        | %
        | <<
        | >>
        | <
        | >
        | <=
        | >=
        | ==
        | !=
        | &
        | ^
        | |
        | ++
        | &&
        | ||
~ End P4Grammar

## Statement and Block Syntax
~ Begin P4MathGrammar
s ::= e<\overline{t}>(\overline{e})     // method calls (positional)
    | e := e                            // assignment
    | t.@apply(\overline{e})             // direct type invocation
    | @if (e) s_1 @else s_2             // conditional statement
    | blk                               // block statement
    | @exit                             // exit statement (only in controls)
    | \mathkw{;}                        // empty statement
    | @return                           // return (void)
    | @return e                         // return (with value)
    | @switch (e) \{ \overline{case} \} // switch statement
    | decl                              // declaration statement

case ::= case\_lbl: blk  // label with block
       | case\_lbl: {}   // fallthrough

case\_lbl ::= x                // name (of action)
            | \texttt{default} // catch-all label

blk ::= \{ s_1; ... s_n; \} // blocks
~ End P4MathGrammar

## Declaration Syntax
~ Begin P4MathGrammar
decl ::= @const t x:=e
       | t x(\overline{e})
       | @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}
       | @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}
       | @function t x<\overline{X}>(\overline{x:t,d}) blk
       | \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})
       | t x
       | t x := e
       | \mathkw{value\_set}<t>(e) x
       | @action x (\overline{x:t,d_0},\overline{x:t}) blk
       | @table x \{ \overline{prop} \}
       | @header X \{ \overline{x:t} \}
       | \mathkw{header\ union} X \{ \overline{x:t} \}
       | @struct X \{ \overline{x:t} \}
       | @error \{ \overline{x} \}
       | \mathkw{match\_kind} \{ \overline{x} \}
       | @enum X \{ \overline{x} \}
       | @enum t X \{ \overline{x=e} \}
       | @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
       | @typedef t X
       | @type t X
       | @control X<\overline{X}>(\overline{x:t,d})
       | @parser X<\overline{X}>(\overline{x:t,d})
       | @package X<\overline{X}>(\overline{x:t})

state ::= @state x \{ \overline{s}; @transition state\_expr \}

state\_expr ::= x
              | @select (\overline{e}) \{ \overline{matches:x} \}

matches = \overline{match}

match ::= \mathkw{\_}
        | e

ctor ::= X(\overline{x:t})

method ::= @abstract t x<\overline{X}>(\overline{x:t,d})
         | t x<\overline{X}>(\overline{x:t,d})

prop ::= @key = \{ \overline{e:x} \}
       | @actions = \{ \overline{action\_ref} \}
       | @const @entries = \{ \overline{matches:action\_ref} \}
       | x = e
       | @const x = e

action\_ref ::= x(\overline{e})
~ End P4MathGrammar

## Program Syntax
A program is a sequence of declarations.
~ Begin P4MathGrammar
P ::= decl, P
    | ()
~ End P4MathGrammar

## Type Syntax

~ Begin P4MathGrammar
t ::= @bool
    | @string
    | @int
    | @int<w>
    | @bit<w>
    | @varbit<w>
    | t[a]
    | @tuple<\overline{t}>
    | \{ \overline{t} \}
    | \{ \overline{f:t} \}  // record type
    | @set<t>
    | @error
    | \mathkw{match\_kind}
    | X  // type name
    | .X // top level type reference
    | @newtype t X
    | @void
    | @header \{ \overline{f:t} \}
    | \mathkw{header\ union} \{ \overline{f:t} \}
    | @struct \{ \overline{f:t} \}
    | @enum X \{ \overline{x} \}
    | @enum t X \{ \overline{x=v} \}
    | t<\overline{t}> // specialized type
    | @package<\overline{X}>(\overline{x:t,d})
    | @control<\overline{X}>(\overline{x:t,d})
    | @parser<\overline{X}>(\overline{x:t})
    | @extern X \{ \overline{method} \}
    | @function<\overline{X}>(\overline{x:t,d}):\tau
    | @action(\overline{x:t,d_0}, \overline{x:t}):@void
    | @constructor<\overline{X}>(\overline{x:t}):t
    | @table t

d0 ::= @in
     | @out
     | @inout

d ::= d0 | @none
~ End P4MathGrammar

Results $res$ are types for statements. 
~ P4MathGrammar
res\in{}@Result::=@returns t // returns
              | @rejects     // rejects
              | @unit        // does not return or reject
~

Contexts indicate where a statement is being typechecked.
~ P4MathGrammar
ctx ::= @InFunction t
      | @InControl
      | @InParser
      | @InAction
~

## Value Syntax

$a \in \mathbb{Z}$

$n \in \mathbb{N}$

$\mathbb{Z}_n ::= m \% 2^n | m \in \mathbb{Z}$

$m_u^n \in \mathbb{Z}_n$

$m_s^n \in \mathbb{Z}_{n-1} \cup \{ -x | x \in \mathbb{Z}_n\}$

Locations in memory:  $\ell$

Values
~ Begin P4MathGrammar
v_o ::= b // booleans
    | a // arbitrary-width integers
    | m_u^n // unsigned integers, n not zero
    | m_s^n // signed integers, n not zero
    | (n', m_u^{n}) // variable-size bitstrings, n less than n'
    | u // strings
    | (\overline{v}) // tuples
    | \{ \overline{name=v} \} // records
    | set
    | @error.name
    | @matchkind name
    | \xi_{closure}\otimes{}v_{anon} // closures
    | @builtin name lv
    | @struct \{ \overline{(name, v)} \}
    | @header b \{ \overline{(name, v)} \}
    | \mathkw{header\ union} \{ \overline{(name, v)} \}
    | (\overline{v}, n_{size}, n_{next}) // stacks
    | name_1.name_2 // enumfield
    | (name_1.name_2, v) // senumfield
    | (\ell, name_{object}) // stateful runtime
    | @parser \overline{(name, v)} (\overline{x:t,d}) \overline{decl} \overline{state}
    | @control \overline{(name, v)} (\overline{x:t,d}) \overline{decl} blk
    | @package \overline{(name, v)}
    | @table name \overline{e:x} \overline{action\_ref} action\_ref_default \{ \overline{matches:action\_ref} \}
    | @extern name v

v_{anon} ::= @function<X>(\overline{x:t,d}) blk                // function code
    	   | @action(\overline{x:t,d_0},\overline{x:t}) blk    // action code

v ::= v_o | @None
~ End P4MathGrammar

Sets
~ Begin P4MathGrammar
set ::=  @universal
    | @singleton w v
    | v1 \texttt{\&\&\&} v2 // mask
    | v1 .. v2 // range
    | @product \overline{set}
    | @lpm w v1 v2
    | \mathkw{value\_set} \overline{matches} \overline{set}
~ End P4MathGrammar

## LValue Syntax
~ Begin P4MathGrammar
lv ::= \ell
     | lv.x
     | lv[n1:n2]
     | lv[n]
~ End P4MathGrammar

## Signal Syntax
Statements evaluate to signals, which describe control flow.
~ Begin P4MathGrammar
sig::=@return v
      | @return
      | @exit
      | @transition @reject x
      | @transition @accept
      | @transition x
ssig ::= @go
      | @stop sig_0
vsig ::= @ok v
       | @stop sig_0
lsig ::= @ok lv
       | @stop sig_0
~ End P4MathGrammar

# Static Semantics { #sec-static }

## Typing contexts

All typing judgments include

1. $\Sigma$, the values of any compile-time-known constants,
2. $\Delta$, the definitions of type names in scope, and
3. $\Gamma$, the types of variables in scope.

Some judgments need a store typing $\Xi$.

Type variables are tracked by mapping type names $X$ to themselves in
the context $\Delta$. Equivalently there could be another context that
was a list of lists of type variables, without them being mapped to
anything.

~ MathPre
\sigma ::= \sigma, x=v | []

S ::= S, \sigma{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []

\gamma ::= \gamma, x:t,d | []

G ::= G, \gamma{} | []

\Xi ::= \Xi, \ell:t | []
~

There are also lookup tests defined for $C \in \{ S, D, G \}$ and $c \in \{ \sigma, \delta, \gamma, \Xi \}$.
~ Judgment
c(x) = y
~

~ Infer
c = c', x = y
--------------[]
c(x) = y
~

~ Infer
c = c', u = v
u \neq x
c'(x) = y
-------------------------------[]
c(x) = y
~

~ Judgment
C(x) = y
~

~ Infer
C = C', c
c(x) = y
--------------------[]
C(x) = y
~

~ Infer
C = C', \sigma
x\notin{}@dom c
S'(x) = y
-------------------------------[]
C(x) = y
~

~Judgment
C(.x) = y
~

~ Infer
C = [], c
c(x) = y
-----------------------[]
C(.x) = y
~

~ Infer
C = C', c
C'(.x) = y
-----------------------[]
C(.x) = y
~

## Helper Judgments

### Numeric types
Judgment form $\mathkw{numeric}(t)$ with 3 rules.
~ MathPre
\inferrule{ }{@numeric(@int)}   \inferrule{ }{@numeric(@int<w>)}   \inferrule{ }{@numeric(@bit<w>)}
~

### LValue Judgment
*TODO: this is maybe a misnamed judgment. Actual lvalues are
rooted at memory locations, not variables, so its confusing to name
this judgment lvalue when it really is checking that you can evaluate
the thing to an lvalue. Better name might be $\mathkw{assignable}$?}*

Left-values or lvalues are expressions that can appear on the left
side of an assignment $e:=e$. As its signature suggests, this judgment
presupposes $S,D,G |- e:t$.
~ Judgment
S,D |- e:t @lvalue
~

~ Infer
t not a stateful, constant, or function type
x\notin{}@dom S
-----------------------------------------------[Name-LValue]
S,D,G |- x:t @lvalue
~

~ Infer
t not a stateful, constant, or function type
x\notin{}@dom S
----------------------------------------------[Top-Level-Name-LValue]
S,D,G |- .x:t @lvalue
~

~ Infer
e @lvalue
x not a builtin field on t
----------------------------------[Member-LValue]
S,D,G |- e.x:t @lvalue
~

~ Infer
e1 @lvalue
----------------[Index-LValue]
e1[e2]:t @lvalue
~

~ Infer
e @lvalue
----------------[Slice-LValue]
e[n1:n2]:t @lvalue
~

## Expression Typing
### Type Constants

~ Infer

------------------------[Bool-True]
S,D,G |- @true : @bool
~

~ Infer

------------------------[Bool-False]
 S,D,G |- @false : @bool
~

~ Infer

------------------------[String]
 S,D,G |- u : @string
~

~ Infer

------------------------[Int-Constant]
S,D,G |- a : @int
~

~ Infer

------------------------[Signed-Int-Constant]
S,D,G |- nsa : @int<n>
~

~ Infer

------------------------[Unsigned-Int-Constant]
S,D,G |- nwa : @bit<n>
~

### Type Variables

~ Infer
G(x) = t, d
-------------------[Var]
S,D,G |- x : t, d
~

~ Infer
G(.x) = t, d
----------------------[Var-Top]
S,D,G |- .x : t, d
~

### Type Accesses

~ Infer
S,D,G |- e_1 : t_1[], d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
----------------------[Array-Access]
S,D,G |- e_1[e_2] : t_1, d_1
~

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
S,D,G |- e_3  : t_3, \_
@numeric(t_3)
0 \leq S(e_3) \leq S(e_2) < w
------------------------------[Slice]
S,D,G |- e1[e2:e3] : bit<S(e_2) - S(e_3) + 1>, d_1
~

~ Infer
S,D,G |- \overline{e: \tau, none}
-----------------------------------------------[List-Expression]
S,D,G |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
~

~ Infer
S,D,G |- \overline{e : t}
----------------------------------------------------------[Record]
S,D,G |- \{ \overline{f = e} \} : \{ \overline{f : t} \}
~

### Type Unary Operations

~ Infer
S,D,G |- e : @bool, d
----------------------[Not]
S,D,G |- !e : @bool, d
~

~ Infer
S,D,G |- e : @bit<w>, d
-----------------------------[Bitwise-Not]
S,D,G |- {\texttt{\textasciitilde}e} : @bit<w>, d
~

~ Infer
S,D,G |- e : t, d
@numeric(t)
--------------------[Negate]
S,D,G |- {-e} : t, d
~

### Type Binary Operations

```haskell
  fun binaryDir In In = In
    | binaryDir _  _  = none
```

~ Infer
S,D,G |- e_1 : @bool, d_1
S,D,G |- e_2 : @bool, d_2
\diamond \in \{ \&\&, || \}
------------------------------------------------------------------[Bool-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int, d_1
S,D,G |- e_2 : @int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
--------------------------------------------------------[Int-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int<w>, d_1
S,D,G |- e_2 : @int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
-----------------------------------------------------------[Int-Signed-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int<w>, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2 : @bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
----------------------------------------------------------[Int-Unsigned-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bit<w>, @binaryDir(d_1, d_2)
~

<!--
need to define has_equality
-->

~ Infer
S,D,G |- e_1 : t, d_1
S,D,G |- e_2 : t, d_2
\mathkw{has\_equality}(t)
\diamond \in \{ ==,!= \}
----------------------------------------------------------[Equality-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @bit<l>, d_1
S,D,G |- e_2 : @bit<r>, d_2
---------------------------------[Bit-Concat-Op]
S,D,G |- e_1 \mathbin{++} e_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : t_1, d_1
S,D,G |- e_2 : t_2, d_2
@numeric(t_1)
t_2 = @bit<\_> \lor t_2 = @int
\diamond \in \{\ll, \gg\}
---------------------------------[Shift-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : t_1, @binaryDir(d_1, d_2)
~

### Type Casts

Casting from $\tau_0$ to $\tau$ is permitted by the
$\tau \prec \tau'$ judgment.

The equality sign here hasn't been defined and probably won't make
sense without adding a context for looking up variables and type
names.
~ Infer
t = t'
-------------------------------------------[]
t \mathrel{\prec} t'
~

~ Infer

---------------------[]
@int \mathrel{\prec} @int<w>
~
~ Infer

---------------------[]
@int \mathrel{\prec} @bit<w>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @tuple<t_1, \dots, t_n>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @header \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @struct \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
t \mathrel{\prec} @enum t X \{m_1, ..., m_n\}
~

~ Infer

-------------------------------------------[]
@enum t X \{m_1, ..., m_n\} \mathrel{\prec} t
~

~ Infer

-------------------------------[]
@newtype t X \mathrel{\prec} t
~

~ Infer

-------------------------------[]
t \mathrel{\prec} @newtype t X
~

~ Infer
S,D,G |- e : t_0, d
t_0 \prec t
------------------------[Cast]
S,D,G |- (t) e : t, @none
~

### Type Member expressions
~ Infer
D(X) = @enum t X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Serializable-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
D(X) = @enum X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
G(@error.name) = @error
-------------------------------------[Error-Member]
S,D,G |- @error.name : @error, @none
~

Field and method lookups on expressions are delegated to another
judgment $\mathkw{has\_field}\ t\ name\ t_{name}$.
~ Infer
S,D,G, |- e : t, d
\mathkw{has\_field} t name t_{name}
------------------------------------[Expression-Member]
S,D,G |- e.name : t_{name}, @none
~

~ Infer

---------------------------------------------------------------------[Header-Field]
\mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

TODO: need to make sure all types in a header union are headers.

~ Infer

--------------------------------------------------------------------------------[Header-Union-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

-------------------------------------------------------------------[Struct-Field]
\mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

---------------------------------------------------------------------------------[Header-IsValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~

~ Infer

---------------------------------------------------------------------------------[Header-SetValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setValid (() -> @void)
~

~ Infer

-----------------------------------------------------------------------------------[Header-SetInvalid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setInvalid (() -> @void)
~

~ Infer

---------------------------------------------------------------------------------------------[HeaderUnion-IsValid-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~


~ Infer

--------------------------------------------------------------------------------[Control-Apply-Field]
\mathkw{has\_field} (@control \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Parser-Apply-Field]
\mathkw{has\_field} (@parser \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Table-Apply-Field]
\mathkw{has\_field} (@table t) @apply (() -> t)
~

~ Infer

-------------------------------------------------------------------[Array-Size-Field]
\mathkw{has\_field} t[a] @size @bit<32>
~

~ Infer

-------------------------------------------------------------------[Array-LastIndex-Field]
\mathkw{has\_field} t[a] @lastIndex @bit<32>
~

~ Infer

-------------------------------[Array-Next-Field]
\mathkw{has\_field} t[a] @next t
~

~ Infer

-------------------------------[Array-Last-Field]
\mathkw{has\_field} t[a] @last t
~

~ Infer

-------------------------------[Array-PushFront-Field]
\mathkw{has\_field} t[a] \mathkw{push\_front} ((count: @int) -> @void)
~

~ Infer

-------------------------------[Array-PopFront-Field]
\mathkw{has\_field} t[a] \mathkw{pop\_front} ((count: @int) -> @void)
~


### Type Ternary Expression

~ Infer
S,D,G |- e_1 : @bool, \_
S,D,G |- e_2 : t, \_
S,D,G |- e_3 : t, \_
--------------------------------[Ternary-Op]
S,D,G |- e_1 ? e_2 : e_3 : t, @none
~

### Direction agreement
Expressions passed as out or inout parameters must be lvalues. This
judgment checks that.

~ Judgment
S,D,G |- e:t @goes d
~
~ Infer
S,D,G |- e:t @goes @out
S,D,G |- e:t @goes @in
-------------------------[]
S,D,G |- e:t @goes @inout
~
~ Infer
S,D,G |- e:t @lvalue
-------------------------[]
S,D,G |- e:t @goes @out
~
~ Infer

-------------------------[]
S,D,G |- e:t @goes @in
~
~ Infer

-------------------------[]
S,D,G |- e:t @goes @none
~

### Type Function Calls
~ Infer
S,D,G |- f:@function<\overline{X}>(\overline{x:t,d}):t_{ret}
S,D[\overline{X=\rho}],G |- \overline{e:t,d}
S,D,G |- \overline{e:t' @goes d}
D[\overline{X=\rho}] |- \tau_{ret}~>\tau_{ret}'
----------------------------------------------------------------------------[Function-Call]
S,D,G |- f<\overline{\rho}>(\overline{e}):\tau_{ret}'
~

~ Infer
S,D,G |- f:@action<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
P,S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
\overline{@P_{call} d}
----------------------------------------------------------------------------[Action-Call]
S,D,G |- f<\overline{\rho}>(\overline{e}):\tau_{\mathsf{ret}}, @none
~

### Type Nameless Instantiation

We need a function to resolve overloads.
~ Infer
t_{ctor} = @constructor<\overline{X}>(\overline{x:t}): t
@length \overline{x:t} = n
X:t_{ctor} \in G
---------------------------------------------------------[Resolve-Constructor-Overload]
\mathkw{resolve\_overload} G X n = t_{ctor}
~

~ Infer
@length \overline{e} = n
@length \overline{\rho} = @length \overline{X}
\mathkw{resolve\_overload} G Y n = @constructor<\overline{X}>(\overline{x:t}): t_{ret}
S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
--------------------------------------------------------------------[Specialized-Type-Instantiation]
S,D,G |- Y<\overline{\rho}>(\overline{e}) : t_{ret}[\overline{\rho/X}]
~

~ Infer
S,D,G |- X<>(\overline{e}) : t
----------------------------------[Simple-Type-Instantiation]
S,D,G |- X(\overline{e}) : t
~

### Type Set Operations

TODO: the Masks rule is based off of the spec
and diverges from the type checker's implementation

~ Infer
S,D,G |- e_1 : @bit<w>, \_
S,D,G |- e_2 : @bit<w>, \_
------------------------------------------------[Masks]
S,D,G |- e_1 \texttt{\&\&\&} e_2 : @set<@bit<w>>,@none
~

~ Infer
S,D,G |- e_1 : \tau, \_
S,D,G |- e_2 : \tau, \_
\tau = @bit<w> \lor \tau = @int<w>
-------------------------[Ranges]
S,D,G |- e_1\mathbin{..}e_2 : @set<\tau>, @none
~

## Evaluation environment typing
The ${\Xi} \vdash E:\Gamma$ judgment constructs a typing context from an
evaluation environment. We may write $\Xi \vdash \xi:\Gamma$ to indicate
$\Xi \vdash E:\Gamma$ when $\xi = (P,E,\Delta,\upsilon)$.

First we need an auxiliary judgment on individual
scopes.
~ Judgment
\Xi\vdash{}\epsilon:\gamma
~
~ Infer

----------------------------------------------[Type-Env-Scope-Empty]
\Xi\vdash [],[]
~

~ Infer
\Xi(\ell)=t
----------------------------------------------[Type-Env-Scope-Binding]
\Xi\vdash \epsilon,x=\ell:\gamma,x:t
~

~ Judgment
\Xi\vdash{}E:G
~
~ Infer

------------------------------------------------------[Type-Env-Empty]
\Xi \vdash []:[]
~

~ Infer
\Xi \vdash \xi:G
\Xi \vdash \epsilon:\gamma
----------------------------------------------------[Type-Env-Binding]
\Xi \vdash \xi,\epsilon:G,\gamma
~

## LValue typing
~ Judgment
\Xi |- lv:t
~

TODO:I'm leaving off rules for name lookup because that process is
already described in the expression typing rules and there's no point
in maintaining two versions of it at present.

~ Infer
\Xi(\ell)=t
----------------[]
\Xi |- \ell:t
~

~ Infer
\Xi(\ell)=t[n]
-------------------[]
\Xi |- \ell[m]:t
~

~ Infer
\Xi(\ell)=@bit<m>
-------------------[]
\Xi |- \ell[n1:n2]
~

## Value Typing
Values can include references to memory locations, so typechecking them
requires a store typing $\Xi$.
~ Judgment
\Xi |- v:t
~

Here are the interesting rules. TODO:remaining rules
~ Infer
\Xi |- \xi:G
[];D[X=X];G,\overline{x:t} |- blk:@returns \tau_{ret} -| G'
----------------------------------------------------------------------------------------------------------------[Type-Value-Function]
\Xi |- (P,E,\Delta,\upsilon)\otimes{}@function<X>(\overline{x:t,d}) blk:@function<X>(\overline{t,d}):\tau_{ret}
~
~ Infer
\Xi |- \xi:G
[];D;G,\overline{x:t} |- blk:@returns @void -| G'
------------------------------------------------------------------------------------------------------------------[Type-Value-Action]
\Xi |- (P,E,\Delta,\upsilon)\otimes{}@action(\overline{x:t,d_0},\overline{x:t}) blk:@action(\overline{x:t,d_0},\overline{x:t}):@void
~

~ Infer
\Xi |- lv:t
\mathkw{has\_field} t name t_{name}
----------------------------------------------------------[Type-Value-Builtin]
\Xi |- @builtin name lv: t_{name}
~

~ Infer
\Xi |- \ell:@extern X \{\overline{method}\}
----------------------------------------------------------[Type-Value-Extern]
\Xi |- (\ell, name_{object}):@extern X \{\overline{method}\}
~

## Store typing
~ Infer
\Xi |- v:t
\Xi(\ell)=t
-----------------------[]
\Xi |- \ell=v,\sigma.
~

~ Infer

-----------------------[]
\Xi |- []
~

## Statement Typing

### Merging statement types

There is a judgment $D |- \mathkw{resmeet}(res_1,res_2,res)$ defined
as follows.
~ MathPre
\inferrule{ }{@resmeet(@unit, @unit, @unit)}

\inferrule{ }{@resmeet(@rejects, @unit, @rejects)}     \inferrule{ }{@resmeet(@unit, @rejects, @rejects)}     \inferrule{ }{@resmeet(@rejects, @rejects, @rejects)}

\inferrule{D |- t\equiv{}t'}{@resmeet(@returns t, @returns t', @returns t)}       \inferrule{ }{@resmeet(@returns t, @unit, @returns t)}      \inferrule{ }{@resmeet(@unit, @returns t, @returns t)}
~

### Statement typing judgment
Statements are typed by a judgment of the form
~ MathPre
S,D,G,ctx |- s:res -| G'.
~

The judgment is defined inductively by the following rules.

~ Infer
S,D,G |- e<\overline{t}>(\overline{e}):@void
-------------------------------------------------------[Type-Stmt-Method-Call]
S,D,G,ctx |- e<\overline{t}>(\overline{e}):@unit -| G
~

~ Infer
e_l @lvalue
S,D,G |- e_l: t
S,D,G |- e_r: t
---------------------------------[Type-Stmt-Assignment]
S,D,G,ctx |- e_l:=e_r:@unit -| G
~

~ Infer
S,D,G |- t().@apply(\overline{e}) : t'
----------------------------------------------[Type-Stmt-Direct-Application]
S,D,G,ctx |- t.@apply(\overline{e}):@unit -| G
~

~ Infer
S,D,G |- e:@bool
S,D,G,ctx |- s_1:res_1 -| G_1
S,D,G,ctx |- s_2:res_2 -| G_2
D |- @resmeet res_1 res_2 res
----------------------------------------------[Type-Stmt-If-Else]
S,D,G,ctx |- @if (e) s_1 @else s_2:res -| G
~

We need another judgment for typing sequences $\overline{s}$ of
statements. (Sorry about the empty sequence notation in the first
rule...)

~ Infer

---------------------------------------------------[Type-Stmts-Empty]
S,D,G,ctx |- \overline{  } :@unit -| G
~

~ Infer
S,D,G,ctx  |- s:@unit -| G'
S,D,G',ctx |- \overline{s}:res -| G'
---------------------------------------------------[Type-Stmts-List]
S,D,G,ctx |- s;\overline{s}:res -| G
~

~ Infer
S,D,G,ctx |- \overline{s}:res -| G'
---------------------------------------[Type-Stmt-Block]
S,D,G,ctx |- \{\overline{s}\}:res -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Exit]
S,D,G,@InParserState |- @exit:@returns -| G
~

~ Infer

------------------------------------------[Type-Stmt-Empty]
S,D,G,ctx |- \mathkw{;}:@unit -| G
~

~ Infer
S,D,G |- e:t
---------------------------------------------------[Type-Stmt-Return-Value]
S,D,G,@InFunction t |- @return e:@returns t -| G
~

~ Infer

--------------------------------------------------------[Type-Stmt-Return-Void]
S,D,G,@InFunction @void |- @return:@returns @void -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Control]
S,D,G,@InControl |- @return:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Action]
S,D,G,@InAction |- @return:@returns -| G
~

We define a typing judgment for cases of switch statements which has
the form $\mathkw{case\_ok}_t case$.
~ Infer
S,D,G |- case\_lbl:t
S,D,G,@InControl |- blk:res -| G'
-----------------------------------------------------[Type-Case-Block]
S,D,G |- \mathkw{case\_ok}_\tau case\_lbl\text{:}blk
~

~ Infer
S,D,G |- case\_lbl:t
----------------------------------------------------[Type-Case-Fallthrough]
S,D,G |- \mathkw{case\_ok}_\tau case\_lbl\text{:}
~

There isn't a real reason to track signals in controls, seeing as
controls only return void and there's no way for an apply block that
typechecks in all other respects to fail to not return a value. Seeing
as switch statements can only appear in controls, this rule just
assigns them the signal $\bot$ to avoid having to track signals in
each case and across fallthrough cases.
~ Infer
S,D,G |- e:@enum X \{\overline{m}\}
S,D,G |- \overline{\mathkw{case\_ok}_X case}
---------------------------------------------------------------------[Type-Stmt-Switch]
S,D,G,@InControl |- @switch (e) \{\overline{case}\}:unit -| G
~

TODO: DeclarationStatements don't need to exist, see
https://github.com/cornell-netlab/petr4/issues/5

~ Infer
S,D,G |- decl -| S',D',G'.
\text{decl is const, instantiation, or var}
---------------------------------------------------[Type-Stmt-Declaration-Statement]
S,D,G,ctx |- decl:@unit -| G'
~

## Parser state typing

Parser states need their own typing judgment to deal with
state-machine control flow. It has the form $S,D,G,K\vdash{}state$,
where K is a list of names of states used to check that the parser's
transitions make sense. It is defined by two rules, which use another
judgement $\mathkw{state\_expr\_ok}$.

~ Infer
S,D,G,K |- \mathkw{state\_expr\_ok} state\_expr
------------------------------------------------------[Type-State-Transition]
S,D,G,K |- @state x \{ ; @transition state\_expr \}
~

~ Infer
S,D,G |- s0:@unit -| G'
S,D,G' |- \{ \overline{s}; @transition state\_expr \}
-------------------------------------------------------[Type-State-Statement-Unit]
S,D,G,K |- @state x \{ s0; \overline{s}; @transition state\_expr \}
~

~ Infer
S,D,G |- s0:@rejects -| G'
S,D,G' |- \{ \overline{s}; @transition state\_expr \}
----------------------------------------------------[Type-State-Statement-Rejects]
S,D,G,K |- @state x \{ s0; \overline{s}; @transition state\_expr \}
~

The $\mathkw{state\_expr\_ok}$ judgment is defined by the following rules.
~ Infer
x\in{}K
-----------------------------------------------[State-Expr-OK-Direct]
G,K |- \mathkw{state\_expr\_ok} x
~

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{\mathkw{match\_ok} t match}
\overline{x\in{}K}
-----------------------------------------------[State-Expr-OK-Select]
S,D,G,K |- \mathkw{state\_expr\_ok} @select (\overline{e}) \{ \overline{\overline{match}:x} \}
~

TODO: Should matches be a separate kind of expression, or should we fold them into one type?
~ Infer
S,D,G |- e : @set t_m
t_m = t
----------------------------------------[Match-OK-Expr]
S,D,G |- \mathkw{match\_ok} t e
~

~ Infer

-------------------------------------------[Match-OK-DontCare]
S,D,G |- \mathkw{match\_ok} t \mathkw{\_}
~

## Parameter typing
~ Judgment
D,ctx |- (x:t,d) @param
~
TODO based on `validate_param` in the implementation. Will need a few
aux judgments.

## Table property typing
Table typechecking uses key types $K::=\{\overline{t}\}$ and
action contexts $A::=\{\overline{x(e)}\}$. The action context supports
membership tests $x(e)\in{}A$, which use strict syntactic equality.

### Table const entry typing
~ Judgment { #type-table }
S,D,G;K,A |- \overline{e_m}:x_a(\overline{e_r},\overline{e}) @entryok
~

~ Infer { #type-table-entry }
S,D,G |- \overline{e_m}:@set<@tuple<t_k>>
x(\overline{e_r}) \in A
S |- e\Downarrow_{CTK}
S,D,G |- x(\overline{e_r},\overline{e}):@void
-----------------------------------------------------------------------------------[Type-Table-Entry]
S,D,G;K,A |- \overline{e_m}:x(\overline{e_r},\overline{e}) @entryok
~

### Table property typing judgment
~ Judgment
S,D,G;K,A |- prop -| K',A'
~

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{x:\mathkw{match\_kind}}
------------------------------------------------------------------------------[Type-Prop-Keys]
S,D,G;\{\},\{\} |- @key=\{\overline{e:x}\} -| \{\overline{t}\},\{\}
~

~Infer
S,D,G |- x_a:@action(\overline{x_r:t_r,d_0},\overline{x:t}):@void
S,D,G |- \overline{e:t_r}
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Actions]
S,D,G;K,\{\} |- @actions=\{\overline{x_a(\overline{e})}\} -| K,\{\overline{x_a(\overline{e}):@action(\overline{x:t}):@void}\}
~

~ Infer
S,D,G;K,A |- \overline{entry} @entryok
---------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Entries]
S,D,G;K,A |- @const @entries = \{\overline{entry}\} -| K,A
~

~ Infer
x(\overline{e_r}) \in A
S |- \overline{e}\Downarrow_{CTK}
---------------------------------------------------[Type-Prop-Default]
S,D,G,K,A |- \mathkw{default\_action}=x(\overline{e_r},\overline{e}) -| K,A
~

## Declaration Typing
~ Judgment
S,D,G,ctx |- decl -| S',D',G'
~

~ Infer
S,D,G,@InConstant |- e:t
S |- e~>v
S,D |- t~>t'
------------------------------------------------[Type-Decl-Const]
S,D,G,ctx |- @const t x:=e -| S[x=v],D,G[x:t']
~

~ Infer
S,D,G,ctx |- t(\overline{e}) : t_{inst}
-------------------------------------------------------[Type-Decl-Instantiation]
S,D,G,ctx |- t x(\overline{e}) -| S,D,G[x:t_{inst}]
~

The function $\mathkw{names}(s_1, s_2, \dots)$ takes a list of states
and returns a list of their names. The judgment $\mathkw{nodups}(K)$
checks that $K$ contains no duplicated names.
~ Infer
K = @names(\overline{state}),@accept,@reject
@nodups(K)
@start \in K
S,D |- \overline{t_r~>t_r'}
S,D |- \overline{t~>t'}
D,@constructor @parser |- \overline{x:t'} @param
D,@runtime @ctx |- \overline{x_r:t_r',d} @param
S,D,G[\overline{x:t}][\overline{x_r:t_r}],@InParserLocals |- \overline{decl} -| S',D',G'
S',D',G',K |- \overline{state}
---------------------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Parser]
S,D,G,ctx |- @parser X(\overline{x_r:t_r,d})(\overline{x:t})\{\overline{decl} \overline{state}\} -| S,D,G[X:@constructor(\overline{x:t}):@parser(\overline{x_r:t_r})]
~

~ Infer
S,D |- \overline{t_r~>t_r'}
S,D |- \overline{t~>t'}
D,@constructor @control |- \overline{x:t'} @param
D,@runtime @control |- \overline{x_r:t_r',d} @param
S,D,G[\overline{x:t'}][\overline{x_r:t_r'}] |- \overline{decl} -| S',D',G'
S',D',G',@InFunction @void |- blk:@returns @void -| G''
----------------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Control]
S,D,G,ctx |- @control X(\overline{x:t,d})(\overline{x:t}) \{\overline{decl} @apply blk\} -| S,D,G[X:@constructor(\overline{x:t}):@control(\overline{x_r:t_r,d})]
~

~ Infer
S,D[\overline{X=X}] |- \overline{t~>t'}
S,D[\overline{X=X}] |- t_{ret}~>t_{ret}'
D[\overline{X=X}],@runtime [ctx] |- \overline{x:t',d} @param
S,D[\overline{X=X}],G[\overline{x:t'}],@InFunction t_{ret}' |- blk:@returns t_{ret}' -| G_{blk}
--------------------------------------------------------------------------------------------------------------------[Type-Decl-Function]
S,D,G,ctx |- @function t_{ret} x<\overline{X}>(\overline{x:t,d}) blk -| S,D,G[x:@function<\overline{X}>(\overline{x:t'}):t_{ret}']
~

~ Infer
S,D[\overline{X=X}] |- \overline{t_r'~>t_r'}
S,D[\overline{X=X}] |- \overline{t'~>t'}
D[\overline{X=X}],@runtime @action |- \overline{x_r:t_r',d} @param
D[\overline{X=X}],@runtime @action |- \overline{x:t',d} @param
S,D[\overline{X=X}],G[\overline{x_r:t_r'}][\overline{x:t'}],@InAction |- blk:@returns @void -| G_{blk}
-----------------------------------------------------------------------------------------------------------------------------[Type-Decl-Action]
S,D,G,ctx |- @action x (\overline{x_r:t_r,d_0},\overline{x:t}) blk -| S,D,G[x:@action(\overline{x_r:t_r',d_0}, \overline{x:t'}):@void]
~

~ Infer
S,D[\overline{X=X}] |- \overline{t~>t'}
S,D[\overline{X=X}] |- \overline{t_{ret}~>t_{ret}'}
D[\overline{X=X}],@runtime @extern |- \overline{x_r:t_r',d} @param
-----------------------------------------------------------------------------------------------------------------------------[Type-Decl-Extern-Function]
S,D,G,ctx |- \mathkw{extern\ function} t_{ret} x<\overline{X}>(\overline{x:t,d}) blk -| S,D,G[x:@function<\overline{X}>(\overline{x:t',d}):t_{ret}']
~

~ Infer
S,D |- t~>t'
---------------------------------[Type-Decl-Variable]
S,D,G,ctx |- t x -| S,D,G[x:t']
~

~ Infer
S,D |- t~>t'
S,D,G |- e:t'
--------------------------------[Type-Decl-Variable-Initialized]
S,D,G,ctx |- t x:=e -| S,D,G[x:t']
~


~ Infer
S,D,G,\{\},\{\} |- \overline{prop} -| K,\{\overline{x_a(\overline{e})}\}
X_{acts},X_{ret} \text{fresh}
t_{acts}=@enum X_{acts} \{\overline{x_a}\}
t_{ret}=@struct \{\mathkw{hit}:@bool; \mathkw{action\_run}:t_{acts}\}
----------------------------------------------------------------------------------------------------------------------[Type-Decl-Table]
S,D,G,ctx |- @table x \{\overline{prop}\} -| S,D[X_{acts}=t_{acts},X_{ret}=t_{ret}],G[x:@table t_{ret}]
~

~ Infer
S,D |- \overline{t}~>\overline{t'}
-----------------------------------------------------------------------------------[Type-Decl-Header]
S,D,G |- @header X \{\overline{x:t}\} -| S,D[X=@header \{\overline{x:t'}\}],G
~

~ Infer
S,D |- \overline{t}~>\overline{t'}
------------------------------------------------------------------------------------[Type-Decl-Header-Union]
S,D,G |- \mathkw{header\ union} X \{\overline{x:t} \} -| S,D[X=@header @union \{\overline{x:t'}\}],G
~

~ Infer
S,D |- \overline{t}~>\overline{t'}
-----------------------------------------------------------------------------------[Type-Decl-Struct]
S,D,G |- @struct X \{\overline{x:t}\} -| S,D[X=@struct \{\overline{x:t'}\}],G
~

~ Infer
\overline{@error.x\notin{}G}
-----------------------------------------------------------[Type-Decl-Error]
S,D,G |- @error \{\overline{x}\} -| S,D,G[\overline{@error.x:@error}]
~

~ Infer
\overline{.x\notin{}G}
---------------------------------------------------------------------------[Type-Decl-Match-Kind]
S,D,G |- \mathkw{match\_kind} \{\overline{x}\} -| S,D,G[\overline{.x:\mathkw{match\_kind}}]
~

~ Infer
S,D |- t~>t'
S,D,G |- \overline{e:t'}
S |- \overline{e}\Downarrow_{CTK}\overline{v}
-------------------------------------------------------------------------------------------------[Type-Decl-Enum]
S,D,G |- @enum t X \{\overline{x=e}\} -| S[\overline{X.x=v}],D[X=@enum t X \{\overline{x}\}],G
~

~ Infer
S,D |- @enum X \{\overline{x}\}~>t_X
---------------------------------------------------[Type-Decl-Serializable-Enum]
S,D,G |- @enum X \{ \overline{x} \} -| S,D[X=t_X],G
~

~ Infer
\forall{}ctor_i=X(\overline{x:t}). {t_{ctor}}_i = @constructor<\overline{X}>(\overline{x_i:t_i}) : t_{extern}
t_{extern} = @extern X \{ \overline{method} \}
---------------------------------------------------[Type-Decl-Extern-Object]
S,D,G |- @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \} -| S,D,G[\overline{X:t_{ctor}}]
~

~ Infer
S,D |- t~>t'
-------------------------------------[Type-Decl-TypeDef]
S,D,G |- @typedef t X -| S,D[X=t'],G
~

~ Infer
S,D |- t~>t'
-----------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @newtype t X -| S,D[X=@newtype t' X],G
~

~ Infer
S,D[\overline{X=X}] |- t~>t'
S,D[\overline{X=X}],@runtime @control |- \overline{x:t',d} @param
--------------------------------------------------------------------------------[Type-Decl-Control-Type]
S,D,G |- @control X<\overline{X}>(\overline{x:t,d}) -| S,D[X=@control<\overline{X}>(\overline{x:t,d}),G
~

~ Infer
S,D[\overline{X=X}] |- t~>t'
S,D[\overline{X=X}],@runtime @parser |- \overline{x:t',d} @param
---------------------------------------------------------------------------------[Type-Decl-Parser-Type]
S,D,G |- @parser X<\overline{X}>(\overline{x:t,d}) -| S,D[X=@parser<\overline{X}>(\overline{x:t,d}),G
~

~ Infer
S,D[\overline{X=X}] |- t~>t'
S,D[\overline{X=X}],@constructor @package |- \overline{x:t'} @param
--------------------------------------------------------------------------------[Type-Decl-Package-Type]
S,D,G |- @package X<\overline{X}>(\overline{x:t}) -| S,D[X=@package<\overline{X}>(\overline{x:t}),G
~

## Typing of Programs
Programs are checked by a judgment of the form
~ MathPre
S,D,G |- P0 -| S',D',G'.
~
Complete programs are checked by giving empty contexts on the left.

The judgment only needs two rules.

~ Infer

--------------------------[]
S,D,G |- [] -| S,D,G
~

~ Infer
S,D,G |- decl -| S',D',G'
S',D',G' |- P0 -| S'',D'',G''
------------------------------------[]
S,D,G |- decl, P0 -| S'',D'',G''
~

# Dynamic Semantics { #sec-dynamic }

## Evaluation Environment and State
All evaluation rules include

1. $\xi$, an evaluation environment
2. $\sigma$, for maintaining state

$\xi ::= P, E, \Delta, \upsilon$

$P$ is a declaration context representing the program seen so far mapping type names to declarations.
$E$ is a value context mapping names to locations $\ell$ in the state $\sigma$.
$\Delta$ is the same as defined in the typing contexts.
$\upsilon$ is a string namespace used for control plane names.

~ MathPre
\rho ::= \rho, X=decl | []

P ::= P, \rho{} | []

\epsilon ::= \epsilon, x=\ell | []

E ::= E, \epsilon{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []
~

$\sigma ::= (packet, (\overline{name,object}))$ where $object$ is defined by the target.
$packet$ is used to maintain the state of the packet and $(\overline{name,object})$ is for stateful objects maintained by externs.

$\mathkw{push} \xi$ pushes an empty first-level scope onto each context in $\xi$.
$\mathkw{pop} \xi$ pops the first-level scope off each context in $\xi$ if one exists.
$\mathkw{first\_lvl} \xi$ is the first-level scope of each context in $\xi$ if one exists.

$\xi[z/x]$ is syntactic sugar for $P[z/x]$, $E[z/x]$, or $\Delta[z/x]$ depending on whether
$z$ is a declaration, value, or type, respectively. Similarly $\xi(x) = z$ is syntactic sugar
for $P(x)$, $E(x)$, or $\Delta(x)$ depending on whether $z$ is a declaration, location, or type, respectively.
$\xi[\overline{\ell}/\overline{name}]$ means the bindings $(name_i, \ell_i)$
are inserted into $\xi$ in the order they appear in $(\overline{name,\ell_i})$.

$\mathkw{set\_namespace} \xi x$ is $\xi$ with $\upsilon$ set to $x$ and $\mathkw{namespace} \xi$ is $\upsilon$.
Since $\upsilon$ is a string, the string concatenation operator ^ is used in places.

## Control flow
Signals are threaded through expression and statement evaluation.
Unless otherwise stated, a signal that is not $\mathkw{sig\_continue}$ will result in
a no-op that does not change $\xi$ or $\sigma$ and propagates the signal. In cases
where a value is needed, it will be $\mathkw{None}$ if the input signal is not $\mathkw{sig\_continue}$.

<!--
~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig', v>
sig = \mathkw{sig\_continue}
----------------------------------------------------------------------------------
<\xi, \sigma, sig, e> \Downarrow_E <\xi', \sigma', sig', v>
~

~ Infer
sig \neq \mathkw{sig\_continue}
----------------------------------------------------------------------------------
<\xi, \sigma, sig, e> \Downarrow_E <\xi, \sigma, sig, @None>
~
-->

## Evaluation Helper Rules

### Memory Allocation and Dereferencing

$ \mathkw{new} \, \xi \, \sigma \, x \, v $ allocates memory for value $v$ and returns an updated state and environment.

~MathPre
@new \, \xi \, \sigma \, x \, v = \xi', \sigma'
\text{where}
\ell \text{ is a fresh location in memory}
\sigma' = \sigma[v / \ell]
\xi' = \xi[ \ell / x ]
~

$(\sigma \circ \xi)(x)$ finds the value associated with name $x$.

### Sequence Evaluation
Evaluating sequences such as $\overline{e}$ implies the evaluation  is performed
left-to-right and outputs such as $\xi$, $\sigma$, and $sig$ are threaded through.

### Numeric Value Evaluation
~ MathPre
\mathkw{extract\_num} v = \begin{cases} a & v = a
a & v = a_u^n
a & v = a_s^n
\end{cases}
~

### Bitslice Evaluation
$\mathkw{bitslice} n_1 n_2 n_3$ is the decimal value obtained from interpreting $n_1$ in its binary representation and
converting bits $n_2...n_3$ inclusive to decimal. Bit $n_2$ is more significant than bit $n_3$.

### Copy-In/Copy-Out
~ MathPre
@copyin \, \xi_{closure} \, \sigma \, (x:t,d) \, v = \begin{cases} \xi_{closure},\sigma & d = @out
@new \, \xi_{closure} \, \sigma \, x \, v & otherwise
\end{cases}
~

~ MathPre
@copyout \, \xi_{call} \, \xi_{closure} \, \sigma \, (x:t,d) \, e = \begin{cases} \sigma & d = @in
\sigma & d = @none \land t \neq @extern ...
\sigma' & otherwise, \text{where} \mathkw{lv\_of\_expr} \, \xi_{call} \, \sigma \, e = (\_, \_, \_, lv_o) \land \mathkw{assign\_lv} \, \xi_{call} \, lv_o \, (\sigma \circ \xi_{closure})(x) = (\sigma', \_)
\end{cases}
~

### Match Switch Case
~ MathPre
\mathkw{match\_switch\_case} case_1...case_n name = \begin{cases} None & \forall i \text{ where } 1 \leq i \leq n, name \neq case\_lbl_i \land case\_lbl_i \neq \texttt{default}
None & case_i = case\_lbl_i :\ \land \nexists case\_lbl_j : blk_j, i \lt j
Some\ blk_i & case_i = case\_lbl_i : blk_i \land name = case\_lbl_i
Some\ blk_j & case_i = case\_lbl_i :\ \land case_j = case\_lbl_j : blk_j \land name = case\_lbl_i \land \nexists case\_lbl_h : blk_h, i \lt h \lt j
\end{cases}
~

### Match Sets
~ MathPre
\mathkw{width\_of\_val} v = \begin{cases} w & v = n_u^w
w & v = n_s^w
n1 & v = (n1, {n2}_u^w)
0 & v = @None
1 & v = b
\mathkw{width\_of\_val} v1 +...+\mathkw{width\_of\_val} v_n & v = @struct \{\overline{(name,v)}\}
\mathkw{width\_of\_val} v1 +...+\mathkw{width\_of\_val} v_n & v = @header b \{\overline{(name,v)}\}
\mathkw{width\_of\_val} v' & v = (name1.name2, v')
\end{cases}

\mathkw{set\_of\_matches} \xi \sigma \overline{match} \overline{w} = \begin{cases} (\xi, \sigma, @universal) & \overline{match} = (\_)
(\xi', \sigma', @singleton w (\mathkw{extract\_num} v)) & \overline{match} = (e) \land \overline{w} = w \land <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
(\xi'', \sigma'', \mathkw{value\_set} \overline{matches} \overline{set}_2) & \overline{match} = (e) \land <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{value\_set} \overline{matches} \overline{set}_1> \land \mathkw{set\_of\_matches} \xi' \sigma' \overline{matches} = (\xi'', \sigma'', \overline{set}_2)
(\xi', \sigma', set) & \overline{match} = (e) \land <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, set> \land set \neq \mathkw{value\_set} ...
(\xi^n, \sigma^n, @product (set_1,...,set_n)) & \overline{match} = (match_1,...,match_n) \land \mathkw{set\_of\_matches} \xi \sigma (match_1) (w_1) = (\xi', \sigma', set_1) \land ... \land \mathkw{set\_of\_matches} \xi^{n-1} \sigma^{n-1} (match_n) (w_n) = (\xi^n, \sigma^n, set_n)
\end{cases}


\mathkw{match\_set} \overline{v} set = \begin{cases} true & set = @universal
true & set = @singleton w v_1 \land \overline{v} = (v_2) \land v_1 = \mathkw{extract\_num} v_2
false & set = @singleton w v_1 \land \overline{v} = (v_2) \land v_1 \neq \mathkw{extract\_num} v_2
true & set = v_1 \texttt{\&\&\&} v_2 \land \overline{v} = (v_3) \land v1 \& v_2 = v_3 \& v_2
false & set = v_1 \texttt{\&\&\&} v_2 \land \overline{v} = (v_3) \land v_1 \& v_2 \neq v_3 \& v_2
true & set = v_1 .. v_2 \land \overline{v} = (v_3) \land v_1 \leq v_3 \leq v_2
false & set = v_1 .. v_2 \land \overline{v} = (v_3) \land (v_3 \lt v_1 \lor v_3 \gt v_2)
\mathkw{match\_set} (v_1) set_1 \&\& ... \&\& \mathkw{match\_set} (v_n) set_n & set = @product (set_1,...,set_n) \land \overline{v} = (v_1,...,v_n)
\mathkw{match\_set} (v_1) set_1 || ... || \mathkw{match\_set} (v_n) set_n & set = \mathkw{value\_set} \overline{matches} (set_1,...,set_n) \land \overline{v} = (v_1,...,v_n)
\mathkw{match\_set} \overline{v} (v_1 \texttt{\&\&\&} v_2) & set = @lpm w v_1 v_2
\end{cases}
~

### Parser State machine
~ MathPre
\mathkw{transition\_select} \xi \sigma (@select (\overline{e}) \{\overline{matches:x}\}) = \begin{cases} (\xi'', \sigma'', None) & <\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}> \land \mathkw{set\_of\_matches} \xi' \sigma' \overline{matches} (\mathkw{width\_of\_val} \overline{v}) = (\xi'', \sigma'', \overline{set}) \land \forall set_i \in \overline{set}, \mathkw{match\_set} \overline{v} set_i = false
(\xi'', \sigma'', Some\ x_i) & <\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}> \land \mathkw{set\_of\_matches} \xi' \sigma' \overline{matches} (\mathkw{width\_of\_val} \overline{v}) = (\xi'', \sigma'', \overline{set}) \land \mathkw{match\_set} \overline{v} set_i = true \land \forall j \lt i, \mathkw{match\_set} \overline{v} set_j = false
\end{cases}


\mathkw{parser\_state\_machine} \xi \sigma \overline{state} (@state x \{\overline{s}; @transition state\_expr\}) = \begin{cases} (\xi', \sigma', \mathkw{sig\_continue}) & state\_expr = ``accept" \land <\xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
(\xi', \sigma', \mathkw{sig\_reject} ``NoError") & state\_expr = ``reject" \land <\xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
\mathkw{parser\_state\_machine} \xi' \sigma' \overline{state} (@state x_{next} \{...\}) & @state x_{next} \{...\} \in \overline{state} \land state\_expr = x_{next} \land x_{next} \neq ``accept" \land x_{next} \neq ``reject" \land <\xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
\mathkw{parser\_state\_machine} \xi'' \sigma'' \overline{state} (@state x \{\overline{s}; @transition x_{next}\}) & state\_expr = @select (\overline{e}) \{\overline{matches:x}\} \land <\xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}> \land \mathkw{transition\_select} \xi' \sigma' state\_expr = (\xi'', \sigma'', Some\ x_{next})
(\xi', \sigma', \mathkw{sig\_reject} ``NoMatch") & state\_expr = @select (\overline{e}) \{\overline{matches:x}\} \land <\xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}> \land \mathkw{transition\_select} \xi' \sigma' state\_expr = (\xi'', \sigma'', None)
\end{cases}
~

### Default Action
~ MathPre
@default \overline{prop} = \begin{cases} x(\overline{e}) & \mathkw{default\_action} = x \in \overline{prop}
@NoAction() & \mathkw{default\_action} = x \not\in \overline{prop}
\end{cases}
~

### LPM Entries
$\mathkw{sort\_lpm}\ \overline{set}\ n$ is $\overline{set}$ with elements up
until the first occurrence of $\mathkw{universal}$, if one exists, sorted in descending order by $w$.
Elements can be of the form $\mathkw{universal}$, $\mathkw{lpm}\ w\ v_1\ v_2$, or
$\mathkw{product}\ \overline{set}'$. If an element $set_i = \mathkw{product}\ \overline{set}'$ then it
is replaced with $set'_n$ where $set'_n = \mathkw{lpm}\ w\ v_1\ v_2$ or $set'_n = \mathkw{universal}$.

$\mathkw{bits}\ n$ is the number of bits not masked by $n$.

~ MathPre
\mathkw{lpm\_set} set = \begin{cases} @universal & set = @universal
@lpm w v_1 v_2 & set = @lpm w v_1 v_2
@lpm w v_u^w (\texttt{\textasciitilde} v)_u^w & set = @singleton w v
@lpm (@bits (\mathkw{extract\_num} v_2)) v_1 v_2 & set = v1 \texttt{\&\&\&} v_2
@product (\mathkw{lpm\_set} \overline{set}) & set = @product \overline{set}
\end{cases}

\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = \begin{cases} (\mathkw{sort\_lpm} (\mathkw{lpm\_set} \overline{set}) n, \overline{v}) & \overline{x} = (@lpm)
(\mathkw{sort\_lpm} (\mathkw{lpm\_set} \overline{set}') i, (v_i)) & \overline{x} = (...,x_i = @lpm,...) \land \forall set \in \overline{set} \text{ where } \mathkw{match\_set} \overline{v} set = true, set \in \overline{set}'
(\overline{set}, \overline{v}) & @lpm \not\in \overline{x}
\end{cases}
~

### Initial Value of Type
~ MathPre
\mathkw{init\_val} \xi t_1 = \begin{cases} false & t_1 = @bool
``" & t_1 = @string
0 & t_1 = @int
0^w_u & t_1 = @bit<w>
0^w_s & t_1 = @int<w>
(w, 0^0_u) & t_1 = @varbit<w>
((\mathkw{init\_val} \xi t)^a, a, 0) & t_1 = t_2[a]
(\mathkw{init\_val} \xi \overline{t}) & t_1 = @tuple<\overline{t}>
(\mathkw{init\_val} \xi \overline{t}) & t_1 = \{ \overline{t} \}
\{\overline{f=\mathkw{init\_val} \xi t}\} & t_1 = \{ \overline{f:t} \}
@universal & t_1 = @set<t>
@error.@NoError & t_1 = @error
@matchkind @exact & t_1 = \mathkw{match\_kind}
\mathkw{init\_val} \xi (\xi(X)) & t_1 = X
\mathkw{init\_val} \xi (\xi(.X)) & t_1 = .X
\mathkw{init\_val} \xi t_2 & t_1 = @newtype t_2 X
@None & t_1 = @void
@header false \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = @header \{ \overline{f:t} \}
\mathkw{header\ union} \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = \mathkw{header\ union} \{ \overline{f:t} \}
@struct \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = @struct \{ \overline{f:t} \}
X.x_1 & t_1 = @enum X \{ \overline{x} \}
(X.x_1, \mathkw{init\_val} \xi t_2)& t_1 = @enum t_2 X \{ \overline{x=v} \}
\end{cases}
~
$(\mathkw{init\_val} \xi t)^n$ is short for $n$ occurrences of $\mathkw{init\_val} \xi t$.

### Name of Type
~ MathPre
@nametype t_1 = \begin{cases} X & t_1 = X
X & t_1 = @newtype t_2 X
X & t_1 = @enum X \{\overline{x}\}
@nametype t_2 & t_1 = t_2<\overline{t}>
\end{cases}
~

## LValue operations
~ Judgment
<\sigma,lv>\Downarrow_{read}v
~
~ Judgment
<\sigma,lv,v>\Downarrow_{write}\sigma'
~
TODO:rules. These judgments write or read (evaluate to a value) lvalues.

This judgment turns expressions into lvalues.
~ Judgment
<\xi,\sigma,e>\Downarrow_{l}<\xi,\sigma,lsig>
~
~ Infer
x\in{}@dom(\xi)
--------------------------------------------------[Eval-LValue-Var]
<\xi,\sigma,x>\Downarrow_{l}<\xi,\sigma,@go \xi(x)>
~
~ Infer
.x\in{}@dom(\xi)
----------------------------------------------------[Eval-LValue-Var-Top]
<\xi,\sigma,.x>\Downarrow_l<\xi,\sigma,@go \xi(.x)>
~
~ Infer
<\xi,\sigma,e>\Downarrow_l<\xi',\sigma',@go lv>
------------------------------------------------------[Eval-LValue-Field]
<\xi,\sigma,e.x>\Downarrow_l<\xi',\sigma',@go lv.x>
~
~ Infer
<\xi,\sigma,e>\Downarrow_l<\xi',\sigma',@stop sig>
------------------------------------------------------[Eval-LValue-Field-Fail1]
<\xi,\sigma,e.x>\Downarrow_l<\xi',\sigma',@stop sig>
~
~ Infer
<\xi,\sigma,e_1>\Downarrow_l<\xi_1,\sigma_1,@go lv>
<\xi_1,\sigma_1,e_2>\Downarrow_e<\xi_2,\sigma_2,@go n>
<\xi_2,\sigma_2,e_3>\Downarrow_e<\xi_3,\sigma_3,@go m>
-------------------------------------------------------------[Eval-LValue-Slice]
<\xi,\sigma,e_1[e_2:e_3]>\Downarrow_l<\xi_3,\sigma_3,@go lv[n:m]>
~
~ Infer
<\xi,\sigma,e_1>\Downarrow_l<\xi_1,\sigma_1,@stop sig>
----------------------------------------------------------[Eval-LValue-Slice-Fail1]
<\xi,\sigma,e_1[e_2:e_3]>\Downarrow_l<\xi_1,\sigma_1,@stop sig>
~
~ Infer
<\xi,\sigma,e_1>\Downarrow_l<\xi_1,\sigma_1,@go lv>
<\xi_1,\sigma_1,e_2>\Downarrow_e<\xi_2,\sigma_2,@stop sig>
----------------------------------------------------------[Eval-LValue-Slice-Fail2]
<\xi,\sigma,e_1[e_2:e_3]>\Downarrow_l<\xi_2,\sigma_2,@stop sig>
~
~ Infer
<\xi,\sigma,e_1>\Downarrow_l<\xi_1,\sigma_1,@go lv>
<\xi_1,\sigma_1,e_2>\Downarrow_e<\xi_2,\sigma_2,@go n>
<\xi_2,\sigma_2,e_3>\Downarrow_e<\xi_3,\sigma_3,@stop sig>
----------------------------------------------------------[Eval-LValue-Slice-Fail3]
<\xi,\sigma,e_1[e_2:e_3]>\Downarrow_l<\xi_3,\sigma_3,@stop sig>
~
~ Infer
<\xi,\sigma,e_1>\Downarrow_l<\xi_1,\sigma_1,@go lv>
<\xi_1,\sigma_1,e_2>\Downarrow_e<\xi_2,\sigma_2,@go n>
------------------------------------------------------------[Eval-LValue-Index]
<\xi,\sigma,e_1[e_2]>\Downarrow_l<\xi_2,\sigma_2,@go lv[n]>
~
~ Infer
<\xi,\sigma,e_1>\Downarrow_l<\xi_1,\sigma_1,@stop sig>
------------------------------------------------------------[Eval-LValue-Index-Fail1]
<\xi,\sigma,e_1[e_2]>\Downarrow_l<\xi_1,\sigma_1,@stop sig>
~
~ Infer
<\xi,\sigma,e_1>\Downarrow_l<\xi_1,\sigma_1,lv>
<\xi_1,\sigma_1,e_2>\Downarrow_e<\xi_2,\sigma_2,@stop sig>
------------------------------------------------------------[Eval-LValue-Index-Fail2]
<\xi,\sigma,e_1[e_2]>\Downarrow_l<\xi_2,\sigma_2,@stop sig>
~

## Expression Evaluation

Expressions are evaluated according to the following big-step relation:
~ Center
$\langle \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle$
~

### Evaluation of Constants

~ Infer

-------------------------------------------------------------------------------[Bool-True]
<\xi, \sigma, true> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, true>
~

~ Infer

-------------------------------------------------------------------------------[Bool-False]
<\xi, \sigma, false> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, false>
~

~ Infer

-------------------------------------------------------------------------------[Int-Constant]
<\xi, \sigma, a> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a>
~

~ Infer

-------------------------------------------------------------------------------[Unsigned-Int-Constant]
<\xi, \sigma, nwa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_u^n>
~

~ Infer

-------------------------------------------------------------------------------[Signed-Int-Constant]
<\xi, \sigma, nsa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_s^n>
~

~ Infer

-------------------------------------------------------------------------------[String]
<\xi, \sigma, u> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, u>
~

### Evaluation of Variables

~ Infer
<\xi,\sigma,x>\Downarrow_l<\xi_1,\sigma_1,@ok lv>
<\xi_1,\sigma_1,@ok lv>\Downarrow_{read}<\xi_2,\sigma_2,@ok v>
x\neq{}@verify
---------------------------------------------------------------------------------------------[Var]
<\xi,\sigma,x>\Downarrow_e<\xi,\sigma,@ok v>
~

~ Infer

--------------------------------------------------------------------------------------------------[Var-Verify]
<\xi, \sigma, @verify> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @extern @verify @None>
~

~ Infer
<\xi,\sigma,x>\Downarrow_l<\xi_1,\sigma_1,@ok lv>
<\xi_1,\sigma_1,@ok lv>\Downarrow_{read}<\xi_2,\sigma_2,@ok v>
x\neq{}@verify
---------------------------------------------------------------------------------------------[Var-Top]
<\xi,\sigma,x>\Downarrow_e<\xi,\sigma,@ok v>
~

### Evaluation of Accessess

~ Infer
<\xi, \sigma, e_1>\Downarrow_e<\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})>
<\xi', \sigma', e_2>\Downarrow_e<\xi'', \sigma'', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------------------------------------------------------------------[Array-Access]
<\xi, \sigma, e_1[e_2]> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_{(\mathkw{extract\_num} v) \% n_{size}}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-----------------------------------------------------------------------------------------------------------[Bitslice]
<\xi, \sigma, e[n1:n2]> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)}>
~

~ Infer
<\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
-------------------------------------------------------------------------------[List-Expression]
<\xi, \sigma, \{\overline{e}\}> \Downarrow_e <\xi', \sigma', sig, (\overline{v})>
~

~ Infer
<\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
-------------------------------------------------------------------------------[Record]
<\xi, \sigma, \{ \overline{name=e} \}> \Downarrow_e <\xi', \sigma', sig, \{ \overline{name=v} \}>
~

### Unary Operation Evaluation

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
\diamond \in \{ !, \texttt{\textasciitilde}, - \}
-------------------------------------------------------------------------------[Unary-Op]
<\xi, \sigma, \diamond e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \diamond v>
~

### Binary Operation Evaluation

~ Infer
<\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
\diamond \in \{ +, |+|, -, |-|, *, /, \%, \ll, \gg, \lt, \gt, \leq, \geq, ==, !=, \&, \hat{}, |, ++, \&\&, || \}
-------------------------------------------------------------------------------[Binary-Op]
<\xi, \sigma, e_1 \diamond e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \diamond v_2>
~

### Evaluation of Casts
~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1>
-------------------------------------------------------------------------------[Bool-Cast-True]
<\xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1>
n \neq 1
-------------------------------------------------------------------------------[Bool-Cast-False]
<\xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~

$\mathkw{of2s}(a)$ is the result of converting $a$ from two's complement while $\mathkw{to2s}(a)$ is the result of converting $a$ to two's complement.

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------------[Bit-Cast]
<\xi, \sigma, (@bit<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@of2s(\mathkw{extract\_num} v)}_u^{w}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------------------[Int-Cast]
<\xi, \sigma, (@int<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@to2s(\mathkw{extract\_num} v)}_s^{w}>
~

~ Infer
<\xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v>
-------------------------------------------------------------------------------[TypeName-Cast]
<\xi, \sigma, (X) e> \Downarrow_e <\xi', \sigma', sig, v>
~

~ Infer
<\xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v>
-------------------------------------------------------------------------------[NewType-Cast]
<\xi, \sigma, (@newtype t X) e> \Downarrow_e <\xi', \sigma', sig, v>
~

### Member Expression Evaluation

~ Infer
\xi(X_1) = @enum X_2 \{\dots,name,\dots\}
-------------------------------------------------------------------------------[Type-Member-Enum]
<\xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~

~ Infer
\xi(X_1) = @enum t X_2 \{\dots,(name, e),\dots\}
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------[Type-Member-SEnum]
<\xi, \sigma, X_1.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (X_2.name, (t) v)>
~

~ Infer

-------------------------------------------------------------------------------[Error-Member]
<\xi, \sigma, @error.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @error.name>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
-------------------------------------------------------------------------------[Struct-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}>
-------------------------------------------------------------------------------[Header-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-IsValid-Field]
<\xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-SetValid-Field]
<\xi, \sigma, e.@setValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @setValid lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-SetInvalid-Field]
<\xi, \sigma, e.@setInvalid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @setInvalid lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots,(name,v),\dots \}>
-------------------------------------------------------------------------------[Header-Union-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots \}>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-Union-IsValid-Field]
<\xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-Size-Field]
<\xi, \sigma, e.@size> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {n_{size}}_u^{32}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \lt n_{size}
-------------------------------------------------------------------------------[Array-Next-Field]
<\xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next}}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \geq n_{size}
-------------------------------------------------------------------------------[Array-Next-Field-OutOfBounds]
<\xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
1 \leq n_{next} \leq n_{size}
-------------------------------------------------------------------------------[Array-Last-Field]
<\xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next} - 1}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \gt n_{size}
-------------------------------------------------------------------------------[Array-Last-Field-OutOfBounds-High]
<\xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \lt 1
-------------------------------------------------------------------------------[Array-Last-Field-OutOfBounds-Low]
<\xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-LastIndex-Field]
<\xi, \sigma, e.@lastIndex> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (n_{next} - 1)_u^{32}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Array-PopFront-Field]
<\xi, \sigma, e.\mathkw{pop\_front}> \Downarrow_e <\xi'', \sigma'', sig, @builtin \mathkw{pop\_front} lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Array-PushFront-Field]
<\xi, \sigma, e.\mathkw{push\_front}> \Downarrow_e <\xi'', \sigma'', sig, @builtin \mathkw{push\_front} lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \{...;name=v;...\}>
--------------------------------------------------------------------------[Record-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (loc, name_{object})>
-------------------------------------------------------------------------------[Runtime-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, name_{object})>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @parser \dots>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Parser-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @control \dots>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Control-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @table \dots>
\mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Table-Field]
<\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~


### Ternary Expression Evaluation

~ Infer
<\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true>
<\xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
-------------------------------------------------------------------------------[Ternary-Op-True]
<\xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~

~ Infer
<\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false>
<\xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
-------------------------------------------------------------------------------[Ternary-Op-False]
<\xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~

### Function Call Evaluation

~ Infer
<\xi, \sigma_0, f> \Downarrow_e <\xi_1, \sigma_1, \mathkw{sig\_continue}, \xi_{closure}\otimes{}@function<X>(\overline{x:t,d}) blk>
<\xi_1, \sigma_1, \overline{e}> \Downarrow_e <\xi_2, \sigma_2, \mathkw{sig\_continue}, \overline{v}>
@copyin \, (@push \, \xi_{closure}) \, \sigma_2 \, (\overline{x:t,d}) \, \overline{v} = \xi_3,\sigma_3
<\xi_3, \sigma_3, blk> \Downarrow_s <\xi_4, \sigma_4, \mathkw{sig\_return\ v}>
@copyout \, \xi_2 \, \xi_4 \, \sigma_4 \, (\overline{x:t,d}) \, \overline{e} = \sigma_5
--------------------------------------------------------------------------------------------------------[Function-Eval]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi_2, \sigma_5, \mathkw{sig\_continue}, v>
~

~ Infer
<\xi, \sigma_0, f> \Downarrow_e <\xi_1, \sigma_1, \mathkw{sig\_continue}, \xi_{closure}\otimes{}@action(\overline{x:t,d_0},\overline{x:t}) blk
<\xi_1, \sigma_1, \overline{e}> \Downarrow_e <\xi_2, \sigma_2, \mathkw{sig\_continue}, \overline{v}>
@copyin \, (@push \, \xi_{closure}) \, \sigma_2 \, (\overline{x:t,d}) \, \overline{v} = \xi_3,\sigma_3
<\xi_3, \sigma_3, blk> \Downarrow_s <\xi_4, \sigma_4, \mathkw{sig\_return\ v}>
@copyout \, \xi_2 \, \xi_4 \, \sigma_4 \, (\overline{x:t,d}) \, \overline{e} = \sigma_5
--------------------------------------------------------------------------------------------------------[Action-Eval]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi_2, \sigma_5, \mathkw{sig\_continue}, v>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\dots\}
----------------------------------------------------------------------------------------------[isValid-Header]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, b>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = \mathkw{header\ union} \{ \dots,(name, @header true \{\dots\}), \dots\}
-------------------------------------------------------------------------------[isValid-Header-Union-True]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = \mathkw{header\ union} \{ \overline{(name, @header false \{\dots\})}\}
-------------------------------------------------------------------------------[isValid-Header-Union-False]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, false>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @setValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\overline{(name,v)}\}
\mathkw{assign\_lv} \xi' lv_o (@header true \{\overline{(name,v)}\}) = (\xi'',sig)
----------------------------------------------------------------------------------------------[setValid]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma', sig, true>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @setInvalid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\overline{(name,v)}\}
\mathkw{assign\_lv} \xi' lv_o (@header false \{\overline{(name,v)}\}) = (\xi'',sig)
----------------------------------------------------------------------------------------------[setInvalid]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma', sig, false>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin \mathkw{pop\_front} (@lvalue t[a] ...)>
<\xi', \sigma', e> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\mathkw{value\_of\_lv} \xi'' (@lvalue t[a] ...) = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi' (@lvalue t[a] ...) (v_{(\mathkw{extract\_num} v)+1},...,v_{n_size}, (\mathkw{init\_val} \xi'' t)^{\mathkw{extract\_num} v}, n_{size}, n_{next} - \mathkw{extract\_num} v) = (\xi''',sig)
--------------------------------------------------------------------------------------------------------[PopFront]
<\xi, \sigma, f<\overline{t}>(e)> \Downarrow_e <\xi''', \sigma'', \mathkw{sig\_continue}, @None>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin \mathkw{push\_front} (@lvalue t[a] ...)>
<\xi', \sigma', e> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\mathkw{value\_of\_lv} \xi'' (@lvalue t[a] ...) = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi' (@lvalue t[a] ...) ((\mathkw{init\_val} \xi'' t)^{\mathkw{extract\_num} v},v_1,...,v_{n_{size} - \mathkw{extract\_num} v}, n_{size}, n_{next} + \mathkw{extract\_num} v) = (\xi''',sig)
-------------------------------------------------------------------------------[PushFront]
<\xi, \sigma, f<\overline{t}>(e)> \Downarrow_e <\xi''', \sigma'', \mathkw{sig\_continue}, @None>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @parser (\overline{name,v}) (\overline{x:t,d}) \overline{decl} \overline{state}
<\mathkw{set\_namespace} \xi' x, \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
(@state ``start" \{...\}) \in \overline{state}
\mathkw{parser\_state\_machine} \xi'''' \sigma''' \overline{state} (@state ``start" \{...\}) = (\xi''''', \sigma'''', sig')
@copyout (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
------------------------------------------------------------------------------[Apply-Parser]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\mathkw{set\_namespace} \xi'''''' (@namespace \xi'), \sigma'''', sig', @None>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @control (\overline{name,v}) (\overline{x:t,d}) \overline{decl} blk
<\mathkw{set\_namespace} \xi' x, \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
<\xi'''', \sigma''', blk> \Downarrow_s <\xi''''', \sigma'''', sig'>
@copyout (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
------------------------------------------------------------------------------[Apply-Control]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\mathkw{set\_namespace} \xi'''''' (@namespace \xi'), \sigma'''', sig', @None>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @table name \overline{e_k:x} \overline{action\_ref} x_{default}(\overline{e}_{default}) \{ \overline{matches:x(\overline{e})} \}
<\mathkw{set\_namespace} \xi' x, \sigma', \overline{e}_k> \Downarrow_e <\xi'', \sigma'', sig ,\overline{v}>
\mathkw{set\_of\_matches} \xi'' \sigma'' \overline{matches'} (\mathkw{width\_of\_val} \overline{v}) = (\xi''', \sigma''', \overline{set})
\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = (\overline{set}',\overline{v}')
\forall i \text{where} 1 \leq i \leq n, \mathkw{match\_set} \overline{v}' set'_i = false
<\xi''', \sigma''', x_{default}(\overline{e}_{default})> \Downarrow_e <\xi'''', \sigma'''', sig', v>
----------------------------------------------------------------------------------------------------------------------------[Apply-Table-Default]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'''', \sigma'''', sig', \{(``\text{hit}",false);(``\text{action\_run}", name.x_{default})\}>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @table name \overline{e_k:x} \overline{action\_ref} x_{default}(\overline{e}_{default}) \{ \overline{matches:x(\overline{e})} \}
<\mathkw{set\_namespace} \xi' x, \sigma', \overline{e}_k> \Downarrow_e <\xi'', \sigma'', sig ,\overline{v}>
\mathkw{set\_of\_matches} \xi'' \sigma'' \overline{matches'} (\mathkw{width\_of\_val} \overline{v}) = (\xi''', \sigma''', \overline{set})
\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = (\overline{set}',\overline{v}')
\mathkw{match\_set} \overline{v} set'_i = true
\forall j \lt i, \mathkw{match\_set} \overline{v}' set'_j = false
<\xi''', \sigma''', x_i(\overline{e}_i)> \Downarrow_e <\xi'''', \sigma'''', sig', v>
------------------------------------------------------------------------------[Apply-Table]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'''', \sigma'''', sig', \{(``\text{hit}",true);(``\text{action\_run}", name.x_i)\}>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, x)>
\xi'(x) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
t name <\overline{X}>(\overline{x:t,d}) \in \overline{method}
@len \overline{x:t,d} = @len \overline{e}
<\xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\xi''', \sigma', \overline{t}, (((loc, x), @packet),(v1,t_1),...,(v_n, t_n))> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
------------------------------------------------------------------------------[Extern-Function-Some-Caller]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

$\mathkw{len}\ \overline{x}$ is defined as the number of elements in $\overline{x}$.
$\mathkw{packet}$ is a type name.
$\tau_i$ is the type of $e_i \in \overline{e}$

$\langle \xi, \sigma, \overline{t}, (\overline{v,t}) \rangle \Downarrow_{Target\_extern} \langle \xi', \sigma', sig, v \rangle$ is a relation defined by the target.

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, x)>
\xi'(x) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
@abstract t name <\overline{X}>(\overline{x:t,d}) \in \overline{method}
@len \overline{x:t,d} = @len \overline{e}
<\xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\xi''', \sigma', \overline{t}, (((loc, x), @packet),(v1,t_1),...,(v_n, t_n))> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
------------------------------------------------------------------------------[Extern-Function-Some-Caller-Abstract]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

~ Infer
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name @None>
\xi'(name) = \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})
<\xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\xi''', \sigma', \overline{t}, (\overline{v,t})> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
----------------------------------------------------------------------------------------------[Extern-Function-No-Caller]
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

### Nameless Instantiation Evaluation

~ Infer
\xi(@nametype t) = @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}
<\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t},@none) \overline{v} = \xi''
---------------------------------------------------------------------------------------[Control]
<\xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @control (\mathkw{first\_lvl} \xi'') (\overline{x:t,d}) \overline{decl} blk>
~

~ Infer
\xi(@nametype t) = @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}
<\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t},@none) \overline{v} = \xi''
-------------------------------------------------------------------------------[Parser]
<\xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @parser (\mathkw{first\_lvl} \xi'') (\overline{x:t,d}) \overline{decl} \overline{state}>
~

~ Infer
\xi(@nametype t) = @package<\overline{X}>(\overline{x:t,d})
<\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t,d}) \overline{v} = \xi''
-------------------------------------------------------------------------------[Package]
<\xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @package (\mathkw{first\_lvl} \xi'')>
~

~ Infer
\xi(@nametype t) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
(@namespace \xi, object) \in \sigma
-------------------------------------------------------------------------------[Extern-Object-Initialized]
<\xi, \sigma, t(\overline{e})> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, (@namespace \xi, X)>
~

$(\mathkw{namespace} \xi, object) \in \sigma$ means if $\sigma = (packet, (\overline{name,object}))$ then $(\mathkw{namespace} \xi, object) \in (\overline{name,object})$.

~ Infer
\xi(@nametype t) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
(@namespace \xi, object) \not\in \sigma
<\xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern (@namespace \xi) ((@namespace \xi), X)>
<\xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma'', sig, v>
-------------------------------------------------------------------------------[Extern-Object-Uninitialized]
<\xi, \sigma, t(\overline{e})> \Downarrow_e <\xi'', \sigma'', sig, v>
~

### Set Operation Evaluation

~ Infer
<\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
-------------------------------------------------------------------------------[Masks]
<\xi, \sigma, e_1 \texttt{\&\&\&} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \texttt{\&\&\&} v_2>
~

~ Infer
<\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
-------------------------------------------------------------------------------[Ranges]
<\xi, \sigma, e_1 \mathbin{..} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \mathbin{..} v_2>
~

## Statements and Block Evaluation

Statements are evaluated according to the following big-step relation:
~ Center
$<\xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig>$
~

~ Infer
<\xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------[Method-Call]
<\xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_s <\xi', \sigma', sig>
~

assignment
~ Infer
<\xi,\sigma,e_l>\Downarrow_{l}<\xi_1,\sigma_1,@ok lv>
<\xi_1, \sigma_1, e_r> \Downarrow_e <\xi_2, \sigma_2, @ok v>
@write \sigma_2 lv v\Downarrow_{w}\sigma_3
---------------------------------------------------------------------------[Assignment]
<\xi, \sigma, e_l := e_r> \Downarrow_s <\xi_2, \sigma_3, @go>
~

~ Infer
<\xi, \sigma, t()> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @parser (\overline{name,v}) (\overline{x:t,d}) \overline{decl} \overline{state}>
<\mathkw{set\_namespace} ((@namespace \xi') \char`\^ (@nametype t)) \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
(@state ``start" \{...\}) \in \overline{state}
\mathkw{parser\_state\_machine} \xi'''' \sigma''' \overline{state} (@state ``start" \{...\}) = (\xi''''', \sigma'''', sig)
@copyout (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
--------------------------------------------------------------------------------------[Direct-Application-Parser]
<\xi, \sigma, t.@apply (\overline{e})> \Downarrow_s <\mathkw{set\_namespace} (@namespace \xi') \xi'''''', \sigma'''', sig>
~

~ Infer
<\xi, \sigma, t()> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @control (\overline{name,v}) (\overline{x:t,d}) \overline{decl} blk>
<\mathkw{set\_namespace} ((@namespace \xi') \char`\^ (@nametype t)) \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
<\xi'''', \sigma''', blk> \Downarrow_s <\xi''''', \sigma'''', sig>
@copyout (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
--------------------------------------------------------------------------------------------[Direct-Application-Control]
<\xi, \sigma, t.@apply (\overline{e})> \Downarrow_s <\mathkw{set\_namespace} (@namespace \xi') \xi'''''', \sigma'''', sig>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v>
------------------------------------------------------------------------------[Conditional-Reject]
<\xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi', \sigma', \mathkw{sig\_reject\ v}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
<@push \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig>
------------------------------------------------------------------------------[If-True]
<\xi, \sigma, @if (e) s> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
------------------------------------------------------------------------------[If-False]
<\xi, \sigma, @if (e) s> \Downarrow_s  <\xi', \sigma', \mathkw{sig\_continue}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
<@push \xi', \sigma', s_1> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-True]
<\xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
<@push \xi', \sigma', s_2> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-False]
<\xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<@push \xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig>
--------------------------------------------------------------------------[Block]
<\xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi, \sigma', sig>
~

~ Infer

---------------------------------------------------------------------[Exit-Continue]
<\xi, \sigma, @exit> \Downarrow_s <\xi, \sigma, \mathkw{sig\_exit}>
~

~ Infer

---------------------------------------------[Empty]
<\xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
~

~ Infer

---------------------------------------------[Return-Void]
<\xi, \sigma, @return> \Downarrow_s <\xi, \sigma, \mathkw{sig\_return\ None}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------[Return-Value]
<\xi, \sigma, @return e> \Downarrow_s <\xi', \sigma', \mathkw{sig\_return\ v}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
\mathkw{match\_switch\_case} \overline{case} name_2 = None
---------------------------------------------------------------------------------[Switch-No-Match]
<\xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
\mathkw{match\_switch\_case} \overline{case} name_2 = Some\ blk
<@push \xi', \sigma', blk> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[Switch-Match]
<\xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\xi, \sigma, decl> \Downarrow_d <\xi', \sigma'>
--------------------------------------------------------------------[Declaration-Statement]
<\xi, \sigma, decl> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
~

## Declaration Evaluation

Declarations are evaluated according to the following big-step relation:
~ Center
$\langle \xi, \sigma, decl \rangle \Downarrow_d \langle \xi', \sigma' \rangle$
~

~ Infer

-------------------------------------------[Constant-Decl]
<\xi, \sigma, @const t x:=v> \Downarrow_d <@new \, \xi \, \sigma \, x \, v>
~

~ Infer
<\mathkw{set\_namespace} ((@namespace \xi) \char`\^ x) \xi, \sigma, t(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------------------------[Instantiation-Decl]
<\xi, \sigma, t x(\overline{e})> \Downarrow_d <@new \, (\mathkw{set\_namespace} (@namespace \xi) \xi') \, \sigma' \, x \, v>
~

~ Infer

-------------------------------------------[Parser-Decl]
<\xi, \sigma, @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}> \Downarrow_d <\xi[@parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Control-Decl]
<\xi, \sigma, @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}> \Downarrow_d <\xi[@control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}/X], \sigma>
~

~ Infer
@new \, \xi \, \sigma \, x \, (\xi\otimes{}@function(\overline{x:t,d}) blk) = \xi', \sigma'
--------------------------------------------------------------------------------------------------------------------------------------------[Function-Decl]
<\xi, \sigma, @function t x<\overline{X}>(\overline{x:t,d}) blk> \Downarrow_d <\xi'[ @function t x<\overline{X}>(\overline{x:t,d}) blk/x], \sigma'>
~

~ Infer
@new \, \xi \, \sigma \, x \, (@extern x @None) = \xi',\sigma'
---------------------------------------------------------------[Extern-Function-Decl]
<\xi, \sigma, \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})> \Downarrow_d <(\xi'[\mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})/x]), \sigma'>
~

~ Infer

-------------------------------------------[Variable-Decl]
<\xi, \sigma, t x> \Downarrow_d <@new \, \xi \, \sigma \, x \, (\mathkw{init\_val} \xi t)>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------------[Variable-Initialized-Decl-Success]
<\xi, \sigma, t x := e> \Downarrow_d <@new \, \xi' \, \sigma' \, x \, v>
~

~ Infer
<\xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig, v>
sig \neq \mathkw{sig\_continue}
-------------------------------------------[Variable-Initialized-Decl-Fail]
<\xi, \sigma, t x := e> \Downarrow_d <@new \, \xi' \, \sigma' \, x \, (\mathkw{init\_val} \xi t)>
~

~Infer
<\xi[t/x], \sigma, e> \Downarrow <\xi', \sigma', sig\_continue, v>
------------------------------------------------------------------------------------------------[Value-Set-Decl-Success]
<\xi, \sigma, \mathkw{value\_set}<t>(e) x> \Downarrow <@new \, \xi' \, \sigma' \, x \, v>
~

~Infer
<\xi[t/x], \sigma, e> \Downarrow <\xi', \sigma', sig, v>
sig \neq \mathkw{sig\_continue}
--------------------------------------------------------------------------[Value-Set-Decl-Fail]
<\xi, \sigma, \mathkw{value\_set}<t>(e) x> \Downarrow <\xi, \sigma>
~

~ Infer
@new \, \xi \, \sigma \, x \, (\xi\otimes{}@action(\overline{x:t,d_0},\overline{x:t}) blk) = \xi',\sigma'
------------------------------------------------------------------------------------------------------------[Action-Decl]
<\xi, \sigma, @action x (\overline{x:t,d_0},\overline{x:t}) blk> \Downarrow_d <\xi'[@action x (\overline{x:t,d_0},\overline{x:t}) blk/x], \sigma'>
~

~ Infer
\mathkw{const\ entries} = \{ \overline{matches:action\_ref} \} \in \overline{prop}
\{ \overline{matches:action\_ref} \} \neq \{\}
@key = \{ \overline{e:x} \} \in \overline{prop}
@actions = \{ \overline{action\_ref} \} \in \overline{prop}
--------------------------------------------------------[Table-Decl-Constant-Entries]
<\xi, \sigma, @table x \{ \overline{prop} \}> \Downarrow_d <@new \, (\xi[@table x \{ \overline{prop} \}/x]) \, \sigma \, x \, (@table x \overline{e} \overline{action\_ref} (@default \overline{prop}) \{ \overline{matches:action\_ref} \})>
~

~ Infer
\mathkw{const\ entries} = \{\} \in \overline{prop}
@key = \{ \overline{e:x} \} \in \overline{prop}
@actions = \{ \overline{action\_ref} \} \in \overline{prop}
--------------------------------------------------------[Table-Decl-Control-Plane-Entries]
<(\{ \overline{matches:action\_ref} \}, \overline{set}), \xi, \sigma, @table x \{ \overline{prop} \}> \Downarrow_d <@new \, (\xi[@table x \{ \overline{prop} \}/x]) \, \sigma \, x \, (@table x \overline{e} \overline{action\_ref} (@default \overline{prop}) \{ \overline{matches:action\_ref} \})>
~

~ Infer

-------------------------------------------[Header-Decl]
<\xi, \sigma, @header X \{ \overline{x:t} \}> \Downarrow_d <\xi[@header X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Header-Union-Decl]
<\xi, \sigma, \mathkw{header\ union} X \{ \overline{x:t} \}> \Downarrow_d <\xi[\mathkw{header\ union} X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Struct-Decl]
<\xi, \sigma, @struct X \{ \overline{x:t} \}> \Downarrow_d <\xi[@struct X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Error-Decl]
<\xi, \sigma, @error \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
~

~ Infer

-------------------------------------------[Matchkind-Decl]
<\xi, \sigma, \mathkw{match\_kind} \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
~

~ Infer

-------------------------------------------[Enum-Decl]
<\xi, \sigma, @enum X \{ \overline{x} \}> \Downarrow_d <\xi[@enum X \{ \overline{x} \}/X], \sigma>
~

~ Infer

-------------------------------------------[SEnum-Decl]
<\xi, \sigma, @enum t X \{ \overline{x=e} \}> \Downarrow_d <\xi[@enum t X \{ \overline{x=e} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Extern-Object-Decl]
<\xi, \sigma, @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}> \Downarrow_d <\xi[@extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Type-Def-Decl]
<\xi, \sigma, @typedef t X> \Downarrow_d <\xi[@typedef t X/X], \sigma>
~

~ Infer

-------------------------------------------[New-Type-Decl]
<\xi, \sigma, @type t X> \Downarrow_d <\xi[@type t X/X], \sigma>
~

~ Infer

-------------------------------------------[Control-Type-Decl]
<\xi, \sigma, @control X<\overline{X}>(\overline{x:t,d})> \Downarrow_d <\xi[@control X<\overline{X}>(\overline{x:t,d})/X], \sigma>
~

~ Infer

-------------------------------------------[Parser-Type-Decl]
<\xi, \sigma, @parser X<\overline{X}>(\overline{x:t,d})> \Downarrow_d <\xi[@parser X<\overline{X}>(\overline{x:t,d})/X], \sigma>
~

~ Infer

-------------------------------------------[Package-Type-Decl]
<\xi, \sigma, @package X<\overline{X}>(\overline{x:t})> \Downarrow_d <\xi[@package X<\overline{X}>(\overline{x:t})/X], \sigma>
~

## Program Evaluation

$r ::= (packet', n_{out\_port}) | \mathkw{None}$

Programs are evaluated according to the following big-step relation:
~ Center
$\langle \xi, \sigma, packet, n_{in\_port}, \overline{decl} \rangle \Downarrow \langle \sigma', r \rangle$
~

~ Infer
<\xi, \sigma, \overline{decl}> \Downarrow_d <\xi', \sigma'>
<\xi', n_{in\_port}> \Downarrow_{Target\_init} <\xi''>
<\xi'', \sigma', packet, TODO> \Downarrow_{Target\_pipeline} <\sigma'', \xi''', packet'>
\xi'''(``std\_meta") = @struct \{...,(``egress\_port",n_u^w),...\}
----------------------------------------------------------------------------------------[Some-Packet]
<\xi, \sigma, packet, n_{in\_port}, \overline{decl}> \Downarrow <\sigma', (packet', n)>
~

~ Infer
<\xi, \sigma, \overline{decl}> \Downarrow_d <\xi', \sigma'>
<\xi', n_{in\_port}> \Downarrow_{Target\_init} <\xi''>
<\xi'', \sigma', packet, TODO> \Downarrow_{Target\_pipeline} <\sigma'', \xi''', @None>
----------------------------------------------------------------------------------------[No-Packet]
<\xi, \sigma, packet, n_{in\_port}, \overline{decl}> \Downarrow <\sigma', @None>
~

$p ::= packet | \mathkw{None}$

These relations are defined by the target:
~ Center
$\langle \xi, n_{in\_port} \rangle \Downarrow_{Target\_init} \langle \xi' \rangle$

$\langle \xi, \sigma, packet, TODO \rangle \Downarrow_{Target\_pipeline} \langle \sigma', \xi', p \rangle$
~

# Type Soundness

## Environment Typing
Given a store typing and a variable typing it is possible to typecheck an
evaluation environment $\xi,\sigma$
~MathPre
S,D,\Xi,G\vDash{}\xi,\sigma.
~
Since contexts and environments are structured into scopes, we will define this
judgment in terms of a per-scope judgment
~MathPre
S,D,\Xi,G\vDash{}\epsilon,\sigma.
~

Here is a formal definition:
~Infer

-------------------------------[Entails-Empty-Scope]
S,D,\Xi,G\vDash{}[]
~

~Infer
S,D,G\vDash{}\epsilon,\sigma
G(x)=t
\Xi(\ell)=t
---------------------------------------------[Entails-Variable-Scope]
S,D,G \models \epsilon,(x=\ell)
~


~ Infer

----------------------[Entails-Empty-Environment]
S,D,G \models ([],[],[],\nu),\sigma
~


~Infer
S,D,G \models (P,E,D,\nu),\sigma
S,D,G \models_{scope} \epsilon,\sigma
--------------------------------------------[Entails-Environment]
S,D,G \models ((P,\rho),(E,\epsilon),(D,\delta),\nu),\sigma
~

### Lemma: Entailment is Contravariant with respect to State
~MathPre
L_{0_1}: \forall S,D,G,\epsilon,\sigma,\sigma',
\sigma \subseteq \sigma' \Rightarrow S,D,G \models_{scope} \epsilon,\sigma \Rightarrow S,D,G \models_{scope} \epsilon,\sigma'
~

~MathPre
L_0: \forall S,D,G,\xi,\sigma,\sigma',
\sigma \subseteq \sigma' \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G \models \xi,\sigma'
~

### Lemma: $\mathkw{lv\_of\_expr}$ Sustains Entailment

TODO: need a good definition for this...

~MathPre
L_1: \forall S,D,G,\xi,\xi',\sigma,\sigma',e,sig,t,lv,
S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t,\_ \Rightarrow \mathkw{lv\_of\_expr} \xi \sigma e = (\xi', \sigma', sig, @lvalue t lv) \Rightarrow S,D,G \models \xi',\sigma' \wedge \sigma \subseteq \sigma' \wedge S,D,G |- lv : t,\_
~

#### Proof

TODO!

### The Necromancer $\Psi$: Constructing $\Gamma$ from $\xi_{closure}$

For function call expressions involving copyin and copyout, the type-preservation proof needs the typing context $\Gamma$ from the function's definition.
We need a way to reverse engineer $\Gamma$ from the closure environment $\xi_{closure}$.
Ergo, the need for a necromancer function:
~MathPre
\Psi : \Sigma \times \Delta \times \xi_{closure} \times \sigma  \mapsto \Gamma
~
$\Psi$ is defined as follows:
~Infer

-------------------------------------------------[Necromance-Empty-Scope]
\psi \, S \, D \, [] \, \sigma \mapsto_{scope} []
~
~Infer
\psi \, S \, D \, \epsilon \, \sigma \mapsto_{scope} \gamma
S \, D \, \gamma |- \sigma(\ell) : t, d
----------------------------------------------------------------------------------[Necromance-Scope]
\psi \, S \, D \, ((\epsilon,x=\ell),\nu) \, \sigma \mapsto_{scope} \gamma,(x:t,d)
~
~Infer

---------------------------------------------------[Necromance-Empty-Environment]
\Psi \, S \, D \, ([],[],\nu) \, \sigma \mapsto []
~
~Infer
\Psi \, S \, D \, (E,D,\nu) \sigma \mapsto G
\psi \, S \, D \, \epsilon \, \sigma \mapsto_{scope} \gamma
-------------------------------------------------------------------[Necromance-Environment]
\Psi \, S \, D \, ((E,\epsilon),(D,\delta),\nu) \, \sigma \mapsto G,\gamma
~

#### Corollary: The Necromancer necromances an entailing Typing Context

~MathPre
C_0: \forall S,D,\xi,\sigma,G,
\Psi \, S \, D \, \xi \, \sigma \mapsto G \Rightarrow S,D,G \models \xi,\sigma
~

##### Proof
Introducing the variables:
~MathPre
S,D,\xi,\sigma,G
~
and hypothesis:
~MathPre
H_0: \Psi \, S \, D \, \xi \, \sigma \mapsto G
~
we wish to prove the goal:
~MathPre
S,D,G \models \xi,\sigma
~
By induction on $H_0$ we have the following case-analysis:

###### Case Necromance-Empty-Environment
We have hypothesis:
~MathPre
H_0: \Psi \, S \, D \, ([],[],\nu) \, \sigma \mapsto []
~
and we wish to prove subgoal:
~MathPre
SG_1: S,D,G \models ([],[],\nu)
~
We may construct the rule-instance:
~ Infer

---------------------------------[Entails-Empty-Environment]
S,D,[] \models ([],[],\nu),\sigma
~
proving $SG_1$

###### Case Necromance-Environment
We have hypothesis:
~MathPre
H_0: \Psi \, S \, D \, ((E,\epsilon),(D,\delta),\nu) \, \sigma \mapsto G,\gamma
~
and induction hypothesis:
~MathPre
I_1: \Psi \, S \, D \, (E,D,\nu) \, \sigma \mapsto G \Rightarrow S,D,G \models (E,D,\nu),\sigma
\textit{Sketchy: probably need another lemma...}
~
and we wish to prove subgoal:
~MathPre
SG_1: S,D,(G,\gamma) \models ((E,\epsilon),(D,\delta),\nu),\sigma
~
By inversion on $H_0$ we have hypotheses:
~MathPre
H_1: \Psi \, S \, D \, (E,D,\nu) \sigma \mapsto G
H_2: \psi \, S \, D \, \epsilon \, \sigma \mapsto_{scope} \gamma
~
Via application $I_1 \, H_1$ we acquire hypothesis:
~MathPre
H_3: S,D,G \models (E,D,\nu),\sigma
~

TODO: stuck...

### Lemma: Copyin Preserves Entailment
TODO: Is this the right definition?
~MathPre
L_2: \forall \xi_{closure},x,t,d,v,\xi_{closure}',S,D,G,D_{\Psi},G_{\Psi}\sigma,\sigma'
S,D,G |- v : t, d \Rightarrow @copyin \, \xi_{closure} \, \sigma (x:t,d) v = \xi_{closure}',\sigma' \Rightarrow S,D_{\Psi},G_{\Psi} \models \xi_{closure},\sigma \Rightarrow S,D_{\Psi},G_{\Psi}[x:t,d] \models \xi_{closure}',\sigma' \wedge \sigma \subseteq \sigma'
~

#### Proof

TODO!

### Lemma: Copyout Preserves Entailment

TODO: probably need a better definition for this...

~MathPre
L_3: \forall \xi_{call}, \xi_{closure} \, \sigma, x, t, d, e, \sigma', S, D, G, D_{\Psi}, G_{\Psi}
S,D,G |- e : t,d \Rightarrow @copyout \, \xi_{call} \, \xi_{closure} \, \sigma \, (x:t,d) \, e = \sigma' \Rightarrow S,D,G \models \xi_{call},\sigma \Rightarrow S,D_{\Psi},G_{\Psi} \models \xi_{closure},\sigma \Rightarrow S,D,G \models \xi_{call},\sigma' \wedge \sigma \subseteq \sigma'
~

#### Proof

TODO!

### Lemma: Push Preserves Entailment
~MathPre
L_4: \forall S,D,G,\xi, \sigma,
S,D,G \models \xi,\sigma \Rightarrow S,D,G \models @push \xi,\sigma
~

#### Proof
Introducing variables:
~MathPre
S,D,G,\xi, \sigma
~
and hypothesis:
~MathPre
H_0: S,D,G \models \xi,\sigma
~
i.e:
~MathPre
H_0: S,D,G \models (E,D,\nu),\sigma
~
we wish to prove the goal:
~MathPre
S,D,G \models @push \xi,\sigma
~
By definition of $\mathkw{push}$ we may rewrite the goal as:
~MathPre
S,D,G \models ((E,[]),(D,[]),\nu),\sigma
~
We may construct the rule-instance:
~Infer

-------------------------------[Entails-Empty-Scope]
S,D,G \models_{scope} [],\sigma
~
as well as:
~Infer
S,D,G \models (E,D,\nu),\sigma
S,D,G \models_{scope} [],\sigma
--------------------------------------------[Entails-Environment]
S,D,G \models ((E,[]),(D,[]),\nu),\sigma
~
proving the goal.

$\square$.

### Lemma: Pop Preserves Entailment
~MathPre
L_5: \forall S,D,G,\xi,\sigma,
S,D,G \models \xi,\sigma \Rightarrow S,D,G \models @pop \xi,\sigma
~

#### Proof
Introducing variables:
~MathPre
S,D,G,\xi,\sigma
~
and hypothesis:
~MathPre
H_0: S,D,G \models \xi,\sigma
~
we wish to provethe goal:
~MathPre
S,D,G \models @pop \xi,\sigma
~
By inversion on $H_0$ we have the following case-analysis:

##### Case Entails-Empty-Environment
We have hypothesis:
~MathPre
H_0: S,D,G \models ([],[],\nu),\sigma
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models @pop ([],[],\nu),\sigma
~
which by definition of $\mathkw{pop}$ we may rewrite as:
~MathPre
SG_1: S,D,G \models ([],[],\nu),\sigma
~
and $H_0$ proves $SG_1$.

##### Case Entails-Environment
We have hypotheses:
~MathPre
H_0: S,D,G \models ((E,\epsilon),(D,\delta),\nu),\sigma
H_1: S,D,G \models (E,D,\nu),\sigma
H_2: S,D,G \models_{scope} \epsilon,\sigma
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models @pop ((E,\epsilon),(D,\delta),\nu),\sigma
~
which by definition of $\mathkw{pop}$ we may rewrite as:
~MathPre
SG_1: S,D,G \models (E,D,\nu),\sigma
~
and $H_1$ proves $SG_1$.

### Lemma $\mathkw{assign\_lv}$ Sustains Entailment

Need better definition...

~MathPre
L_6: \forall S,D,G,\xi,\sigma,lv,v,\sigma',sig,
S,D,G |- v : t,d \Rightarrow S,D,G |- lv : t,d \Rightarrow \mathkw{assign\_lvalue} \, \xi \, \sigma \, lv \, v = \sigma',sig \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G \models \xi,\sigma'
~

#### Proof

TODO!

### Lemmas: State is Monotonic

These are used to prove statement type preservation.

#### Expression Monotonicity
~MathPre
L_7:\forall \xi,\sigma,e,\xi',\sigma',sig,v
\langle \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle \Rightarrow \sigma \subseteq \sigma'
~

##### Proof

TODO!

#### Corollary: $\mathkw{lv\_of\_expr}$ is Monotonic
~MathPre
C_1: \forall \xi,\xi',\sigma,\sigma',e,sig,t,lv,
\mathkw{lv\_of\_expr} \sigma', sig, @lvalue t lv) \Rightarrow \sigma \subseteq \sigma'
~

##### Proof

TODO!

#### Corollary: Copyin is Monotonic
~MathPre
C_2: \xi_{closure}, \sigma, x, t, d, v, \xi_{closure}',\sigma',
@copyin \, \xi_{closure} \, \sigma (x:t,d) v = \xi_{closure}',\sigma' \Rightarrow \sigma \subseteq \sigma'
~

##### Proof

TODO!

#### Statement Monotonicity
~MathPre
L_8: \forall \xi,\sigma,s,\xi',\sigma',sig,
<\xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig> \Rightarrow \sigma \subseteq \sigma'
~

#### Proof


TODO!

### Lemma: Extending $\Delta$ Preserves Entailment

TODO: Is this valid?

The validity of this lemma may heavily depend upon how
reliant the typing judgment for values is upon the typing contexts.

~MathPre
L_9: \forall \xi,\sigma,S,D,X,\rho,
S,D,G \models \xi,\sigma \Rightarrow S,D[X \to \rho],G \models \xi,\sigma
~

#### Proof:

TODO!

### Lemma: Extending $\Sigma$ Preserves Entailment
~MathPre
L_{10}: \forall S,D,G,\xi,\sigma,decl,
S,D,G \models \xi,\sigma \Rightarrow S[decl],D,G \models \xi,\sigma
~

### Lemma Extending $\Sigma$ Preserves Per-Scope Entailment
~MathPre
L_{11}: \forall S,D,G,\epsilon,\sigma,decl,
S,D,G \models_{scope} \epsilon,\sigma \Rightarrow S[decl],D,G \models_{scope} \epsilon,\sigma
~

#### Proof:

TODO!

### Sketchy? Lemma Extending $P$ Preserves Entailment
~MathPre
L_{12}: \forall S,D,G,P,E,\nu,\sigma,decl
S,D,G \models (P,E,D,\nu),\sigma \Rightarrow S,D,G \models (P[decl],E,D,\nu),\sigma
~

#### Proof:
TODO!

### Lemma Extending $G, \, \xi, \, \sigma$ Preserves Entailment
~MathPre
L_{13}: \forall S,D,G,v,t,\xi,\sigma,x,
S,D,G |- v : t \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G[x:t] \models @new \, \xi \, \sigma \, x \, v
~

#### Proof:
Introducing variables:
~MathPre
S,D,G,v,t,\xi,\sigma,x
~
and hypotheses:
~MathPre
H_0: S,D,G |- v : t
H_1: S,D,G \models \xi,\sigma
~
we wish to prove the goal:
~MathPre
S,D,G[x:t] \models @new \, \xi \, \sigma \, x \, v
~
By definition of $\mathkw{new} \, \xi \, \sigma \, x ((t) \, v)$
~MathPre
@new \, \xi \, \sigma \, x \, v = \xi', \sigma'
\exists \ell,
\xi' = \xi,(x=\ell) = P,(E,\epsilon(x=\ell)),D,\nu
\sigma' = \sigma[v / \ell]
~
By inversion on $H_1$, we have the following case-analysis:

##### Case Entails-Empty-Environment
We have hypothesis:
~MathPre
H_0: S,D,G |- v : t
H_1: S,D,G \models (P,[],D,\nu),\sigma
~
and we wish to prove subgoal:
~MathPre
SG: S,D,G[x:t] \models (P,([],(x=\ell)),D,\nu),\sigma'
~
Thus we may construct the rule-instance:

Sketchy: there needs to be a typing judgment for values,
so we can show extending $\Gamma$ preserves the typing judgment...
~Infer
S,D,G \models_{scope} [],\sigma'
G[x:t](x) = t
S,D,G[x:t] |- \sigma'(\ell) : t
---------------------------------------------[Entails-Variable-Scope]
S,D,G[x:t] \models_{scope} ([],(x=\ell)),\sigma'
~
as well as:
~Infer
S,D,G[x:t] \models (P,[],D,\nu),\sigma'
S,D,G[x:t] \models_{scope} ([],(x=\ell)),\sigma'
--------------------------------------------[Entails-Environment]
S,D,G[x:t] \models (P,([],(x=\ell)),D,\nu),\sigma'
~
and we have proved $SG$.

##### Case Entails-Environment
We have hypothesis:
~MathPre
H_0: S,D,G |- v : t
H_1: S,D,G \models (P,(E,\epsilon),D,\nu),\sigma
H_2: S,D,G \models (P,E,D,\nu),\sigma
H_3: S,D,G \models_{scope} \epsilon,\sigma
~
and we wish to prove subgoal:
~MathPre
SG: S,D,G[x:t] \models (P,(E,(\epsilon,(x=\ell))),D,\nu),\sigma'
~
Sketchy, need to show extending $\Gamma$ is ok here...

Via applications $L_0 \, (\sigma \subseteq \sigma') \, H_2$ and $L_{0_1} \, (\sigma \subseteq \sigma') \, H_3$ we acquire hypotheses:
~MathPre
H_4: S,D,G[x:t] \models (P,E,D,\nu),\sigma'
H_5: S,D,G[x:t] \models_{scope} \epsilon,\sigma'
~
Thus we may construct the rule-instance:
~Infer
S,D,G[x:t] \models_{scope} \epsilon,\sigma'
G[x:t](x) = t,d
S,D,G[x:t] |- \sigma'(\ell) : t, d
---------------------------------------------[Entails-Variable-Scope]
S,D,G[x:t] \models_{scope} (\epsilon,(x=\ell)),\sigma'
~
as well as:
~Infer
S,D,G[x:t] \models (P,E,D,\nu),\sigma'
S,D,G[x:t] \models_{scope} (\epsilon,(x=\ell)),\sigma'
------------------------------------------------------------[Entails-Environment]
S,D,G[x:t] \models (P,(E,(\epsilon,(x=\ell))),D,\nu),\sigma'
~

$\square$.

### Lemma: $\mathkw{init\_val}$ is Sound
~MathPre
L_{14}: \forall S,D,G,\xi,\sigma,t,
S,D,G \models \xi,\sigma \Rightarrow S,D,G |- \mathkw{init\_val} \, \xi \, t : t
~

### Lemma: Extending $\Gamma$ with Previously Unbound Name Preserves Entailment
~MathPre
L_{15}: S,D,G,\xi,\sigma,x,t
x \notin G \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G[x:t] \models \xi,\sigma
~

## Type Soundness of Expressions

### Expression Type Preservation Theorem Statement
~ Begin Theorem { #type-preservation-expr; caption: "Evaluation preserves expression types"; }
Let $\langle\xi,\sigma,e\rangle$ be an initial configuration
and take contexts $\Sigma,\Delta,\Xi,\Gamma$. Suppose that
the configuration is safe in the context, so $\Xi,G\vdash{}\xi$,
$\Xi\vdash{}\sigma$, and $\Sigma,\Delta,\Gamma\vdash{}e:t{}$.
If there is a final configuration $\langle\xi',\sigma',sig,v\rangle$ such that
~ Begin MathPre
<\xi,\sigma,e>\Downarrow_{e}<\xi',\sigma',sig,v>,
~ End MathPre
then there exists an extension $\Xi' \supseteq \Xi$ of the store
typing such that

 * $\Xi' |- v:t{}$,
 * $\Xi',G\vdash{}\xi'$, and
 * $\Xi'\vdash{}\sigma'$.
~ End Theorem

### Expression Type Preservation Proof
By induction on $<\xi,\sigma,e>\Downarrow_{e}<\xi',\sigma',sig,v>$.

#### Case Bool-True
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- @true : @bool, @none
<\xi, \sigma, @true> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @true>
~
We wish to prove subgoals:
~MathPre
S,D,G \models \xi,\sigma \wedge S,D,G |- @true : @bool, @none
~
Our subgoal is true by assumption.

#### Case Bool-False
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- @false : @bool, @none
<\xi, \sigma, @false> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @true>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- @false : @bool, @none
~
Our subgoal is true by assumption.

#### Case Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- a : @int, @none
<\xi, \sigma, a> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- a : @int, @none
~
Our subgoal is true by assumption.

#### Case Unsigned-Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- nwa : @bit<a>, @none
<\xi, \sigma, nwa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_u^n>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- nwa : @bit<a>, @none
~
Our subgoal is true by assumption.

#### Case Signed-Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- nsa : @int<w>, @none
<\xi, \sigma, nsa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_s^n>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- nsa : @int<w>, @none
~
Our subgoal is true by assumption.

#### Case String
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- u : @string, @none
<\xi, \sigma, u> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, u>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- u : @string, @none
~
Our subgoal is true by assumption.

#### Case Var
We need to show that $<\xi,\sigma,\mathkw{sig\_continue},(\sigma \circ
\xi)(x)>$ is safe under some expansion $\Xi'$ of $\Xi$. This rule
leaves $\xi$ and $\sigma$ unchanged, so things will work out with
$\Xi'=\Xi$. Induction on $\Xi |- \xi:G$ shows that $\Xi(\xi(x))=\tau$,
and $\Xi |- \sigma$ allows us to conclude $\sigma(\xi(x)):t$.

#### Case Var-Top
As in the ordinary variable case.

#### Case Array-Access
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1[e_2] : t_1, d_1
H_2: <\xi, \sigma, e1[e2]> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_{(\mathkw{extract\_num} v) \% n_{size}}>
~
and inductive hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : t_1[], d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next}) : t_1[], d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2  : t_2, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi'',sigma'' \wedge S,D,G |- v  : t_2, d_2
~

We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_{(\mathkw{extract\_num} v) \% n_{size}} : t_1, d_1
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e_1 : t_1[], d_1
H_4: S,D,G |- e_2  : t_2, d_2
H_5: @numeric(t_2)
~

By inversion on $H_2$ we get hypotheses:
~MathPre
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next}) : t_1[], d_1
~

Sketchy: By inversion on $H_9$ we may conclude $SG_2$.

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'', \sigma''
H_{11}: S,D,G |- v  : t_2, d_2
~
thus by assumption $H_{10}$ subgoal $SG_1$ is proven.

#### Case Bitslice
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e[n_1:n_2] : S,D,G |- e1[e_2:e_3] : bit<n_1 - n_2 + 1>, d
H_2: <\xi, \sigma, e[n_1:n_2]> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)}>
~
and inductive hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bit<w>, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @bit<w>, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)} : bit<n1 - n2 + 1>, d
~

By inversion on $H_1$ and $H_2$ respectively we get hypotheses:
~MathPre
H_3: S,D,G |- e : @bit<w>, d
H_4:  <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : @bit<w>, d
~
By $H_5$, subgoal $SG_1$ holds.

Sketchy: By $H_6$ we know $v$ is numeric and thus $SG_2$ holds.

#### Case List-Expression
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
H_2: <\xi, \sigma, \{\overline{e}\}> \Downarrow_e <\xi', \sigma', sig, (\overline{v})>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- \overline{e: \tau, none} \Rightarrow <\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- \overline{v: \tau, none}
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- \{ \overline{v} \} : \{ \overline{\tau} \}, none
~
By inversion on $H_1$ and $H_2$ we respectively get hypotheses:
~MathPre
H_3: S,D,G |- \overline{e: \tau, none}
H_4: <\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- \overline{v: \tau, none}
~
By $H_5$, subgoal $SG_1$ holds.

By constructing the rule-instance:
~ Infer
S,D,G |- \overline{v: \tau, none}
-----------------------------------------------[List-Expression]
S,D,G |- \{ \overline{v} \} : \{ \overline{\tau} \}, none
~
we prove subgoal $SG_2$.

#### Case Record
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: <\xi, \sigma, \{ \overline{f=e} \}> \Downarrow_e <\xi', \sigma', sig, \{ \overline{f=v} \}>
H_2: S,D,G |- \{ \overline{f = e} \} : \{ \overline{f : t} \}
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- \overline{e : t} \Rightarrow <\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}> \Rightarrow S,D,G |- \xi',\sigma' \wedge S,D,G |- \overline{v : t}
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- \{ \overline{f=v} \} : \{ \overline{f : t} \}
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- \overline{e : t}
H_4: <\xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
~
Under the aegis of application $I_1 \, H_0 \, H_3 \, H_4$ we obtain hypotheses:
~MathPre
H_5: S,D,G |- \xi',\sigma'
H_6: S,D,G |- \overline{v : t}
~
and $H_5$ proves $SG_1$.
We may construct the rule-instance:
~ Infer
S,D,G |- \overline{v : t}
----------------------------------------------------------[Record]
S,D,G |- \{ \overline{f = v} \} : \{ \overline{v : t} \}
~
which proves $SG_2$.

#### Case Unary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- \diamond e : t, d
H_2: <\xi, \sigma, \diamond e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \diamond v>
~
and inductive hypothesis:
~MathPre
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e : t, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- \diamond v : t, d
~

By inversion on $H_1$ and $H_2$ we get the following subcases:

##### Subcase Not
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- !e : @bool, d
H_2: <\xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bool, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @bool, d
H_3: S,D,G |- e : @bool, d
H_4: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- !v : @bool, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : @bool, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : @bool, d
----------------------[Not]
S,D,G |- !v : @bool, d
~
we prove subgoal $SG_2$.

##### Subcase Bitwise-Not
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- {\texttt{\textasciitilde}e} : @bit<w>, d
H_2: <\xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e : @bit<w>, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi', \sigma' \wedge S,D,G |- v : @bit<w>, d
H_3: S,D,G |- e : @bit<w>, d
H_4: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- {\texttt{\textasciitilde}v} : @bit<w>, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : @bit<w>, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : @bit<w>, d
-------------------------------------------------[Bitwise-Not]
S,D,G |- {\texttt{\textasciitilde}v} : @bit<w>, d
~
we prove subgoal $SG_2$.

##### Subcase Negate
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- -e : t, d
H_2: <\xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e : t, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi', \sigma' \wedge S,D,G |- v : t, d
H_3: S,D,G |- e : t, d
H_7: @numeric(t)
H_4: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- -v : t, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : t, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : t, d
@numeric(t)
----------------------[Negate]
S,D,G |- -v : t, d
~
we prove subgoal $SG_2$.

#### Case Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : t, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e_1 : t_1, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : t_1, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t_2, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t_2, d_2
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : t, @binaryDir(d_1, d_2)
~

By inversion on $H_1$ and $H_2$ we get the following subcases:

##### Subcase Bool-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bool, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bool, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bool, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bool, d_2
H_3: S,D,G |- e_1 : @bool, d_1
H_4: S,D,G |- e_2 : @bool, d_2
H_5: \diamond \in \{ \&\&, || \}
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @bool, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @bool, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bool, d_1
S,D,G |- v_2 : @bool, d_2
\diamond \in \{ \&\&, || \}
------------------------------------------------------------------[Bool-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @int, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @int, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @int, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @int, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @int, d_2
H_3: S,D,G |- e_1 : @int, d_1
H_4: S,D,G |- e_2 : @int, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @int, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @int, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @int, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @int, d_1
S,D,G |- v_2 : @int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
------------------------------------------------------------------[Int-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @int, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Signed-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @int<w>, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @int<w>, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @int<w>, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @int<w>, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @int<w>, d_2
H_3: S,D,G |- e_1 : @int<w>, d_1
H_4: S,D,G |- e_2 : @int<w>, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @int<w>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @int<w>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @int<w>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @int<w>, d_1
S,D,G |- v_2 : @int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
------------------------------------------------------------------[Int-Signed-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @int<w>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Unsigned-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bit<w>, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bit<w>, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bit<w>, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bit<w>, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bit<w>, d_2
H_3: S,D,G |- e_1 : @bit<w>, d_1
H_4: S,D,G |- e_2 : @bit<w>, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<w>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @bit<w>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @bit<w>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<w>, d_1
S,D,G |- v_2 : @bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
------------------------------------------------------------------[Int-Unsigned-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<w>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Equality-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : t, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : t, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, d_2
H_3: S,D,G |- e_1 : t, d_1
H_4: S,D,G |- e_2 : t, d_2
H_{12}: \mathkw{has\_equality}(t)
H_5: \diamond \in \{ ==,!= \}
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : t, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : t, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : t, d_1
S,D,G |- v_2 : t, d_2
\diamond \in \{ ==,!= \}
------------------------------------------------------------------[Equality-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Bit-Concat-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{++} e_2 : @bit<l+r>, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \mathbin{++} e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \mathbin{++} v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bit<l>, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bit<l>, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bit<r>, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bit<r>, d_2
H_3: S,D,G |- e_1 : @bit<l>, d_1
H_4: S,D,G |- e_2 : @bit<r>, d_2
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{++} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @bit<l>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @bit<r>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<l>, d_1
S,D,G |- v_2 : @bit<r>, d_2
------------------------------------------------------------------[Bit-Concat-Op]
S,D,G |- v_1 \mathbin{++} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Shift-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : t_1, @binaryDir(d_1, d_2)
H_2: <\xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : t_1, d_1 \Rightarrow <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : t_1, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t_2, d_2 \Rightarrow <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t_2, d_2
H_3: S,D,G |- e_1 : t_1, d_1
H_4: S,D,G |- e_2 : t_2, d_2
H_{12}: @numeric(t_1)
H_{13}: t_2 = @bit<\_> \lor t_2 = @int
H_5: \diamond \in \{\ll, \gg\}
H_6: <\xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : t_1, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : t_2, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : t_1, d_1
S,D,G |- v_2 : t_2, d_2
@numeric(t_1)
t_2 = @bit<\_> \lor t_2 = @int
\diamond \in \{\ll, \gg\}
------------------------------------------------------------------[Shift-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : t_1, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

#### Case Bool-Cast-True
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@bool) e : @bool, @none
H_2: <\xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1> \Rightarrow S,D,G \models \xi',\sigma' \wedge \Rightarrow S,D,G |- 1_u^1 : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- @true : @bool, @none
~

$SG_2$ is true by constructing rule-instance:
~ Infer

------------------------[Bool-True]
 S,D,G |- @true : @bool, @none
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t_0, d
H_4: t_0 \prec @bool
~

By inversion on $H_2$ we get hypothesis:
~MathPre
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- 1_u^1 : t_0, d
~
By $H_6$ we prove subgoal $SG_1$.

#### Case Bool-Cast-False
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@bool) e : @bool, @none
H_2: <\xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1> \Rightarrow S,D,G \models \xi',\sigma' \wedge \Rightarrow S,D,G |- n_u^1 : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- @false : @bool, @none
~

$SG_2$ is true by constructing rule-instance:
~ Infer

------------------------[Bool-False]
 S,D,G |- @false : @bool, @none
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t_0, d
H_4: t_0 \prec @bool
~

By inversion on $H_2$ we get hypothesis:
~MathPre
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- n_u^1 : t_0, d
~
By $H_6$ we prove subgoal $SG_1$.

#### Case Bit-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@bit<w>) e : @bit<w>, @none
H_2: <\xi, \sigma, (@bit<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@of2s(\mathkw{extract\_num} v)}_u^{w}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- {@of2s(\mathkw{extract\_num} v)}_u^{w} : @bit<w>, @none
~

TODO: maybe we need different typing rules for fixed sized ints?

#### Case TypeName-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (X) e : X, @none
H_2: <\xi, \sigma, (X) e> \Downarrow_e <\xi', \sigma', sig, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- (\xi(X)) e : \xi(X), @none \Rightarrow <\xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \xi(X), @none
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : X, @none
~
By inversion on $H_1$ and $H_2$ we have hypotheses:
~MathPre
H_3: S,D,G |- (\xi(X)) e : \xi(X), @none
H_4: \xi(X) \prec X
H_5: <\xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- v : \xi(X), @none
~
By $H_6$, we prove $SG_1$.

Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- v : \xi(X), d
\xi(X) \prec X
-------------------------[Cast]
S,D,G |- (X) v : X, @none
~
~Infer

-----------------------[]
S,D,G |- v : X, @none
~
we prove subgoal $SG_2$

#### Case NewType-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@newtype t X) e : @newtype t X, @none
H_2: <\xi, \sigma, (@newtype t X) e> \Downarrow_e <\xi', \sigma', sig, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- (t) e : t, @none \Rightarrow <\xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t, @none
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : @newtype t X, @none
~
By inversion on $H_1$ and $H_2$ we have hypotheses:
~MathPre
H_3: S,D,G |- (t) e : t, d
H_4: t \prec (@newtype t X)
H_5: <\xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- v : t, @none
~
By $H_6$, we prove $SG_1$.

Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- v : t, @none
t \prec (@newtype t X)
-------------------------[Cast]
S,D,G |- (@newtype t X) v : @newtype t X, @none
~
~Infer

--------------------------------[]
S,D,G |- v : @newtype t X, @none
~
we prove subgoal $SG_2$

#### Case Type-Member-Enum
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- X_1.name : X_1, @none
H_2: <\xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi,\sigma
SG_2: S,D,G |-  X_2.name : X_1, @none
~
$SG_1$ is proven by $H_0$.

By inversion on $H_2$ we get hypothesis:
~MathPre
H_3: \xi(X_1) = @enum X_2 \{\dots,name,\dots\}
~
Thus $X_2$ can be substituted for $X_1$ under $\xi$. Thus $SG_2$ is proven by $H_1$.


#### Case Type-Member-SEnum
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |-  X_1.name : X_1, @none
H_2: <\xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi,\sigma
SG_2: S,D,G |-  X_2.name : X_1, @none
~
$SG_1$ is proven by $H_0$.

By inversion on $H_2$ we get hypothesis:
~MathPre
H_3: \xi(X_1) = @enum t X_2 \{\dots,(name, e),\dots\}
~
Thus $X_2$ can be substituted for $X_1$ under $\xi$. Thus $SG_2$ is proven by $H_1$.

#### Case Error-Member
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- @error.name : @error, @none
H_2: <\xi, \sigma, @error.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @error.name>
~
Our subgoal:
~MathPre
S,D,G \models \xi,\sigma \wedge S,D,G |- @error.name : @error, @none
~
is true by our assumptions $H_0 \wedge H_1$.

#### Case Struct-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : @struct \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
-------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Header-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Header-IsValid-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@isValid : @bool
H_2: <\xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- @builtin @isValid lv_o : @bool
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
H_6: \mathkw{lv\_of\_expr} \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
~
Via application $I_1 \, H_0 \, H_3 \, H_5$ we acquire hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
Via application $L_1 \, H_6 \, H_7$ we get hypothesis:
~MathPre
H_9: S,D,G \models \xi'',\sigma''
~
which proves subgoal $SG_1$.

TODO: I'm confused about these cases...

#### Case Header-Union-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots,(name,v),\dots \}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
--------------------------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Array-Size-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@size : @bit<32>, @none
H_2: <\xi, \sigma, e.@size> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {n_{size}}_u^{32}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- {n_{size}}_u^{32} : @bit<32>, @none
~
By inversion on $H_1$ and $H_2$ we acquire hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @size @bit<32>
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we obtain the hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$SG_1$ is proven by $H_6$.

TODO: maybe need to modify fixed-int type-checking...

#### Case Array-Next-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@next : t, @none
H_2: <\xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next}}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v_{n_{next}} : t, @none
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @next t
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$H_6$ proves subgoal $SG_1$.
Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
\mathkw{has\_field} t[a] @next t
------------------------------------[Expression-Member]
S,D,G |- v_{n_{next}} : t, @none
~
$SG_2$ is proven.

#### Case Array-Last-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@last : t, @none
H_2: <\xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next} - 1}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v_{n_{next} - 1} : t, @none
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @last t
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$H_6$ proves subgoal $SG_1$.
Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
\mathkw{has\_field} t[a] @last t
------------------------------------[Expression-Member]
S,D,G |- v_{n_{next} - 1} : t, @none
~
$SG_2$ is proven.

#### Case Ternary-Op-True
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 ? e_2 : e_3 : t, @none
H_2: <\xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bool, \_ \Rightarrow <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @true : @bool, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t, \_ \Rightarrow <\xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, \_
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, @none
~
By inversion on $H_1$ and $H_2$ we attain hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bool, \_
H_4: S,D,G |- e_2 : t, \_
H_5: <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true>
H_6: <\xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we earn hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @true : @bool, \_
~
Via the application $I_2 \, H_7 \, H_4 \, H_6$ we gain hypothesis:
~MathPre
H_9: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, \_
~
which proves our subgoal $SG_1$.

#### Case Ternary-Op-False
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 ? e_2 : e_3 : t, @none
H_2: <\xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bool, \_ \Rightarrow <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @false : @bool, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_3 : t, \_ \Rightarrow <\xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_3 : t, \_
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_3 : t, @none
~
By inversion on $H_1$ and $H_2$ we attain hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bool, \_
H_4: S,D,G |- e_3 : t, \_
H_5: <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false>
H_6: <\xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we earn hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @false : @bool, \_
~
Via the application $I_2 \, H_7 \, H_4 \, H_6$ we gain hypothesis:
~MathPre
H_9: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_3 : t, \_
~
which proves our subgoal $SG_1$.

#### Case Function-Eval
There are separate types for functions and actions. This proof only
deals with functions.

We would like to show $v:t_{ret}[\rho/X]$ in an extension of $\Xi$. We
will go one step at a time, constructing a chain of store typings
$\Xi \subseteq \Xi_1 \subseteq \dots
\subseteq \Xi_5$.
##### Closure typing
From the present evaluation rule and the typing
rule $\textsc{Function-Call}$ we have this situation.
~ MathPre
S,D,G |- f:@function<\overline{X}>(\overline{x:t,d}):t_{ret}
<\xi, \sigma_0, f> \Downarrow_e <\xi_1, \sigma_1, \mathkw{sig\_continue}, \xi_{closure}\otimes{}@function<X>(\overline{x':t',d'}) blk>
D[\overline{X=\rho}] |- t_{ret}~>t_{call}
S,D,G |- f<\overline{\rho}>(\overline{e}):t_{call}'
~
We don't know that the parameter lists line up yet. What we do know,
however, is that $\Gamma,\Xi |- \xi,\sigma_0$. Applying the induction
hypothesis yields a store typing $\Xi_1 \supseteq \Xi$ which types the
closure.
~ MathPre
\Xi_1 |- \xi_{closure}\otimes{}@function<X'>(\overline{x':t',d'}) blk:@function<\overline{X}>(\overline{x:t,d}):t_{ret}'.
~
Inverting this judgment tells us all the primed variables are
actually the same as the nonprimed ones and, furthermore, the block
returns an appropriate value.
~ MathPre
\xi_{closure}=(P_{cl},E_{cl},\Delta_{cl},\upsilon_{cl})
\Xi_1 |- \xi:G_{cl}
 [] ; D_{cl}[X=X];G_{cl},\overline{x:t} |- blk:@returns \tau_{ret} -| G'
~

##### Expression typing
##### Copy-in typing
##### Block typing
##### Copy-out typing

#### Case Masks
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \texttt{\&\&\&} e_2 : @set<@bit<w>>,@none
H_2: <\xi, \sigma, e_1 \texttt{\&\&\&} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \texttt{\&\&\&} v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bit<w>, \_ \Rightarrow <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bit<w>, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bit<w>, \_ \Rightarrow <\xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bit<w>, \_
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \texttt{\&\&\&} v_2 : @set<@bit<w>>,@none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bit<w>, \_
H_4: S,D,G |- e_2 : @bit<w>, \_
H_5: <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
H_6: <\xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- v_1 : @bit<w>, \_
~
Under the aegis of application $I_2 \, H_7 \, H_4 \, H_6$ we secure hypotheses:
~MathPre
H_9: S,D,G \models \xi'',\sigma''
H_{10}: S,D,G |- v_2 : @bit<w>, \_
~
$H_9$ proves $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<w>, \_
S,D,G |- v_2 : @bit<w>, \_
------------------------------------------------[Masks]
S,D,G |- v_1 \texttt{\&\&\&} v_2 : @set<@bit<w>>,@none
~
we prove $SG_2$.

#### Case Ranges
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1\mathbin{..}e_2 : @set<\tau>, @none
H_2: <\xi, \sigma, e_1 \mathbin{..} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \mathbin{..} v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : \tau, \_ \Rightarrow <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : \tau, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : \tau, \_ \Rightarrow <\xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : \tau, \_
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1\mathbin{..}v_2 : @set<\tau>, @none
~
By inversion on hypotheses $H_1$ and $H_2$ we land hypotheses:
~MathPre
H_3: S,D,G |- v_1 : \tau, \_
H_4: S,D,G |- v_2 : \tau, \_
H_5: \tau = @bit<w> \lor \tau = @int<w>
H_6: <\xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
H_7: <\xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
~
By dint of application $I_1 \, H_0 \, H_3 \, H_6$ we obtain hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : \tau, \_
~
By virtue of application $I_2 \, H_8 \, H_4 \, H_7$ we get hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : \tau, \_
~
$H_{10}$ proves $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : \tau, \_
S,D,G |- v_2 : \tau, \_
\tau = @bit<w> \lor \tau = @int<w>
-------------------------[Ranges]
S,D,G |- v_1\mathbin{..}v_2 : @set<\tau>, @none
~
we prove $SG_2$.

## Type Soundness of Statements

### Context-signal typing
Statement type preservation requires a predicate on contexts and signals:
~MathPre
\Xi,ctx |- sig
~

~ Infer

-------------------------------[]
\Xi,@void |- @stop
~

~ Infer

-------------------[]
\Xi,@unit |- @go
~
~ Infer

------------------------------[]
\Xi,@returns t |- @stop @exit
~
~ Infer
\Xi |- v:t
----------------------------------[]
\Xi,@returns t |- @stop @return v
~
~ Infer
\Xi |- v:@error
----------------------------------------------[]
\Xi,@parses |- @stop @reject v
~
~ Infer
\Xi |- v:@error
----------------------------------------------[]
\Xi,@parses |- @go
~

### Statement Type Preservation Theorem Statement
~ Begin Theorem { caption: "Evaluation preserves statement types"; }
Let $\langle\xi,\sigma,s\rangle$ be an initial configuration
and take contexts $\Sigma,\Delta,\Xi,G,G'$. Suppose that
the configuration is safe in the context, so

 * There exists a $G'$ for which $S,D,G,ctx |- s:R -| G'$,
 * $\Xi,G\vdash{}\xi$, and
 * $\Xi\vdash{}\sigma$.
 * $\Sigma,\Delta,\Gamma\vdash{}e:t{}$.

If there is a final configuration $<\xi',\sigma',sig>$ such that
~ Begin MathPre
<\xi,\sigma,s>\Downarrow_{s}<\xi',\sigma',sig>,
~ End MathPre

then there exists an extension $\Xi' \supseteq \Xi$ of the store
typing such that

 * $\Xi,R |- sig$,
 * $\Xi'\vdash{}\xi':G'$, and
 * $\Xi'\vdash{}\sigma'$.
~ End Theorem

~MathPre
\forall S,D,G,ctx,s,R,G',\xi,\sigma,\xi',\sigma',sig
S,D,G,ctx |- s: R -| G' \Rightarrow <\xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig> \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G' \models \xi',\sigma' \wedge \Omega ctx
~

### Statement Type Preservation Proof

Introducing variables:
~MathPre
S,D,G,ctx,s,R,G',\xi,\sigma,\xi',\sigma',sig
~
and assuming hypotheses:
~MathPre
H_0: S,D,G,ctx |- s:R -| G'
H_1: <\xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig>
H_2: S,D,G \models \xi,\sigma
~
we wish to prove the goal:
~MathPre
S,D,G \models \xi',\sigma'
~
We induct on the derivation of:
~MathPre
H_1: <\xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig>
~
We assume freely $s$ is free-variable free.

#### Case Assignment
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- e_l:=e_r:\bot -| G
H_1: <\xi, \sigma, e_l := e_r> \Downarrow_s <\xi', \sigma''', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_r : t,d \Rightarrow \langle \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', \mathkw{sig\_continue}, v \rangle \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \tau,d
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'''
~

By inversion on $H_0$ and $H_1$ we amass hypotheses:
~MathPre
H_3: \mathkw{lvalue}(e_l)
H_4: S,D,G |- e_l: t,\_
H_5: S,D,G |- e_r: t,\_
H_6: <\xi, \sigma, e_r> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
H_7: \mathkw{lv\_of\_expr} \xi \sigma' e_l = (\xi'', \sigma'', \mathkw{sig\_continue}, lv)
H_8: \mathkw{assign\_lv} \xi' \sigma'' lv v = (\sigma''', sig)
~

Via the application $I_1 \, H_2 \, H_5 \, H_6$ we obtain hypotheses
~MathPre
H_9: S,D,G \models \xi',\sigma'
H_{10}: S,D,G |- v : t,d
~
We may instantiate Lemma 1 as:
~MathPre
L_1: S,D,G \models \xi,\sigma' \Rightarrow S,D,G |- e_l : t,\_ \Rightarrow \mathkw{lv\_of\_expr} \xi \sigma' e_l = (\xi'', \sigma'', \mathkw{sig\_continue}, @lvalue t lv) \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- lv : t,\_
~

Via the application $L_1 \, (L_0 \, (L_7 \, H_6) \, H_2) \, H_4 \, H_7$ we acquire hypotheses:
~MathPre
H_{11}: S,D,G \models \xi'',\sigma''
H_{12}: S,D,G |- lv : t,\_
~

We may instantiate Lemma 6 as:
~MathPre
L_6: S,D,G |- v : t,d \Rightarrow S,D,G |- lv : t,d \Rightarrow \mathkw{assign\_lvalue} \, \xi' \, \sigma'' \, lv \, v = \sigma''',sig \Rightarrow S,D,G \models \xi',\sigma'' \Rightarrow S,D,G \models \xi',\sigma'''
~

Via the application $L_6 \, H_{10} \, H_{12} \, H_8 \, (L_0 \, (C_1 \, H_7) \, H_9)$ we obtain hypotheses:
~MathPre
H_{13}: S,D,G \models \xi',\sigma'''
~
Subgoal $SG$ is thus proven by $H_{13}$.

#### Case Conditional-Reject
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s_1 @else s_2:R_1\wedge{}R_2 -| G
H_1: <\xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi', \sigma', \mathkw{sig\_reject\ v}>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e:@bool,\_ \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v:@bool,\_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on $H_0$ and $H_1$ we collect hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s_1:R_1 -| G_1
H_5: S,D,G,ctx |- s_2:R_2 -| G_2
H_6: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v>
~
Through the agency of application $I_1 \, H_2 \, H_3 \, H_6$ we come by hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- v:@bool,\_
~
and $H_7$ proves $SG$.

#### Case If-True
We inherit hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s :\bot -| G
H_1: <\xi, \sigma, @if (e) s> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bool,\_ \Rightarrow \langle \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, @true \rangle \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @true : @bool,\_
I_2: S,D,G,ctx |- s:\bot -| G' \Rightarrow <@push \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig> \Rightarrow S,D,G \models @push \xi',\sigma' \Rightarrow S,D,G' \models \xi'',\sigma''
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s:R -| G'
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
H_6: <@push \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig>
~
Under the aegis of application $I_1 \, H_2 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @true : @bool,\_
~
By the application $L_0 \, (L_8 \, H_6)$ we acquire hypothesis:
~MathPre
H_9: S,D,G \models \xi',\sigma''
~
and by $H_9$ subgoal $SG$ is proven.

#### Case If-False
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s :\bot -| G
H_1: <\xi, \sigma, @if (e) s> \Downarrow_s <\xi', \sigma', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bool,\_ \Rightarrow \langle \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, @false \rangle \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @false : @bool,\_
~
We wish to prove:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on hypotheses $H_0$ and $H_1$ we inherit hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s:R -| G'
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~
Via application $I_1 \, H_2 \, H_3 \, H_5$ we obtain hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- @false : @bool,\_
~
and by $H_6$ we prove $SG$.

#### Case If-Else-True
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s_1 @else s_2:R_1\wedge{}R_2 -| G
H_1: <\xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e:@bool,\_ \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @true : @bool,\_
I_2: S,D,G,ctx |- s_1:R_1 -| G_1 \Rightarrow <@push \xi', \sigma', s1> \Downarrow_s <\xi'', \sigma'', sig> \Rightarrow S,D,G \models \xi',\sigma' \Rightarrow S,D,G_1 \models \xi'',\sigma''
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we amass hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s_1:R_1 -| G_1
H_5: S,D,G,ctx |- s_2:R_2 -| G_2
H_6: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
H_7: <@push \xi', \sigma', s_1> \Downarrow_s <\xi'', \sigma'', sig>
~
Via the application $I_1 \, H_2 \, H_3 \, H_6$ we acquire hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- @true : @bool, \_
~
By the application $L_0 \, (L_8 \, H_7) \, H_8$ we get hypothesis:
~MathPre
H_{10}: S,D,G \models \xi',\sigma''
~
and $H_{10}$ proves $SG$.

#### Case If-Else-False
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s_1 @else s_2:R_1\wedge{}R_2 -| G
H_1: <\xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e:@bool,\_ \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @false : @bool,\_
I_2: S,D,G,ctx |- s_2:R_2 -| G_2 \Rightarrow <@push \xi', \sigma', s_2> \Downarrow_s <\xi'', \sigma'', sig> \Rightarrow S,D,G \models \xi',\sigma' \Rightarrow S,D,G_2 \models \xi'',\sigma''
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we amass hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s_1:R_1 -| G_1
H_5: S,D,G,ctx |- s_2:R_2 -| G_2
H_6: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
H_7: <@push \xi', \sigma', s_2> \Downarrow_s <\xi'', \sigma'', sig>
~
Via the application $I_1 \, H_2 \, H_3 \, H_6$ we acquire hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- @true : @bool, \_
~
By the application $L_0 \, (L_8 \, H_7) \, H_8$ we get hypothesis:
~MathPre
H_{10}: S,D,G \models \xi',\sigma''
~
and $H_{10}$ proves $SG$.

#### Case Block
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- \{\overline{s}\}:sig -| G
H_1: <\xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi', \sigma', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: <\xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig> \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G \models \xi',\sigma'
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma'
~
By inversion on $H_0$ and $H_1$ we assemble hypotheses:
~MathPre
H_3: S,D,G,ctx |- \overline{s}:sig -| G'
H_4: <\xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig>
~
By the application $L_0 \, (L_8 \, H_4) \, H_2$ we get hypothesis:
~MathPre
H_5: S,D,G \models \xi,\sigma'
~

#### Case Exit-Continue
We have hypotheses:
~MathPre
H_0: S,D,G,@InParserState |- @exit:@returns -| G
H_1: <\xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma
~
$H_2$ proves $SG$.

#### Case Empty
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- \mathkw{;}:\bot -| G
H_1: <\xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma
~
$H_2$ proves $SG$.

#### Case Return-Void
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @return:@returns -| G
H_1: <\xi, \sigma, @return> \Downarrow_s <\xi, \sigma, \mathkw{sig\_return\ None}>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma
~
$H_2$ proves $SG$.

#### Case Return-Value
We have hypotheses:
~MathPre
H_0: S,D,G,@InFunction t |- @return e:@returns -| G
H_1: <\xi, \sigma, @return e> \Downarrow_s <\xi', \sigma', \mathkw{sig\_return\ v}>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t,\_ \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t,\_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on $H_0$ and $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t,\_
H_4: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
By virtue of the application $I_1 \, H_2 \, H_3 \, H_4$ we obtain hypotheses:
~MathPre
H_5: S,D,G \models \xi',\sigma'
H_6: S,D,G |- v : t, \_
~
and $H_5$ proves $SG$.

#### Case Switch-No-Match
We have hypotheses:
~MathPre
H_0: S,D,G,@InControl |- @switch (e) \{ case1, \dots, case_n \}:\bot -| G
H_1: <\xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @enum X,\_ \{ \overline{m} \} \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @enum X \{ \overline{m} \}, \_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on hypotheses $H_0$ and $H_1$ we profit hypotheses:
~MathPre
H_3: S,D,G |- e : @enum X \{ \overline{m} \}, \_
H_4: \forall i. S,D,G |- \mathkw{case\_ok}_X case_i
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
H_6: \mathkw{match\_switch\_case} \overline{case} name_2 = None
~
By means of application $I_1 \, H_2 \,H_3 \, H_5$ we procure hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- e : @enum X \{ \overline{m} \}, \_
~
and $H_7$ proves $SG$.

#### Case Switch-Match
We have hypotheses:
~MathPre
H_0: S,D,G,@InControl |- @switch (e) \{ case1, \dots, case_n \}:\bot -| G
H_1: <\xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @enum X,\_ \{ \overline{m} \} \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @enum X \{ \overline{m} \}, \_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we garner hypotheses:
~MathPre
H_3: S,D,G |- e : @enum X \{ \overline{m} \}
H_4: \forall i. S,D,G |- \mathkw{case\_ok}_X case_i
H_5: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
H_6: \mathkw{match\_switch\_case} \overline{case} name_2 = Some\ blk
H_7: <@push \xi', \sigma', blk> \Downarrow_s <\xi'', \sigma'', sig>
~
TODO: where is $\mathkw{case\_ok}$ defined?

Via application $I_1 \, H_2 \, H_3 \, H_5$ we obtain hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v : @enum X \{ \overline{m} \}, \_
~

As a result of application $L_0 \, (L_8 \, H_7) \, H_8$ we secure hypothesis:
~MathPre
H_{10}: S,D,G \models \xi',\sigma''
~
and $H_{10}$ proves $SG$.

## Type Soundness of Declarations

### Declaration Type Preservation Theorem Statement

~MathPre
\forall S,D,G,decl,S',D',G',\xi,\sigma,\xi',\sigma',
S,D,G |- decl -| S',D',G' \Rightarrow <\xi, \sigma, decl> \Downarrow_d <\xi', \sigma'> \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S',D',G' \models \xi',\sigma'
~

### Declaration Type Preservation Proof

Introducing variables:
~MathPre
S,D,G,decl,S',D',G',\xi,\sigma,\xi',\sigma'
~
and hypotheses:
~MathPre
H_0: S,D,G |- decl -| S',D',G'
H_1: <\xi, \sigma, decl> \Downarrow_d <\xi', \sigma'>
H_2: S,D,G \models \xi,\sigma
~
we wish to prove the goal:
~MathPre
S',D',G' \models \xi',\sigma'
~
We induct on the derivation of:
~MathPre
H_1: <\xi, \sigma, decl> \Downarrow_d <\xi', \sigma'>
~
We assumely freely $decl$ is free-variable free.

#### Case Constant-Decl
We have hypotheses:
~MathPre
H_0: S,D,G |- @const t x := v -| S[x = v],D,G[x:t]
H_1: <\xi, \sigma, @const t x:=v> \Downarrow_d <@new \, \xi \, \sigma \, x \, v>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S[x=v],D,G[x:t] \models @new \, \xi \, \sigma \, x \, v
~
By inversion on $H_0$ we get hypothesis:
~MathPre
H_3: S,D,G |- v:t
~
Via the application $L_{10} \, (L_{13} \, H_3 \, H_2)$ we acquire hypothesis:
~MathPre
H_4: S[x=v],D,G[x:t] \models @new \, \xi \, \sigma \, x \, v
~
and $H_4$ proves $SG$.

#### Case Parser-Decl
~MathPre
H_0: S,D,G |- @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} -| S,D,G[X:t_ctor]
H_1: <\xi, \sigma, @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}> \Downarrow_d <\xi[@parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}/X], \sigma>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[X:t_ctor] \models \xi[@parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}/X], \sigma
~
Sketchy: I am just doing the non-empty case for now.

By inversion on $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G \models (P,E,D,\nu),\sigma
H_4: S,D,G \models_{scope} \epsilon,\sigma
~
Sketchy: $\models$ may need to take into account other constituents of $\xi$.
Right now it only takes into account the variable to location mapping $E$.

TODO: The dynamic semantics do not map the name $X$ to a value in $(\sigma \circ \xi)$.
I am not sure how to show that preservation holds still, since theoretically $X$ may have been mapped to a value of a different type...
This is a problem with several of the declaration rules...

#### Case Function-Decl
We have hypotheses:
~MathPre
H_0: S,D,G |- @function t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G'
H_1: <\xi, \sigma, @function t x<\overline{X}>(\overline{x:t,d}) blk> \Downarrow_d <\xi'[ @function t x<\overline{X}>(\overline{x:t,d}) blk/x], \sigma'>
H_2: S,D,G \models \xi,\sigma
~
and we wish to prove subgoal:
~MathPre
SG: S,D,G' \models \xi'[ @function t x<\overline{X}>(\overline{x:t,d}) blk/x], \sigma'
~
By inversion on $H_0$ and $H_1$ we get hypotheses:
~MathPre
H_3: \exists \rho, S,D[\overline{X \to \rho}],G[\overline{x:t}],@InFunction t |- blk: @returns t -| G_{blk}
H_4: G' = G[x:@function<\overline{X}>(\overline{x: t}) : t]
H_5: @new \, \xi \, \sigma \, x \, (\xi \otimes (\overline{x:t,d}) \to blk) = \xi', \sigma'
~
Sketchy: need to define type-checking for values!

By construction we have:
~MathPre
H_6: S,D,G' |- \xi \otimes (\overline{x:t,d}) \to blk : @function<\overline{X}>(\overline{x: t}) : t
~
Via the application $L_{12} \, (L_{13} \, H_6 \, H_2)$ we acquire hypothesis:
~MathPre
H_7: S,D,G' \models \xi'[ @function t x<\overline{X}>(\overline{x:t,d}) blk/x], \sigma'
~
and $H_7$ proves $SG$.

#### Case Extern-Function-Decl
We have hypotheses:
~MathPre
H_0: S,D,G |- \mathkw{extern\ function} t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G'
H_1: <\xi, \sigma, \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})> \Downarrow_d <(\xi'[\mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})/x]), \sigma'>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G' \models (\xi'[\mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})/x]), \sigma'
~
By inversion on $H_0$ and $H_1$ we obtain hypotheses:
~MathPre
H_3: G' = G[x:@function<\overline{X}>(\overline{x: t,d}) : t]
H_4: @new \, \xi \, \sigma \, x \, (@extern x @None) = \xi',\sigma'
~
Sketchy: need to define type-checking for values!

By construction we have:
~MathPre
H_5: S,D,G' |- (@extern x @None) : x:@function<\overline{X}>(\overline{x: t,d}) : t
~
Via the application $L_{12} \, (L_{13} \, H_5 \, H_2)$ we acquire hypothesis:
~MathPre
H_6: S,D,G' \models (\xi'[\mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})/x]), \sigma'
~
and $H_6$ proves $SG$.

#### Case Variable-Decl
We have hypotheses:
~MathPre
H_0: S,D,G |- t x -| S,D,G[x:t]
H_1: <\xi, \sigma, t x> \Downarrow_d <@new \, \xi \, \sigma \, x \, (\mathkw{init\_val} \xi t)>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[x:t] \models @new \, \xi \, \sigma \, x \, (\mathkw{init\_val} \xi t)
~
By dint of application $L_{13} \, (L_{14} \, H_2) \, H_2$ we acquire hypothesis:
~MathPre
H_3: S,D,G[x:t] \models @new \, \xi \, \sigma \, x \, (\mathkw{init\_val} \, \xi \, t)
~
and $H_3$ proves $SG$.

#### Case Variable-Initialized-Decl-Success
We have hypotheses:
~MathPre
H_0: S,D,G |- t x := e -| S,D,G[x:t]
H_1: <\xi, \sigma, t x := e> \Downarrow_d <@new \, \xi' \, \sigma' \, x \, v>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \tau
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[x:t] \models @new \, \xi' \, \sigma' \, x \, v
~
By inversion on $H_0$ and $H_1$ we secure hypotheses:
~MathPre
H_3: S,D,G |- e : t
H_4: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
Via application $I_1 \, H_2 \, H_3 \, H_4$ we acquire hypotheses:
~MathPre
H_5: S,D,G \models \xi',\sigma'
H_6: S,D,G |- v : \tau
~
By application $L_{13} \, H_6 \, H_5$ we get hypothesis:
~MathPre
H_7: S,D,G[x:t] \models @new \, \xi' \, \sigma' \, x \, v
~
and $H_7$ proves $SG$.

#### Case Variable-Initialized-Decl-Fail
We have hypotheses:
~MathPre
H_0: S,D,G |- t x := e -| S,D,G[x:t]
H_1: <\xi, \sigma, t x := e> \Downarrow_d <@new \, \xi' \, \sigma' \, x \, (\mathkw{init\_val} \xi t)>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t \Rightarrow <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \tau
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[x:t] \models @new \, \xi' \, \sigma' \, x \, (\mathkw{init\_val} \xi t)
~
By inversion on hypotheses $H_0$ we procure hypotheses:
~MathPre
H_3: S,D,G |- e : t
H_4: <\xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig, v>
H_5: sig \neq \mathkw{sig\_continue}
~
By application $I_1 \, H_2 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- v : \tau
~
By dint of application $L_{13} \, (L_{14} \, H_6) \, H_6$ we acquire hypothesis:
~MathPre
H_8: S,D,G[x:t] \models @new \, \xi' \, \sigma' \, x \, (\mathkw{init\_val} \xi t)
~
and $H_8$ proves $SG$.

#### Case Value-Set-Decl-Success
TODO: currently I am not sure how we are checking the size $e$ is numeric...

We have hypotheses:
~MathPre
H_0: S,D,G |- \mathkw{value\_set}<t>(e) x -| S,D,G[x:@set t]
H_1: <\xi, \sigma, \mathkw{value\_set}<t>(e) x> \Downarrow <@new \, \xi' \, \sigma' \, x \, v>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow ??? \Rightarrow <\xi[t/x], \sigma, e> \Downarrow <\xi', \sigma', sig\_continue, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge ???
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[x:@set t] \models @new \, \xi' \, \sigma' \, x \, v
~
By inversion on $H_0$ and $H_1$ we score hypothesis:
~MathPre
H_3: \textit{I need some hypothesis about e but one currently does not exist...}
H_4: <\xi[t/x], \sigma, e> \Downarrow <\xi', \sigma', sig\_continue, v>
~
By application $I_1 \, H_2 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi',\sigma'
H_6: ???
~
TODO: Type-Decl-Value-Set needs a hypothesis for $e$.

#### Case Value-Set-Decl-Fail
We have hypothesis:
~MathPre
H_0: S,D,G |- \mathkw{value\_set}<t>(e) x -| S,D,G[x:@set t]
H_1: <\xi, \sigma, \mathkw{value\_set}<t>(e) x> \Downarrow <\xi, \sigma>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma
~
$H_2$ proves $SG$.

#### Case Action-Decl
We have hypotheses:
~MathPre
H_0: S,D,G |- @action x<\overline{X}>(\overline{x:t,d_0},\overline{x:t}) blk -| S,D,G'
H_1: <\xi, \sigma, @action x (\overline{x:t,d_0},\overline{x:t}) blk> \Downarrow_d <\xi'[@action x (\overline{x:t,d_0},\overline{x:t}) blk/x], \sigma'>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G' \models \xi'[@action x (\overline{x:t,d_0},\overline{x:t}) blk/x], \sigma'
~
By inversion on $H_0$ and $H_1$ we obtain hypotheses:
~MathPre
H_3: S,D[\overline{X=X}],G[\overline{x:t}],@InAction |- blk : @returns -| G_{blk}
H_4: G' = G[x:@action<\overline{X}>(\overline{x:t,d0},\overline{x:t})]
H_5: @new \, \xi \, \sigma \, x \, (\xi \otimes (\overline{x:t,d_0},\overline{x:t}) \to blk) = \xi',\sigma'
~
Sketchy: we need to define type-checking for values!

By construction we have that:
~MathPre
H_6: S,D,G' |- \xi \otimes (\overline{x:t,d_0},\overline{x:t}) \to blk : @action<\overline{X}>(\overline{x:t,d0},\overline{x:t})
~
Via application $L_{12} \, (L_{13} \, H_6 \, H_2)$ we get hypothesis:
~MathPre
H_7: S,D,G' \models \xi'[@action x (\overline{x:t,d_0},\overline{x:t}) blk/x], \sigma'
~
and $H_7$ proves $SG$.

#### Case Error-Decl
We have hypotheses:
~MathPre
H_0: S,D,G |- @error \{ \overline{x} \} -| S,D,G[\overline{@error.x:@error}]
H_1: <\xi, \sigma, @error \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[\overline{@error.x:@error}] \models \xi,\sigma
~
By inversion on $H_0$ we get hypothesis:
~MathPre
H_3: \overline{@error.x \notin G}
~
Via application $L_{15} \, H_3 \, H_2$ we procure hypothesis:
~MathPre
H_4: S,D,G[\overline{@error.x:@error}] \models \xi,\sigma
~
and $H_4$ proves $SG$.

#### Case Matchkind-Decl
We have hypotheses:
~MathPre
H_0: S,D,G |- \mathkw{match\_kind} \{ \overline{x} \} -| S,D,G[\overline{.x:\mathkw{match\_kind}}]
H_1: <\xi, \sigma, \mathkw{match\_kind} \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[\overline{.x:\mathkw{match\_kind}}] \models \xi,\sigma
~
By inversion on $H_0$ we obtain hypothesis:
~MathPre
H_3: \overline{.x \notin G}
~
Via application $L_{15} \, H_3 \, H_2$ we acquire hypothesis:
~MathPre
H_4: S,D,G[\overline{.x:\mathkw{match\_kind}}] \models \xi,\sigma
~
and $H_4$ proves $SG$.
