Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp
Package: mathtools
Package: xspace

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/( +)-\|( +)/\1\dashv{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG([^a-zA-Z])/\Gamma{}\1/g";
  replace: "/\bD([^a-zA-Z])/\Delta{}\1/g";
  replace: "/\bS([^a-zA-Z])/\Sigma{}\1/g";
  replace: "/\bt([^a-z])/\tau{}\1/g";
  replace: "/</\langle{}/g";
  replace: "/>/\rangle{}/g";
  replace: "/\b:=\b/\coloneqq{}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

p4mathgrammar {
  replace:"/\/\/(.*)/\/\/ &\text{\1}/g";
  replace: "~ Begin P4MathGrammarBlock&nl;\
                 ~ Begin MathPre&nl;&source;&nl;~ End MathPre&nl;\
                 ~ End P4MathGrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expressions

~ Begin P4MathGrammar
e ::= @true
    | @false
    | a // arbitrary width integer literal
    | nwa // unsigned integer literal
    | nsa // signed integer literal
    | u // strings
    | x // name
    | .x // top level name
    | e1[e2] // array access
    | e1[e2:e3] // bitslice
    | {e1,...,en} // list
    | uop e
    | e1 binop e2
    | (t) e // explicit cast
    | X.name // type member
    | @error.name // errors
    | e.name // expression member
    | e1 ? e2 : e3 // ternary operator
    | f<\overline{t}>(\overline{e}) // function call (positional)
    | f<\overline{t}>(\overline{x=e}) // function call (named)
    | t(\overline{e}) // nameless instantiation
    | e1 \texttt{\&\&\&} e2 // mask
    | e1 .. e2 // range
~ End P4MathGrammar

~ Begin P4Grammar
// unary operators
uop ::= ! // not
      | - // unary minus
      | ~ // bitwise complement/not

// binary operators
binop ::= +
        | |+|
        | -
        | |-|
        | *
        | /
        | %
        | <<
        | >>
        | <
        | >
        | <=
        | >=
        | ==
        | !=
        | &
        | ^
        | |
        | ++
        | &&
        | ||
~ End P4Grammar

## Statements and blocks
~ Begin P4MathGrammar
s ::= e<\overline{t}>(\overline{e})     // method calls (positional)
    | e<\overline{t}>(\overline{x=e})   // method calls (named)
    | e := e                            // assignment
    | t.@apply(e_1,...,e_n)             // direct type invocation
    | @if (e) s_1 @else s_2             // conditional statement
    | blk                               // block statement
    | @exit                             // exit statement (only in controls)
    | \mathkw{;}                        // empty statement
    | @return                           // return (void)
    | @return e                         // return (with value)
    | @switch (e) \{ \overline{case} \} // switch statement
    | decl                              // declaration statement

case ::= case\_lbl: blk  // label with block
       | case\_lbl: {}   // fallthrough

case\_lbl ::= x                // name (of action)
            | \texttt{default} // catch-all label

blk ::= \{ s_1; ... s_n; \} // blocks
~ End P4MathGrammar

## Declarations
~ Begin P4MathGrammar
decl ::= @const t x:=e
       | t x(\overline{e})
       | t x(\overline{e}) blk
       | @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}
       | @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}
       | @function t x<\overline{X}>(\overline{x:t,d}) blk
       | \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})
       | t x
       | t x := e
       | \mathkw{value\_set}<t>(e) x
       | @action x (\overline{x:t,d_0},\overline{x:t}) blk
       | @table x \{ \overline{prop} \}
       | @header X \{ \overline{x:t} \}
       | \mathkw{header\ union} X \{ \overline{x:t} \}
       | @struct X \{ \overline{x:t} \}
       | @error \{ \overline{x} \}
       | \mathkw{match\_kind} \{ \overline{x} \}
       | @enum X \{ \overline{x} \}
       | @enum t X \{ \overline{x=e} \}
       | @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
       | @typedef t X
       | @type t X
       | @control X<\overline{X}>(\overline{x:t,d})
       | @parser X<\overline{X}>(\overline{x:t,d})
       | @package X<\overline{X}>(\overline{x:t})

state ::= @state x \{ \overline{s}; @transition state\_expr \}

state\_expr ::= x
              | @select (\overline{e}) \{ \overline{matches:x} \}

matches = \overline{match}

match ::= \mathkw{\_}
        | e

ctor ::= X(\overline{x:t})

method ::= @abstract t x<\overline{X}>(\overline{x:t,d})
         | t x<\overline{X}>(\overline{x:t,d})

prop ::= @key = \{ \overline{e:x} \}
       | @actions = \{ \overline{action\_ref} \}
       | @const @entries = \{ \overline{matches:action\_ref} \}
       | x = e
       | @const x = e

action\_ref ::= x(\overline{e})
~ End P4MathGrammar

## Programs
A program is a sequence of declarations.
~ Begin P4MathGrammar
P ::= decl, P
    | ()
~ End P4MathGrammar

## Types

~ Begin P4MathGrammar
t ::= @bool
    | @string
    | @int
    | @int<w>
    | @bit<w>
    | @varbit<w>
    | t[a]
    | @tuple<\overline{t}>
    | \{ \overline{t} \}
    | @set<t>
    | @error
    | \mathkw{match\_kind}
    | X  // type name
    | .X // top level type reference
    | @newtype X t
    | @void
    | @header \{ \overline{f:t} \}
    | \mathkw{header\ union} \{ \overline{f:t} \}
    | @struct \{ \overline{f:t} \}
    | @enum X \{ \overline{x} \}
    | @enum t X \{ \overline{x=v} \}
    | t<\overline{t}> // specialized type
    | @package<\overline{X}>(\overline{x:t,d})
    | @control<\overline{X}>(\overline{x:t,d})
    | @parser<\overline{X}>(\overline{x:t})
    | @extern X \{ \overline{method} \}
    | @function<\overline{X}>(\overline{x:t}) : \tau
    | \mathkw{extern\ function} x<\overline{X}>(\overline{x:t,d}):t
    | @action(\overline{x:t,d_0}, \overline{x:t}) : @void
    | @constructor<\overline{X}>(\overline{x:t}): t
    | @table X

d0 ::= @in
     | @out
     | @inout

d ::= d0 | @none
~ End P4MathGrammar

Signals are types for statements.
~ P4MathGrammar
sig := @returns // written ``Void" in the implementation
     | \bot     // written ``Unit" in the implementation
~

Contexts indicate where a statement is being typechecked.
~ P4MathGrammar
ctx ::= @InFunction t
      | @InControl
      | @InParser
      | @InAction
~

## Values

<!--
TODO:
- lvalues?
- lists vs tuples
-->
$a \in \mathbb{Z}$

$n \in \mathbb{N}$

$\mathbb{Z}_n ::= m \% 2^n | m \in \mathbb{Z}$

$m_u^n \in \mathbb{Z}_n$

$m_s^n \in \mathbb{Z}_{n-1} \cup \{ -x | x \in \mathbb{Z}_n\}$

Values
~ Begin P4MathGrammar
v ::= b // booleans
    | a // arbitrary-width integers
    | m_u^n // unsigned integers, n not zero
    | m_s^n // signed integers, n not zero
    | (n, m_u^{n'}) // variable-size bitstrings, n less than n'
    | u // strings
    | (\overline{v}) // tuples
    | set
    | @error.name
    | (\overline{p}) \Rightarrow blck // functions, actions
    | @builtin name
    | @struct \{ \overline{(name, v)} \}
    | (@header \{ \overline{(name, v)} \}, b)
    | (\mathkw{header\ union} \{ \overline{(name, b)} \}, v)
    | (\overline{v}, n_{size}, n_{next}) // stacks
    | name1.name2 // enumfield
    | (name1.name2, v) // senumfield
    | loc // stateful runtime
    | @parser (\overline{(name, v)}, \overline{p}, \overline{decl}, \overline{state})
    | @control (\overline{(name, v)}, \overline{p}, \overline{decl}, blck)
    | @package (\overline{(name, v)})
    | @table (name, \overline{v}, \overline{@action}, @action_default, \overline{set})
    | @extern name
~ End P4MathGrammar

Sets
~ Begin P4MathGrammar
set ::=  \_ // universal
    | v // singleton
    | v1 \texttt{\&\&\&} v2 // mask
    | v1 .. v2 // range
    | (\overline{set}) // product
    | @lpm v // lpm
    | ?? // TODO: value set
~ End P4MathGrammar

Parameters
~ Begin P4MathGrammar
p ::= (d, \tau, v, e_{opt})
e_{opt} ::= @None
      | @Some e
~ End P4MathGrammar

## Signals
~ Begin P4MathGrammar
sig ::= \mathkw{sig\_continue}
    | \mathkw{sig\_return\ v}
    | \mathkw{sig\_exit} 
    | \mathkw{sig\_reject\ v}
~ End P4MathGrammar

# Static Semantics { #sec-static }

## Typing contexts

All typing judgments include

1. $\Sigma$, the values of any compile-time-known constants,
2. $\Delta$, the definitions of type names in scope, and
3. $\Gamma$, the types of variables in scope.

Type variables are tracked by mapping type names $X$ to themselves in
the context $\Delta$. Equivalently there could be another context that
was a list of lists of type variables, without them being mapped to
anything.

~ MathPre
\sigma ::= \sigma, x=v | []

S ::= S, \sigma{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []

\gamma ::= \gamma, x:t,d | []

G ::= G, \gamma{} | []
~

In all contexts there is a lookup test $C(x) = y$ which searches from
the outermost list of bindings inward and a top level lookup $C(.x) =
y$ which only looks at the innermost list of bindings.

## Helper judgments

### Numeric types
~ MathPre
@numeric(t) = \begin{cases} true & t = int
true & t = int<w>
true & t = bit<w>
false & \text{otherwise}
\end{cases}
~

### Left-values

Left-values or lvalues are expressions that can appear on the left
side of an assignment $e:=e$.  The judgment has the form
~ MathPre
e @lvalue
~
and is defined inductively by the following rules.

~ Infer

-------------[Name-LValue]
x @lvalue
~

~ Infer

-------------[Top-Level-Name-LValue]
.x @lvalue
~

~ Infer
e @lvalue
--------------[Member-LValue]
e.x @lvalue
~

~ Infer
e1 @lvalue
----------------[Index-LValue]
e1[e2] @lvalue
~

~ Infer
e1 @lvalue
----------------[Slice-LValue]
e1[e2:e3] @lvalue
~

## Expression typing
### Constants

~ Infer

------------------------[Bool-True]
 S,D,G |- @true : @bool, @none
~

~ Infer

------------------------[Bool-False]
 S,D,G |- @false : @bool, @none
~

~ Infer

------------------------[String]
 S,D,G |- u : @string, @none
~

~ Infer

------------------------[Int-Constant]
S,D,G |- a : @int, @none
~

~ Infer

------------------------[Signed-Int-Constant]
S,D,G |- nsa : @int<w>, @none
~

~ Infer

------------------------[Unsigned-Int-Constant]
S,D,G |- nwa : @bit<a>, @none
~

### Variables

~ Infer
G(x) = t, d
-------------------[Var]
S,D,G |- x : t, d
~

~ Infer
G(.x) = t, d
----------------------[Var-Top]
S,D,G |- .x : t, d
~

### Accesses

~ Infer
S,D,G |- e_1 : t_1[], d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
----------------------[Array-Access]
S,D,G |- e_1[e_2] : t_1, d_1
~

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
S,D,G |- e_3  : t_3, \_
@numeric(t_3)
0 \leq e_2
e_2 \lt w
e_2 \leq e_3
e_3 \lt w
------------------------[Slice]
S,D,G |- e1[e2:e3] : t_1, d_1
~

~ Infer
S,D,G |- \overline{e: \tau, none}
-----------------------------------------------[List-Expression]
S,D,G |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
~

### Unary Operations

~ Infer
S,D,G |- e : @bool, d
-------------------[Not]
S,D,G |- !e : @bool, d
~

~ Infer
S,D,G |- e : @bit<w>, d
-----------------------------[Bitwise-Not]
S,D,G |- {\texttt{\textasciitilde}e} : @bit<w>, d
~

~ Infer
S,D,G |- e : t, d
@numeric(t)
--------------------[Negate]
S,D,G |- {-e} : t, d
~

### Binary Operations

```haskell
  fun binaryDir In In = In
    | binaryDir _  _  = none
```

~ Infer
S,D,G |- e_1 : @bool, d_1
S,D,G |- e_2 : @bool, d_2
\diamond \in \{ \&\&, || \}
------------------------------------------------------------------[Bool-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int, d_1
S,D,G |- e_2 : @int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
--------------------------------------------------------[Int-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int<w>, d_1
S,D,G |- e_2 : @int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
-----------------------------------------------------------[Int-Signed-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int<w>, @binaryDir(d_1, d_2)
~

<!--
having trouble with ^ symbol for xor
-->

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2 : @bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
----------------------------------------------------------[Int-Unsigned-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bit<w>, @binaryDir(d_1, d_2)
~

<!--
need to define has_equality
-->

~ Infer
S,D,G |- e_1 : t, d_1
S,D,G |- e_2 : t, d_2
\mathkw{has\_equality}(t)
\diamond \in \{ ==,!= \}
----------------------------------------------------------[Equality-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @bit<l>, d_1
S,D,G |- e_2 : @bit<r>, d_2
---------------------------------[Bit-Concat-Op]
S,D,G |- e_1 \mathbin{++} e_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : t_1, d_1
S,D,G |- e_2 : t_2, d_2
@numeric(t_1)
t_2 = @bit<\_> \lor t_2 = @int
\diamond \in \{\ll, \gg\}
---------------------------------[Shift-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : t_1, @binaryDir(d_1, d_2)
~

### Casts

Casting from $\tau_0$ to $\tau$ is permitted by the
$\tau \prec \tau'$ judgment.

The equality sign here hasn't been defined and probably won't make
sense without adding a context for looking up variables and type
names.
~ Infer
t = t'
-------------------------------------------[]
t \mathrel{\prec} t'
~

~ Infer

---------------------[]
@int \mathrel{\prec} @int<w>
~
~ Infer

---------------------[]
@int \mathrel{\prec} @bit<w>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @tuple<t_1, \dots, t_n>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @header \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @struct \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
t \mathrel{\prec} @enum t X \{m_1, ..., m_n\}
~

~ Infer

-------------------------------------------[]
@enum t X \{m_1, ..., m_n\} \mathrel{\prec} t
~

~ Infer

-------------------------------[]
@newtype X t \mathrel{\prec} t
~

~ Infer

-------------------------------[]
t \mathrel{\prec} @newtype X t
~

~ Infer
S,D,G |- e : t_0, d
t_0 \prec t
------------------------[Cast]
S,D,G |- (t) e : t, d
~

### Member expressions
~ Infer
D(X) = @enum t X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Serializable-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
D(X) = @enum X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
G(@error.name) = @error
-------------------------------------[Error-Member]
S,D,G |- @error.name : error, @none
~

Field and method lookups on expressions are delegated to another
judgment $\mathkw{has\_field}\ t\ name\ t_{name}$.
~ Infer
S,D,G, |- e : t
\mathkw{has\_field} t name t_{name}
------------------------------------[Expression-Member]
S,D,G |- e.name : t_{name}
~

~ Infer

---------------------------------------------------------------------[Header-Field]
\mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

--------------------------------------------------------------------------------[Header-Union-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

-------------------------------------------------------------------[Struct-Field]
\mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

---------------------------------------------------------------------------------[Header-IsValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~

~ Infer

---------------------------------------------------------------------------------[Header-SetValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setValid (() -> @void)
~

~ Infer

-----------------------------------------------------------------------------------[Header-SetInvalid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setInvalid (() -> @void)
~

~ Infer

---------------------------------------------------------------------------------------------[HeaderUnion-IsValid-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~


~ Infer

--------------------------------------------------------------------------------[Control-Apply-Field]
\mathkw{has\_field} (@control \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Parser-Apply-Field]
\mathkw{has\_field} (@parser \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Table-Apply-Field]
\mathkw{has\_field} (@table X) @apply (() -> X)
~

~ Infer

-------------------------------------------------------------------[Array-Size-Field]
\mathkw{has\_field} t[a] @size @bit<32>
~

~ Infer

-------------------------------------------------------------------[Array-NextIndex-Field]
\mathkw{has\_field} t[a] @nextIndex @bit<32>
~

~ Infer

-------------------------------------------------------------------[Array-LastIndex-Field]
\mathkw{has\_field} t[a] @lastIndex @bit<32>
~

~ Infer

-------------------------------[Array-Next-Field]
\mathkw{has\_field} t[a] @next t
~

~ Infer

-------------------------------[Array-Last-Field]
\mathkw{has\_field} t[a] @last t
~

~ Infer

-------------------------------[Array-PushFront-Field]
\mathkw{has\_field} t[a] \mathkw{push\_front} ((count: @int) -> @void)
~

~ Infer

-------------------------------[Array-PopFront-Field]
\mathkw{has\_field} t[a] \mathkw{pop\_front} ((count: @int) -> @void)
~


### Ternary Expression

~ Infer
S,D,G |- e_1 : @bool, \_
S,D,G |- e_2 : t, \_
S,D,G |- e_3 : t, \_
--------------------------------[Ternary-Op]
S,D,G |- e_1 ? e_2 : e_3 : t, @none
~

### Function Calls
TODO: Check directions
TODO: Handle overloads of extern functions
~ Infer
S,D,G |- f : f<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
P,S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
----------------------------------------------------------------------------[Function-Call-Nameless]
S,D,G |- f<\overline{\rho}>(\overline{e}):\tau_{\mathsf{ret}}, @none
~

~ Infer
S,D,G |- f : @function<...,X_i,...>(...,x_j:\tau_j,...) : \tau, \_
\forall j, \, S,D[\overline{X \to \rho}],G \vdash e_j:t_j
----------------------------------------------------------------------------[Function-Call-Named]
\Pi,\Gamma,\Delta |- f<...,\tau_i,...>(...,x_j=e_j,...) : \tau,@none
~

### Nameless Instantiation

We need a function to resolve overloads.
~ Infer
t_{ctor} = @constructor<\overline{X}>(\overline{x:t}): t
@length \overline{x:t} = n
X:t_{ctor} \in G
---------------------------------------------------------[Resolve-Constructor-Overload]
\mathkw{resolve\_overload} G X n = t_{ctor}
~

~ Infer
@length \overline{e} = n
@length \overline{\rho} = @length \overline{X}
\mathkw{resolve\_overload} G Y n = @constructor<\overline{X}>(\overline{x:t}): t_{ret}
S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
--------------------------------------------------------------------[Specialized-Type-Instantiation]
S,D,G |- Y<\overline{\rho}>(\overline{e}) : t_{ret}[\overline{\rho/X}]
~

~ Infer
S,D,G |- X<>(\overline{e}) : t
----------------------------------[Simple-Type-Instantiation]
S,D,G |- X(\overline{e}) : t
~

### Set Operations

TODO: the Masks rule is based off of the spec
and diverges from the type checker's implementation

~ Infer
S,D,G |- e_1 : @bit<w>, \_
S,D,G |- e_2 : @bit<w>, \_
------------------------------------------------[Masks]
S,D,G |- e_1 \texttt{\&\&\&} e_2 : @set<@bit<w>>,@none
~

~ Infer
S,D,G |- e_1 : \tau, \_
S,D,G |- e_2 : \tau, \_
\tau = @bit<w> \lor \tau = @int<w>
-------------------------[Ranges]
S,D,G |- e_1\mathbin{..}e_2 : @set<\tau>, @none
~

## Statement typing

Statements are typed by a judgment of the form
~ MathPre
S,D,G,ctx |- s:sig -| G'.
~

The judgment is defined inductively by the following rules.

~ Infer
S,D,G |- e<t_1,\dots,t_n>(e_1,\dots,e_m):t
-------------------------------------------------------[Type-Stmt-Method-Call]
S,D,G,ctx |- e<t_1,\dots,t_n>(e_1,\dots,e_m):\bot -| G
~

~ Infer
\mathkw{lvalue}(e_l)
S,D,G |- e_l: t
S,D,G |- e_r: t
----------------------------[Type-Stmt-Assignment]
S,D,G,ctx |- e_l:=e_r:\bot -| G
~

~ Infer
S,D,G |- t().@apply(\overline{e}) : t'
----------------------------------------------[Type-Stmt-Direct-Application]
S,D,G,ctx |- t.@apply(\overline{e}):bot -| G
~

The $\wedge{}$ operator is $\mathkw{returns}$ if both of its arguments
are $\mathkw{returns}$ and $\bot$ otherwise. The $\vee{}$ operator is
$\mathkw{returns}$ if any of its arguments are $\mathkw{returns}$
and $\bot$ otherwise.
~ Infer
S,D,G |- e:@bool
S,D,G,ctx |- s_1:sig_1 -| G_1
S,D,G,ctx |- s_2:sig_2 -| G_2
----------------------------------------------[Type-Stmt-Conditional]
S,D,G,ctx |- @if (e) s_1 @else s_2:sig_1\wedge{}sig_2 -| G
~

We need another judgment for typing sequences $\overline{s}$ of
statements. (Sorry about the empty sequence notation in the first
rule...)

~ Infer

---------------------------------------------------[Type-Stmts-Empty]
S,D,G,ctx |- \overline{  } :\bot -| G
~

~ Infer
S,D,G,ctx  |- s:sig_1 -| G'
S,D,G',ctx |- \overline{s}:sig_2 -| G'
---------------------------------------------------[Type-Stmts-List]
S,D,G,ctx |- s;\overline{s}:sig_1 \vee sig_2 -| G
~

~ Infer
S,D,G,ctx |- \overline{s}:sig -| G'
---------------------------------------------------[Type-Stmt-Block]
S,D,G,ctx |- \{\overline{s}\}:sig -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Exit]
S,D,G,@InParserState |- @exit:@returns -| G
~

~ Infer

------------------------------------------[Type-Stmt-Empty]
S,D,G,ctx |- \mathkw{;}:\bot -| G
~

~ Infer
S,D,G |- e:t
---------------------------------------------------[Type-Stmt-Return-Value]
S,D,G,@InFunction t |- @return e:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Void]
S,D,G,@InFunction @void |- @return:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Control]
S,D,G,@InControl |- @return:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Action]
S,D,G,@InAction |- @return:@returns -| G
~

~ Infer
S,D,G |- case\_lbl : \tau
S,D,G,@InControl |- blk:sig -| G'
---------------------------------------------------[Type-Case-Block]
S,D,G |- \mathkw{case\_ok}_\tau (case\_lbl:blk)
~

~ Infer
S,D,G |- case\_lbl : \tau
---------------------------------------------------[Type-Case-Fallthrough]
S,D,G |- \mathkw{case\_ok}_\tau (case\_lbl:{})
~

There isn't a real reason to track signals in controls, seeing as
controls only return void and there's no way for an apply block that
typechecks in all other respects to fail to not return a value. Seeing
as switch statements can only appear in controls, this rule just
assigns them the signal $\bot$ to avoid having to track signals in
each case and across fallthrough cases.
~ Infer
S,D,G |- e : @enum X \{ \overline{m} \}
\forall i. S,D,G |- \mathkw{case\_ok}_X case_i
--------------------------------------------------------------------------[Type-Stmt-Switch]
S,D,G,@InControl |- @switch (e) \{ case1, \dots, case_n \}:\bot -| G
~

TODO: DeclarationStatements don't need to exist, see
https://github.com/cornell-netlab/petr4/issues/5

The implementation makes sure decl is a constant, instantiation, or
variable, this rule doesn't bother.
~ Infer
S,D,G |- decl -| S',D',G'.
---------------------------------------------------[Type-Stmt-Declaration-Statement]
S,D,G,ctx |- decl:\bot -| G'
~

## Parser state typing

Parser states need their own typing judgment to deal with state-machine control flow. It has the form
~ MathPre
S,D,G,K |- state,
~
where K is a list of names of states used to check that the parser's
transitions make sense. It is defined by two rules, which use another
judgement $\mathkw{state\_expr\_ok}$.

~ Infer
S,D,G,K |- \mathkw{state\_expr\_ok} state\_expr
------------------------------------------------------[Type-State-Transition]
S,D,G,K |- @state x \{ ; @transition state\_expr \}
~

~ Infer
S,D,G |- s0 -| G'
S,D,G' |- \{ \overline{s}; @transition state\_expr \}
----------------------------------------------------------[Type-State-Statement]
S,D,G,K |- @state x \{ s0; \overline{s}; @transition state\_expr \}
~

The $\mathkw{state\_expr\_ok}$ judgment is defined by the following rules.
~ Infer
x\in{}K
-----------------------------------------------[State-Expr-OK-Direct]
G,K |- \mathkw{state\_expr\_ok} x
~

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{\mathkw{match\_ok} t match}
\overline{x\in{}K}
-----------------------------------------------[State-Expr-OK-Select]
S,D,G,K |- \mathkw{state\_expr\_ok} @select (\overline{e}) \{ \overline{\overline{match}:x} \}
~

TODO: there should be implicit casts inserted in matches so that they always have set type.
TODO: Should matches be a separate kind of expression, or should we fold them into one type?
~ Infer
S,D,G |- e : @set t_m
t_m = t
----------------------------------------[Match-OK-Expr]
S,D,G |- \mathkw{match\_ok} t e
~

~ Infer

-------------------------------------------[Match-OK-DontCare]
S,D,G |- \mathkw{match\_ok} t \mathkw{\_}
~

## Declaration typing

Declarations are typed by a judgment of the form
~ MathPre
S,D,G |- decl -| S',D',G'.
~

It is defined inductively by the following rules.

~ Infer
S,D,G |- e:t
S, e \Downarrow v
--------------------------------------------[Type-Decl-Const]
S,D,G |- @const x := e -| S[x = v],D,G
~

~ Infer
S,D,G |- t(\overline{e}) : t_{inst}
-----------------------------------[Type-Decl-Instantiation]
S,D,G |- t x(\overline{e}) -| S,D,G[x:t_{inst}]
~

The function $\mathkw{names}(s_1, s_2, \dots)$ takes a list of states
and returns a list of their names.

~ Infer
K = @names(\overline{state}),@accept,@reject
@start \in K
S,D,G[\overline{x^{ctor}:t^{ctor}}][\overline{x:t}] |- \overline{decl} -| S',D',G'
S',D',G',K |- \overline{state}
t_{ctor} = @constructor(\overline{x^{ctor}:t^{ctor}}):@parser(\overline{x:t})
-------------------------------------------------------------------------------------------------------------[Type-Decl-Parser]
S,D,G |- @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} -| S,D,G[X:t_ctor]
~

~ Infer
S,D,G[\overline{x^{ctor}:t^{ctor}}][\overline{x:t}] |- \overline{decl} -| S',D',G'
S',D',G',@void |- blk -| G''
t_{ctor} = @constructor(\overline{x^{ctor}:t^{ctor}}):@control(\overline{x:t})
-------------------------------------------------------------------------------------------------------------------[Type-Decl-Control]
S,D,G |- @control X(\overline{x: t})(\overline{x^{ctor}:t^{ctor}}) \{ \overline{decl} @apply blk \} -| S,D,G[X:t_ctor]
~

~ Infer
S,D[\overline{X=X}],G[\overline{x:t}],t |- blk -| G_{blk}
G' = G[x:@function<\overline{X}>(\overline{x: t}) : t]
----------------------------------------------------[Type-Decl-Function]
S,D,G |- @function t x<\overline{X}>(\overline{x: t}) blk -| S,D,G'
~

~ Infer
G' = G[x:@function<\overline{X}>(\overline{x: t}) : t]
---------------------------------------------------------------[Type-Decl-Extern-Function]
S,D,G |- \mathkw{extern\ function} t x<\overline{X}>(\overline{x: t}) blk -| S,D,G'
~

~ Infer
t x := e
--------------------------------[Type-Decl-Variable]
S,D,G |- t x -| S,D,G[x:t]
~

~ Infer
S,D,G |- e:t
-------------------------------------[Type-Decl-Variable-Initialized]
S,D,G |- t x := e -| S,D,G[x:t]
~

~ Infer

-------------------------------------------------------[Type-Decl-Value-Set]
S,D,G |- \mathkw{value\_set}<t>(e) x -| S,D,G[x:@set t]
~

~ Infer
S,D[\overline{X=X}],G[\overline{x:t}],t |- blk -| G_{blk}
G' = G[x:@action<\overline{X}>(\overline{x:t,d0},\overline{x:t})]
-------------------------------------------------------------------------------[Type-Decl-Action]
S,D,G |- @action x<\overline{X}>(\overline{x:t,d_0},\overline{x:t}) blk -| S,D,G'
~

### Table Typing

Table properties get their own judgment
~ MathPre
S,D,G; K,A |- prop -| K',A'
~
Where $K$ is defined as the types of keys defined in the table, and $A$ is defined as the names and types of actions in the table.

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{x:\mathkw{match\_kind}}
------------------------------------------------------------------------------[Type-Prop-Keys]
S,D,G; \{\},\{\} |- @key = \{ \overline{e:x} \} -| \{\overline{\tau}\},\{\}
~

~Infer
P(x_a) = @action x_a (\overline{x:t,d_0},\overline{x:t}) blk
S,D,G |- \overline{e:t}
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Actions]
S,D,G; K,\{\} |- @actions = \{ \overline{x_a(\overline{e})} \} -| K,\{\overline{x_a:@action(\overline{x:t,d_0}, \overline{x:t}) : @void}\}
~

~ Infer
S,D,G |- \overline{e_m : t_k}
A(x_a) = @action (\overline{x:t,d_0},\overline{x:t}) @void
S,D,G |- \overline{e_a : t}
---------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Entries]
S,D,G; \{\overline{t_k}\},A |- @const @entries = \{ \overline{\overline{e_m}:x_a(\overline{e_a})} \} -| \{\overline{t_k}\},A
~

~ Infer
x \in A
---------------------------------------------------[Type-Prop-Default]
S,D,G,K,A |- \mathkw{default\_action}=x -| K,A
~

~ Infer
S,D,G,\{\},\{\} |- \overline{prop} -| K,\{\overline{x_a:@action(\overline{x:t,d_0}, \overline{x:t}) : @void}\}
D' = D[``action\_list\_<x>" \to @enum ``action\_list\_<x>" \{ \overline{x_a} \}]
D'' = D'[``apply\_result\_<x>" \to @struct \{ ``hit" : @bool; ``action\_run" : @enum ``action\_list\_<x>" \{ \overline{x_a} \} \}]
---------------------------------------------------[Type-Decl-Table]
S,D,G |- @table x \{ \overline{prop} \} -| S,D,G[x \to @table ``apply\_result\_<x>"]
~


### Header and struct typing
~ Infer

-----------------------------------------------------------------------------------[Type-Decl-Header]
S,D,G |- @header X \{ \overline{x:t} \} -| S,D[X=@header \{ \overline{x:t} \}],G
~

~ Infer

----------------------------------------------------------------[Type-Decl-Header-Union]
S,D,G |- \mathkw{header\ union} X \{ \overline{x:t} \} -| S,D[X=\mathkw{header\ union} \{ \overline{x:t} \}],G
~

~ Infer

-------------------------------------------------------------------[Type-Decl-Struct]
S,D,G |- @struct X \{ \overline{x:t} \} -| S,D[X=@struct \{ \overline{f:t} \}],G
~

~ Infer
\overline{@error.x \notin G}
-----------------------------------------------------------[Type-Decl-Error]
S,D,G |- @error \{ \overline{x} \} -| S,D,G[\overline{@error.x:@error}]
~

~ Infer
\overline{.x \notin G}
---------------------------------------------------[Type-Decl-Match-Kind]
S,D,G |- \mathkw{match\_kind} \{ \overline{x} \} -| S,D,G[\overline{.x:\mathkw{match\_kind}}]
~

~ Infer
D' = D[X=@enum t X \{ \overline{x} \}]
\overline{e} \Downarrow \overline{v}
---------------------------------------------------[Type-Decl-Enum]
S,D,G |- @enum t X \{ \overline{x=e} \} -| S[\overline{x=v}],D,G
~

~ Infer
D' = D[X=@enum X \{ \overline{x} \}]
---------------------------------------------------[Type-Decl-Serializable-Enum]
S,D,G |- @enum X \{ \overline{x} \} -| S,D,G
~

~ Infer
\forall{}ctor_i=X(\overline{x:t}). {t_{ctor}}_i = @constructor<\overline{X}>(\overline{x_i:t_i}) : t_{extern}
t_{extern} = @extern X \{ \overline{method} \}
---------------------------------------------------[Type-Decl-Extern-Object]
S,D,G |- @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \} -| S,D,G[\overline{X:t_{ctor}}]
~

~ Infer

---------------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @typedef t X -| S,D[X=t],G
~

~ Infer

---------------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @newtype t X -| S,D[X=@newtype X t],G
~

~ Infer
D'=D[X=@control<\overline{X}>(\overline{x:t,d})
--------------------------------------------------------------------[Type-Decl-Control-Type]
S,D,G |- @control X<\overline{X}>(\overline{x:t,d}) -| S,D',G
~

~ Infer
D'=D[X=@parser<\overline{X}>(\overline{x:t,d})
---------------------------------------------------[Type-Decl-Parser-Type]
S,D,G |- @parser X<\overline{X}>(\overline{x:t,d}) -| S,D',G
~

~ Infer
D'=D[X=@package<\overline{X}>(\overline{x:t})
-----------------------------------------------------------------[Type-Decl-Package-Type]
S,D,G |- @package X<\overline{X}>(\overline{x:t}) -| S,D',G
~

## Typing of programs
Partial programs are checked by a judgment of the form
~ MathPre
S,D,G |- P0 -| S',D',G'.
~
Complete programs are checked by giving empty contexts on the left.

The judgment only needs two rules.

~ Infer

--------------------------[]
S,D,G |- [] -| S,D,G
~

~ Infer
S,D,G |- decl -| S',D',G'
S',D',G' |- P0 -| S'',D'',G''
------------------------------------[]
S,D,G |- decl, P0 -| S'',D'',G''
~

# Dynamic Semantics { #sec-dynamic }

## Contexts
All evaluation rules include

1. $\zeta$, a representation of the control plane
2. $\xi$, an evaluation context
3. $\sigma$, TODO: Target.st? 

The control plane representation contains table entries and value sets. Since
tables already populated with constant entries are immutable, the representation
of the control plane treats entries like constant entries.

$\zeta ::= (\overline{\mathkw{const\ entries}}, \overline{set})$

TODO: $\xi$ needs something like $P$, $\Gamma$, and $\Sigma$ (but for var-value mappings).
But can all of these be represented by one $\xi$ or does it need to be split out
like Ryan did in typing contexts.

$\mathkw{push} \xi$ pushes an empty first-level scope onto $\xi$. $\mathkw{pop \xi}$ pops the first-level scope off $\xi$ if one exists.

## Helper rules

<!-- Didn't know how to combine all these into one rule so I did something similar to numeric typing
~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', a>
-------------------------------------------------------------------------------[Extract-Int]
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', a>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', {a}_u^{n}>
-------------------------------------------------------------------------------[Extract-Unsigned-Int]
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', a>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', {a}_s^{n}>
-------------------------------------------------------------------------------[Extract-Signed-Int]
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', a>
~
-->

### Numeric Values
~ MathPre
\mathkw{extract\_num} <\zeta, \xi, \sigma, e> = \begin{cases} <\xi', \sigma', a> & <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', a>
<\xi', \sigma', a> & <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', {a}_u^{n}>
<\xi', \sigma', a> & <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', {a}_s^{n}>
\end{cases}
~

### Copy-In/Copy-Out

~ MathPre
\mathkw{copyin} \xi (d, t, v1, e_{opt}) v2 = \begin{cases} \mathkw{push} \xi & d = @out
(\mathkw{push}\xi)[v2/v1] & otherwise
\end{cases}
~

<!--
~ MathPre
\mathkw{insert\_arg} \xi (d, t, v1, e_{opt}) v2 = \begin{cases} \xi & d = \mathkw{out}
\xi[v2/v1] & otherwise
\end{cases}
~

- type also gets inserted. mapped to v1
- weird business with headers

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', v2>
-------------------------------------------------------------------------------[CopyIn-Positional]
<\zeta, \xi, \sigma, (d, t, v1, e_{opt}), e> \Downarrow <\mathkw{insert\_arg} \xi' (d, t, v1, e_{opt}) v2, \sigma'>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', v2>
-------------------------------------------------------------------------------[CopyIn-Named]
<\zeta, \xi, \sigma, (d, t, v1, e_{opt}), x = e> \Downarrow <\mathkw{insert\_arg} \xi' (d, t, v1, e_{opt}) v2, \sigma'>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', v2>
-------------------------------------------------------------------------------[CopyIn-Missing-Opt]
<\zeta, \xi, \sigma, (d, t, v1, @Some e), ()> \Downarrow <\mathkw{insert\_arg} \xi' (d, t, v1, @Some e) v2, \sigma'>
~

~ Infer
TODO
-------------------------------------------------------------------------------[CopyIn-Missing-NoOpt]
<\zeta, \xi, \sigma, (d, t, v1, @None), ()> \Downarrow TODO
~

~ Infer
<\zeta, @push \xi, \sigma, p1, {arg}_1> \Downarrow <\xi', \sigma'>
\dots
<\zeta, \xi^{n-1}, \sigma^{n-1}, p_n, {arg}_n> \Downarrow <\xi^n, \sigma^n>
----------------------------------------------------------------------[CopyIn]
<\zeta, \xi, \sigma, \overline{p}, \overline{arg}> \Downarrow <\xi^n, \sigma^n>
~
-->

~ MathPre
\mathkw{copyout} \xi (d, t, v, e_{opt}) e = \begin{cases} \mathkw{pop} \xi & d = @in
\mathkw{pop} \xi & d = @none \land \xi(X) \neq @extern X \dots
\mathkw{pop} \xi & d = @none \land \xi(.X) \neq @extern X \dots
TODO: eval_assign' (\mathkw{pop} \xi)[\xi(v)/lvalue of e] & otherwise
\end{cases}
~

<!--
~ MathPre
\mathkw{copy\_arg\_out} \zeta \xi \sigma v arg = \begin{cases} \xi & arg = ()
TODO: eval_assign' so something like e := v where e is from the arg ßbut that doesn't seem right & otherwise
\end{cases}
~

~ Infer
\xi_1(X) = @extern X \dots
----------------------------------------------------------------------[NoDir-Extern-TypeName]
<\zeta, \xi_1, \xi_2, \sigma, (@none, X, v, e_{opt}), arg> \Downarrow \mathkw{copy\_arg\_out} \zeta \xi_1 \sigma \xi_2(v) arg 
~

~ Infer
\xi_1(.X) = @extern X \dots
----------------------------------------------------------------------[NoDir-Extern-TopLevelType]
<\zeta, \xi_1, \xi_2, \sigma, (@none, .X, v, e_{opt}), arg> \Downarrow \mathkw{copy\_arg\_out} \zeta \xi_1 \sigma \xi_2(v) arg 
~

~ Infer
\xi_1(X) \neq @extern X \dots
----------------------------------------------------------------------[NoDir-TypeName]
<\zeta, \xi_1, \xi_2, \sigma, (@none, X, v, e_{opt}), arg> \Downarrow \xi_1
~

~ Infer
\xi_1(.X) \neq @extern X \dots
----------------------------------------------------------------------[NoDir-TopLevelType]
<\zeta, \xi_1, \xi_2, \sigma, (@none, .X, v, e_{opt}), arg> \Downarrow \xi_1
~

~ Infer

----------------------------------------------------------------------[Dir-In]
<\zeta, \xi_1, \xi_2, \sigma, (@in, t, v, e_{opt}), arg> \Downarrow \xi_1
~

~ Infer

----------------------------------------------------------------------[Dir-InOut]
<\zeta, \xi_1, \xi_2, \sigma, (@inout, t, v, e_{opt}), arg> \Downarrow \mathkw{copy\_arg\_out} \zeta \xi_1 \sigma \xi_2(v) arg 
~

~ Infer

----------------------------------------------------------------------[Dir-Out]
<\zeta, \xi_1, \xi_2, \sigma, (@out, t, v, e_{opt}), arg> \Downarrow \mathkw{copy\_arg\_out} \zeta \xi_1 \sigma \xi_2(v) arg 
~

~ Infer
<\zeta, @pop \xi, \xi, \sigma, p1, {arg}_1> \Downarrow \xi'
\dots
<\zeta, \xi^{n-1}, \xi, \sigma^{n-1}, p_n, {arg}_n> \Downarrow \xi^n
----------------------------------------------------------------------[CopyOut]
<\zeta, \xi, \xi, \sigma, \overline{p}, \overline{arg}> \Downarrow \xi^n
~
-->

## Expressions

Expressions are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', v \rangle$
~

TODO: need to add signals after clarifying some things

### Constants

~ Infer

-------------------------------------------------------------------------------[Bool-True]
<\zeta, \xi, \sigma, true> \Downarrow_e <\xi, \sigma, true>
~

~ Infer

-------------------------------------------------------------------------------[Bool-False]
<\zeta, \xi, \sigma, false> \Downarrow_e <\xi, \sigma, false>
~

~ Infer

-------------------------------------------------------------------------------[Int-Constant]
<\zeta, \xi, \sigma, a> \Downarrow_e <\xi, \sigma, a>
~

~ Infer

-------------------------------------------------------------------------------[Unsigned-Int-Constant]
<\zeta, \xi, \sigma, nwa> \Downarrow_e <\xi, \sigma, a_u^n>
~

~ Infer

-------------------------------------------------------------------------------[Signed-Int-Constant]
<\zeta, \xi, \sigma, nsa> \Downarrow_e <\xi, \sigma, a_s^n>
~

~ Infer

-------------------------------------------------------------------------------[String]
<\zeta, \xi, \sigma, u> \Downarrow_e <\xi, \sigma, u>
~

### Variables

~ Infer
x \neq @verify
-------------------------------------------------------------------------------[Var]
<\zeta, \xi, \sigma, x> \Downarrow_e <\xi, \sigma, \xi(x)>
~

~ Infer

-------------------------------------------------------------------------------[Var-Verify]
<\zeta, \xi, \sigma, @verify> \Downarrow_e <\xi, \sigma, @builtin @verify>
~

~ Infer

-------------------------------------------------------------------------------[Var-Top]
<\zeta, \xi, \sigma, .x> \Downarrow_e <\xi, \sigma, \xi(.x)>
~

### Accesses

~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', (\dots,v_i,\dots,n_{size},n_{next})>
\mathkw{extract\_num} <\zeta, \xi', \sigma', e2> = <\xi'', \sigma'', a>
i = a \% n_{size}
-------------------------------------------------------------------------------[Array-Access]
<\zeta, \xi, \sigma, e1[e2]> \Downarrow_e <\xi'', \sigma'', v_i>
~

<!-- not sure if this is valid -->
~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', v1>
<\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', v2>
<\zeta, \xi'', \sigma'', e3> \Downarrow_e <\xi''', \sigma''', v3>
w = v2 - v3 + 1
n = v1 \% 2^{v2+1}
if v3 \leq 0 then r = (n_u^w) else r = v1/2[v2-1:v3-1]
-------------------------------------------------------------------------------[Bitslice]
<\zeta, \xi, \sigma, e1[e2:e3]> \Downarrow_e <\xi''', \sigma''', r>
~

~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', v1>
\dots
<\zeta, \xi^{n-1}, \sigma^{n-1}, e_n> \Downarrow_e <\xi^n, \sigma^n, v_n>
-------------------------------------------------------------------------------[List-Expression]
<\zeta, \xi, \sigma, {e1,\dots,e_n}> \Downarrow_e <\xi^n, \sigma^n, (v1,\dots,v_n)>
~

### Unary Operations

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', v>
\diamond \in \{ !, \texttt{\textasciitilde}, - \}
-------------------------------------------------------------------------------[Unary-Op]
<\zeta, \xi, \sigma, \diamond e> \Downarrow_e <\xi', \sigma', \diamond v>
~

### Binary Operations

~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', v1>
<\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', v2>
\diamond \in \{ +, |+|, -, |-|, *, /, \%, \ll, \gg, \lt, \gt, \leq, \geq, ==, !=, \&, \hat{}, |, ++, \&\&, || \}
-------------------------------------------------------------------------------[Binary-Op]
<\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', v1 \diamond v2>
~

### Casts
~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', 1_u^1>
-------------------------------------------------------------------------------[Bool-Cast-True]
<\zeta, \xi, \sigma, (bool) e> \Downarrow_e <\xi', \sigma', true>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', n_u^1>
n \neq 1
-------------------------------------------------------------------------------[Bool-Cast-False]
<\zeta, \xi, \sigma, (bool) e> \Downarrow_e <\xi', \sigma', false>
~

$\mathkw{of2s}(a)$ is the result of converting $a$ from two's complement while $\mathkw{to2s}(a)$ is the result of converting $a$ to two's complement.

~ Infer
\mathkw{extract\_num} <\zeta, \xi, \sigma, e1> = <\xi', \sigma', a1>
\mathkw{extract\_num} <\zeta, \xi', \sigma', e2> = <\xi'', \sigma'', a2>
-------------------------------------------------------------------------------[Bit-Cast]
<\zeta, \xi, \sigma, (bit\lt e2\gt) e1> \Downarrow_e <\xi'', \sigma'', {@of2s(a1)}_u^{a2}>
~

~ Infer
\mathkw{extract\_num} <\zeta, \xi, \sigma, e1> = <\xi', \sigma', a1>
\mathkw{extract\_num} <\zeta, \xi', \sigma', e2> = <\xi'', \sigma'', a2>
-------------------------------------------------------------------------------[Int-Cast]
<\zeta, \xi, \sigma, (int\lt e2\gt) e1> \Downarrow_e <\xi'', \sigma'', {@to2s(a1)}_s^{a2}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', v>
-------------------------------------------------------------------------------[TypeName-Cast]
<\zeta, \xi, \sigma, (X) e> \Downarrow_e <\xi', \sigma', v>
~

~ Infer
TODO: how to differentiate value and set
----------------------------------------------------------------[Set-Cast-Singleton]
<\zeta, \xi, \sigma, (set) v> \Downarrow_e <\xi, \sigma, >
~

<!--
~ Infer

----------------------------------------------------------------[Set-Cast-Product]
<\zeta, \xi, \sigma, (set) (\overline{v})> \Downarrow_e <\xi, \sigma, >
~
-->

### Member Expressions

~ Infer
\xi(X) = @enum X \{\dots,name,\dots\}
-------------------------------------------------------------------------------[Type-Member-Enum]
<\zeta, \xi, \sigma, X.name> \Downarrow_e <\xi, \sigma, X.name>
~

~ Infer
\xi(X) = @enum t X \{\dots,(name, e),\dots\}
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', v>
-------------------------------------------------------------------------------[Type-Member-SEnum]
<\zeta, \xi, \sigma, X.name> \Downarrow_e <\xi', \sigma', (X.name, (t) v)>
~

~ Infer

-------------------------------------------------------------------------------[Error-Member]
<\zeta, \xi, \sigma, @error.name> \Downarrow_e <\xi, \sigma, @error.name>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', @struct \{\dots,(name, v),\dots\}>
-------------------------------------------------------------------------------[Struct-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (@header \{ \dots,(name, v),\dots \}, b)>
-------------------------------------------------------------------------------[Header-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (@header \{ \dots \}, b)>
-------------------------------------------------------------------------------[Header-IsValid-Field]
<\zeta, \xi, \sigma, e.@isValid> \Downarrow_e <\xi', \sigma', @builtin @isValid>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (@header \{ \dots \}, b)>
-------------------------------------------------------------------------------[Header-SetValid-Field]
<\zeta, \xi, \sigma, e.@setValid> \Downarrow_e <\xi', \sigma', @builtin @setValid>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (@header \{ \dots \}, b)>
-------------------------------------------------------------------------------[Header-SetInvalid-Field]
<\zeta, \xi, \sigma, e.@setInvalid> \Downarrow_e <\xi', \sigma', @builtin @setInvalid>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (\mathkw{header\ union} \{ \dots \}, v')>
-------------------------------------------------------------------------------[Header-Union]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', v'>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-Size-Field]
<\zeta, \xi, \sigma, e.@size> \Downarrow_e <\xi', \sigma', {n_{size}}_u^{32}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (\overline{v}, n_{size}, n_{next})>
n_{next} \lt n_{size}
-------------------------------------------------------------------------------[Array-Next-Field]
<\zeta, \xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', v_{n_{next}}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (\overline{v}, n_{size}, n_{next})>
1 \leq n_{next} \leq n_{size}
-------------------------------------------------------------------------------[Array-Last-Field]
<\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', v_{n_{next}}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-LastIndex-Field]
<\zeta, \xi, \sigma, e.@lastIndex> \Downarrow_e <\xi', \sigma', (n_{next} - 1)_u^{32}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-PopFront-Field]
<\zeta, \xi, \sigma, e.\mathkw{pop\_front}> \Downarrow_e <\xi', \sigma', @builtin \mathkw{pop\_front}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-PushFront-Field]
<\zeta, \xi, \sigma, e.\mathkw{push\_front}> \Downarrow_e <\xi', \sigma' @builtin \mathkw{push\_front}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', loc>
-------------------------------------------------------------------------------[Runtime]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', @extern name>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', @parser \dots>
-------------------------------------------------------------------------------[Parser-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', @builtin name>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', @control \dots>
-------------------------------------------------------------------------------[Control-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', @builtin name>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', @table \dots>
-------------------------------------------------------------------------------[Table-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', @builtin name>
~


### Ternary Expression

~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', true>
<\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', v2>
-------------------------------------------------------------------------------[Ternary-Op-True]
<\zeta, \xi, \sigma, e1 ? e2 : e3> \Downarrow_e <\xi'', \sigma'', v2>
~

~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', false>
<\zeta, \xi', \sigma', e3> \Downarrow_e <\xi'', \sigma'', v3>
-------------------------------------------------------------------------------[Ternary-Op-False]
<\zeta, \xi, \sigma, e1 ? e2 : e3> \Downarrow_e <\xi'', \sigma'', v3>
~

### Function Calls

~ Infer
TODO
-------------------------------------------------------------------------------[Function-Action-Positional]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[isValid]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[setValid]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[setInvalid]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[PopFront]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[PushFront]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[Apply]
TODO
~

TODO: what about extract, emit, length, lookahead, advance, verify? also externfun

### Nameless Instantiation

~ Infer
TODO
-------------------------------------------------------------------------------[Control]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[Parser]
TODO
~

~ Infer
TODO
-------------------------------------------------------------------------------[Package]
TODO
~

### Set Operations

~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', v1>
<\zeta, \xi', \sigma, e2> \Downarrow_e <\xi'', \sigma'', v2>
-------------------------------------------------------------------------------[Masks]
<\zeta, \xi, \sigma, e1 \texttt{\&\&\&} e2> \Downarrow_e <\xi'', \sigma'', v1 \texttt{\&\&\&} v2>
~

~ Infer
<\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', v1>
<\zeta, \xi', \sigma, e2> \Downarrow_e <\xi'', \sigma'', v2>
-------------------------------------------------------------------------------[Ranges]
<\zeta, \xi, \sigma, e1 \mathbin{..} e2> \Downarrow_e <\xi'', \sigma'', v1 \mathbin{..} v2>
~

## Statements and Blocks

Statements are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, s \rangle \Downarrow_s \langle \xi', \sigma', sig \rangle$
~

~ Infer
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------[Method-Call]
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_s <\xi', \sigma', sig>
~

~ Infer
TODO
---------------------------------------------[Assignment]
<\zeta, \xi, \sigma, e1 := e2> \Downarrow_s <TODO>
~

~ Infer
TODO
---------------------------------------------[Direct-Application]
<\zeta, \xi, \sigma, t.@apply (e1, ..., e_n)> \Downarrow_s <TODO>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v>
------------------------------------------------------------------------------[Conditional-Reject]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi', \sigma', \mathkw{sig\_reject\ v}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
<\zeta, \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig>
------------------------------------------------------------------------------[If-True]
<\zeta, \xi, \sigma, @if (e) s> \Downarrow_s <\xi'', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, false>
------------------------------------------------------------------------------[If-False]
<\zeta, \xi, \sigma, @if (e) s> \Downarrow_s  <\xi, \sigma, \mathkw{sig\_continue}>
~
TODO: why is it not the updated env and st

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
<\zeta, \xi', \sigma', s1> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-True]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi'', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, false>
<\zeta, \xi', \sigma', s2> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-False]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi'', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, s_1> \Downarrow_s <\xi', \sigma', sig'>
\dots
<\zeta, \xi^{n-1}, \sigma^{n-1}, s_n> \Downarrow_s <\xi^n, \sigma^n, sig^n>
-------------------------------------------------------------------------------------[Block]
<\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi^n, \sigma^n, sig^n>
~

~ Infer

---------------------------------------------------------------------[Exit-Continue]
<\zeta, \xi, \sigma, @exit> \Downarrow_s <\xi, \sigma, \mathkw{sig\_exit}>
~

~ Infer

---------------------------------------------[Empty]
<\zeta, \xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
~

~ Infer
TODO
---------------------------------------------[Return-Void]
<\zeta, \xi, \sigma, @return> \Downarrow_s <TODO>
~

~ Infer
TODO
---------------------------------------------[Return-Value]
<\zeta, \xi, \sigma, @return v> \Downarrow_s <TODO>
~

~ Infer
TODO
---------------------------------------------[Switch]
<\zeta, \xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <TODO>
~

~ Infer
TODO
---------------------------------------------[Declaration-Statement]
<\zeta, \xi, \sigma, decl> \Downarrow_s <TODO>
~
