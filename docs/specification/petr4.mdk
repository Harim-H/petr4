Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp
Package: mathtools
Package: xspace

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/( +)-\|( +)/\1\dashv{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG([^a-zA-Z])/\Gamma{}\1/g";
  replace: "/\bD([^a-zA-Z])/\Delta{}\1/g";
  replace: "/\bS([^a-zA-Z])/\Sigma{}\1/g";
  replace: "/\bt([^a-z])/\tau{}\1/g";
  replace: "/</\langle{}/g";
  replace: "/>/\rangle{}/g";
  replace: "/\b:=\b/\coloneqq{}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

p4mathgrammar {
  replace:"/\/\/(.*)/\/\/ &\text{\1}/g";
  replace: "~ Begin P4MathGrammarBlock&nl;\
                 ~ Begin MathPre&nl;&source;&nl;~ End MathPre&nl;\
                 ~ End P4MathGrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Value Syntax

~ Begin P4MathGrammar
v\in{}@Val::=\text{TODO once exprs stop changing so much}
~ End P4MathGrammar

## Expression Syntax

~ Begin P4MathGrammar
e\in{}@Expr::=@true | @false                 // boolean literals
  | a                              // arbitrary width integer literal
  | w\mathkw{w}a                   // unsigned int of width w
  | \{\overline{e}\}               // tuple
  | \{\overline{name=e}\}          // record
  | @header \{\overline{name=e}\}  // header
  | match                          // set
  | @error.x                       // error values
  | @matchkind.x                   // matchkind values
  | (t)e                           // explicit cast
  | x                              // variable
  | e.name                         // expression member
  | f<\overline{t}>(\overline{e})  // function call
  | t<\overline{t}>(\overline{e})  // nameless instantiation
  | @externfn \ell{} name                                            // extern functions
  | @extern name \ell                                           // extern objects
  | @builtin e name                                              // builtin functions
  | @stack_n n \overline{v}                                      // stacks
  | \lambda_p(\overline{x:t,d}).\overline{state}                 // parser objects
  | \lambda_c(\overline{x:t,d}).blk                              // control objects
  | @package(\overline{name=v})                                  // package objects
  | \lambda_{ctor}(\overline{x:t}).blk                           // constructor closures
  | (N,E)\otimes{}e                                            // closures
  | @table(\overline{\tau:@matchkind.x})\{\overline{match:aref}\}  // tables
  | @apply\{\overline{s}\}                                      // copy-in copy-out blocks
  | @parse\{state;\overline{state}\}                            // parser invocations

match ::= @singleton_t e      // singleton set
        | (\_)_{\tau}         // universal set for type $t$
    	| v\mathbin{\texttt{\&\&\&}}v // bitmask
        | \prod{}\overline{e} // finite set product
uop   ::= ... // unary operators
binop ::= ... // binary operators
aref::=x(\overline{e})
~ End P4MathGrammar

## Statement syntax
~ Begin P4MathGrammar
s ::= e<\overline{t}>(\overline{e})  // method call
    | \tau x                         // variable declaration
    | e := e                         // assignment
    | @if (e) s_1 @else s_2          // conditional statement
    | @exit                          // exit statement
    | @return                        // return (void)
    | @return e                      // return (with value)
    | @emp                           // empty statement
    | blk // blocks
    | @apply blk // copy-in copy-out blocks
    | @parse\{state;\overline{state}\}  // parser invocations
blk ::= \{\overline{s}\} // blocks
~ End P4MathGrammar

## Declaration Syntax
~ Begin P4MathGrammar
decl ::= t x // variable declaration
       | X(\overline{e}) x // instantiation
       | @parser X(\overline{x:t}) \{ \overline{decl} \lambda_P(\overline{x:t,d}).@parse \overline{state} \} // parser
       | @control X(\overline{x:t}) \{ \overline{decl} \lambda_C(\overline{x:t,d}).@do blk \} // control
       | @action a(\overline{x:t,d_0}).\lambda_A(\overline{x:t}).@apply blk // action
       | @function f<T>(\overline{x:t,d}).@do blk // function
       | @table x \{\overline{prop}\} // table
       | @error \{\overline{x}\} // error
       | \mathkw{match\_kind} \{\overline{x}\} // match\_kind
       | @extern X<\overline{X}> \{\overline{ctor}\ \overline{method}\} // extern class
       | @typedef t X // typedefs (transparent)
       | @type t X // newtypes (opaque)

state ::= @state x \{blk; @transition state\_expr\}

state\_expr ::= x
              | @select (\overline{e}) \{\overline{match:x}\}

ctor ::= @constructor<\overline{X}>(\overline{t})

method ::= @method t x<\overline{X}>(\overline{t,d})

prop ::= @key = \{\overline{e:x}\}
       | @actions = \{\overline{a\_ref}\}
       | @const @entries = \{\overline{e:a\_ref(\overline{e})}\}
       | x = e
       | @const x = e

a\_ref ::= x(\overline{e})
~ End P4MathGrammar

## Program Syntax
A program is a sequence of declarations.
~ Begin P4MathGrammar
P ::= decl, P
    | ()
~ End P4MathGrammar

## Type Syntax
~ Begin P4MathGrammar
t ::= @bool
    | @int
    | @bit<w>
    | t[a]
    | @tuple<\overline{t}>
    | \{\overline{f:t}\}  // record type
    | \mathkw{header\ union} \{\overline{f:t}\}
    | @struct \{\overline{f:t}\}
    | @header \{\overline{f:t}\}
    | @set<t>
    | @error
    | \mathkw{match\_kind}
    | X // type name
    | @newtype X t
    | @void
    | t<\overline{t}> // specialized type
    | @package<\overline{X}>(\overline{t,d})
    | @control<\overline{X}>(\overline{t,d})
    | @parser<\overline{X}>(\overline{t})
    | @extern X \{ \overline{method} \}
    | <\overline{X}>(\overline{t,d})\longrightarrow_F{}\tau
    | (\overline{t,d_0},\overline{t})\longrightarrow_A{}@void
    | <\overline{X}>(\overline{t})\longrightarrow_C{}t
    | @table

d0 ::= @in
     | @out
     | @inout

d ::= d0 | @none

X ::= name // regular type name
    | .name // top-level type name

~ End P4MathGrammar

"Results" $R$ are types for statements.
~ P4MathGrammar
R := @returns // written ``Void" in the implementation
     | \bot     // written ``Unit" in the implementation
~

Contexts indicate where a statement, declaration, parameter, or expression is
being typechecked.
~ P4MathGrammar
sctx ::= @InFunction t
       | @InAction
       | @InParser
       | @InControl
dctx ::= @InTopLevel
       | @InControl
       | @InParser
       | @InStatement sctx
pctx ::= sctx
       | @InExternMethod
       | @InPackage
ectx ::= @InFunction
       | @InAction
       | @InParserState
       | @InApplyBlock
       | @InDeclLocals
       | @InTableAction
       | @InConstant
~

## Signal Syntax
~ Begin P4MathGrammar
ssig ::= @go | @stop exn
esig ::= @go v | @stop exn
lsig ::= @go e | @stop exn
exn ::= @ret | @ret v | @reject v | @exit
~ End P4MathGrammar
There are signal conversions $[-]_{ssig}$, $[-]_{esig}$, and $[-]_{lsig}$.

# Static Semantics { #sec-static }

## Typing contexts

All typing judgments include

1. $\Sigma$, the values of any compile-time-known constants,
2. $\Delta$, the definitions of type names in scope, and
3. $\Gamma$, the types of variables in scope.

Type variables are tracked by mapping type names $X$ to themselves in
the context $\Delta$. Equivalently there could be another context that
was a list of lists of type variables, without them being mapped to
anything.

~ MathPre
\sigma ::= \sigma, x=v | []
S ::= S, \sigma{} | []

\delta ::= \delta, X=t | []
D ::= D, \delta{} | []

\gamma ::= \gamma, x:t,d | []
G ::= G, \gamma{} | []
~

For all contexts there is a lookup test $C(name) = y$ which searches from
the outermost list of bindings inward and a top level lookup $C(.name) =
y$ which only looks at the innermost list of bindings.

## Context conversions

Contexts (not the typing contexts, but the $\mathkw{InFunction}$ ones)
can be converted using maps $[-]_E,$ $[-]_S,$ and $[-]_D.$

## Expression Typing

~ Infer

---------------------[]
L,G |- @true: @bool
~

~ Infer

---------------------[]
L,G |- @false: @bool
~

~ Infer

---------------------[]
L,G |- a: @int
~

~ Infer

---------------------[]
L,G |- w{@w}a: bit<w>
~

~ Infer
L,G |- \overline{e:t}
----------------------------------------[]
L,G |- \{\overline{e}\}:tuple<\overline{t}>
~

~ Infer
L,G |- \overline{e:t}
@nodups \overline{name}
--------------------------------------------------[]
L,G |- \{\overline{name=e}\}:\{\overline{name:t}\}
~

~ Infer
L,G |- \overline{e:t}
@nodups \overline{name}
-----------------------------------------------------------------[]
L,G |- @header \{\overline{name=e}\}:@header \{\overline{name:t}\}
~

~ Infer
L,G \vdash_{set} match:t
-----------------------[]
L,G |- match:@set<t>
~

~ Infer
L,G(@error.x)=@error
----------------------[]
L,G |- @error.x:@error
~

~ Infer
L,G(x)=@match\_kind
--------------------------------[]
L,G |- @match\_kind.x:@match\_kind
~

~ Infer
L,G |- e:t_0
@cast\_ok t_0 t
------------------------------------[]
L,G |- (t)e:t
~

~ Infer
L,G(x)=t
----------[]
L,G |- x:t
~

~ Infer
L,G |- e:t,d
\mathkw{has\_field} t name t_{name}
------------------------------------[]
L,G |- e.name:t_{name}
~

The $\mathkw{dir\_ok}$ judgment checks that \(e\) can be used in
copy-in copy-out mode $d$. The $\mathkw{param\_ok}$ judgment is here
to make sure that the type arguments provided don't make the
parameters have inappopriate types (e.g., a string parameter on a
run-time function).
~ Infer
kind\neq{}ctor
L,G |- f:<\overline{T}>(\overline{t,d})\longrightarrow_{kind}t_ret
t_ret[\overline{\rho/T}] \Downarrow t_ret'
\overline{t[\overline{\rho/t}]\Downarrow{}t'}
L,G |- \overline{e:t'}
L,G |- \overline{e d \mathkw{dir\_ok}}
L,G |- \overline{kind t' \mathkw{param\_ok}}
-----------------------------------------------------------------[]
L,G |- f<\overline{\rho}>(\overline{e}) : t_ret'
~

~ Infer
G |- X:<\overline{T}>(\overline{t})\longrightarrow_{ctor}t_ret
t_ret[\overline{\rho/T}] \Downarrow t_ret'
\overline{t[\overline{\rho/t}]\Downarrow{}t'}
G |- \overline{e:t'}
G |- \overline{e \mathkw{ctk}}
G |- \overline{kind t' \mathkw{param\_ok}}
-----------------------------------------------------------------[]
L,G |- X<\overline{\rho}>(\overline{e}) : t_ret'
~

~ Infer
L(\ell)=@extern X \{G_X\}
G_X(name)=<\overline{T}>(\overline{\tau,d})\longrightarrow_M\tau_ret
------------------------------------------------------------------------------------[]
L,G |- @externfn \ell\ name:<\overline{T}>(\overline{\tau,d})\longrightarrow_M\tau_ret
~


## Statement Typing

### Result operators

The $\wedge{}$ operator is $\mathkw{returns}$ if both of its arguments
are $\mathkw{returns}$ and $\bot$ otherwise. The $\vee{}$ operator is
$\mathkw{returns}$ if any of its arguments are $\mathkw{returns}$
and $\bot$ otherwise.
~ MathPre
@returns \wedge @returns &= @returns
\bot\wedge{}R&=\bot
R\wedge\bot&=\bot
\bot\vee\bot&=\bot
@returns\vee{}R&=@returns
R\vee{}@returns&=@returns
~

### Valid declaration statements
The $decl\ \mathkw{declstmt}$ judgment says which declarations can be used as statements.
~ Infer

----------------------------[DeclStmt-Const]
@const t x:=e @declstmt
~
~ Infer

----------------------------[DeclStmt-VarDecl]
t x @declstmt
~
~ Infer

----------------------------[DeclStmt-VarInit]
t x:=e @declstmt
~

~ Infer

----------------------------[DeclStmt-Instantiation]
t x(\overline{e}) @declstmt
~

### Typing judgment

Statements are typed by a judgment of the form
~ MathPre
S,D,G,sctx |- s:R -| S',G'.
~

The judgment is defined inductively by the following rules.

~ Infer
S,D,G,[sctx]_E |- e<\overline{t}>(\overline{e}):t
-------------------------------------------------------[Type-Stmt-Method-Call]
S,D,G,sctx |- e<\overline{t}>(\overline{e}):\bot -| S,G
~

~ Infer
e_l \mathkw{lvalue}
S,D,G,[sctx]_E |- e_l:t
S,D,G,[sctx]_E |- e_r:t
----------------------------[Type-Stmt-Assignment]
S,D,G,sctx |- e_l:=e_r:\bot -| S,G
~

~ Infer
S,D,G,[sctx]_E |- e:@bool
S,D,G,sctx |- s_1:R_1 -| S_1,G_1
S,D,G,sctx |- s_2:R_2 -| S_2,G_2
----------------------------------------------[Type-Stmt-If-Else]
S,D,G,sctx |- @if (e) s_1 @else s_2:R_1\wedge{}R_2 -| S,G
~

Typing sequences of statements is defined in the next section.
~ Infer
S,D,G,sctx |- \overline{s}:R -| S',G'
---------------------------------------[Type-Stmt-Block]
S,D,G,sctx |- \{\overline{s}\}:R -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Exit]
S,D,G,@InParserState |- @exit:@returns -| S,G
~

~ Infer
S,D,G,@InFunction |- e:t
---------------------------------------------------[Type-Stmt-Return-Value]
S,D,G,@InFunction t |- @return e:@returns -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Void]
S,D,G,@InFunction @void |- @return:@returns -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Control]
S,D,G,@InControl |- @return:@returns -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Action]
S,D,G,@InAction |- @return:@returns -| S,G
~

~ Infer
decl @declstmt
S,D,G,[sctx]_D |- decl -| S',D',G'.
---------------------------------------------------[Type-Stmt-Declaration-Statement]
S,D,G,sctx |- decl:\bot -| S',G'
~

### Typing sequences of statements
We need another judgment for typing sequences $\overline{s}$ of
statements. (Sorry about the empty sequence notation in the first
rule...)

~ Infer

---------------------------------------------------[Type-Stmts-Empty]
S,D,G,sctx |- \overline{  } :\bot -| S,G
~

~ Infer
S,D,G,sctx |- s:R_1 -| S',G'
S',D,G',sctx |- \overline{s}:R_2 -| S'',G''
---------------------------------------------------[Type-Stmts-List]
S,D,G,sctx |- s;\overline{s}:R_1 \vee R_2 -| S'',G''
~

## Compile-time Evaluation

To evaluate compile-time known expressions, there is a judgment
~ Center
$S,\ e\Downarrow_{CTK}v$.
~

TODO: rules

## Declaration Typing
### Table property typing

#### Action ref typing
To make table typing rules readable there is a single-rule judgment
(abbreviation?) for action ref typing. It differs from ordinary action
invocation because it only looks at the "data plane parameters" of the
action, which are the ones with directions $d_0$.

~ Infer
G(x) = (\overline{t,d_0},\overline{t'}) \longrightarrow_A @void
S,D,G |- \overline{e:t}
-----------------------------------------------------------------[Type-ARef]
S,D,G |- x(\overline{e}) \mathkw{aref\_ok}
~

#### Entry typing

Similar situation here, but for table entries. The $x(\overline{e})
\in A$ check is implemented using a strict syntactic equality.
~ Infer
x(\overline{e}) \in A
G(x) = (\overline{t,d_0},\overline{t'}) \longrightarrow_A @void
S,D,G |- \overline{e':t'}
S,D,G |- e_m:@set<@tuple<\overline{t_k}>>
----------------------------------------------------------------------------------------------------[Type-Entry]
S,D,G;\{\overline{t_k}\},A |- e_m:x(\overline{e},\overline{e'}) \mathkw{entry\_ok}
~

#### Property typing
Table properties get their own judgment
~ MathPre
S,D,G,dctx;K,A |- prop -| K',A'
~
Where $K$ is a list of types for the table's keys and $A$ is a mapping from action refs to types.

~ Infer
S,D,G,[dctx]_E |- \overline{e:t}
S,D,G,[dctx]_E |- \overline{x:\mathkw{match\_kind}}
------------------------------------------------------------------------------[Type-Prop-Keys]
S,D,G;\{\},\{\} |- @key=\{\overline{e:x}\} -| \{\overline{\tau}\},\{\}
~

~Infer
S,D,G |- \overline{x_a(\overline{e}) \mathkw{aref\_ok}}
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Actions]
S,D,G;K,\{\} |- @actions = \{ \overline{x_a(\overline{e})} \} -| K,\{\overline{x_a(\overline{e})}\}
~

~ Infer
S,D,G;K,A |- \overline{entry \mathkw{entry\_ok}}
---------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Entries]
S,D,G;K,A |- @const @entries = \{ \overline{entry} \} -| K,A
~

~ Infer
G(x) = (\overline{t,d_0},\overline{t'}) \longrightarrow_A @void
x(\overline{e}) \in A
S,D,G |- \overline{e':t'}
----------------------------------------------------------------------------[Type-Prop-Default]
S,D,G,K,A |- \mathkw{default\_action}=x(\overline{e},\overline{e'}) -| K,A
~

### Parser state typing

Parser states need their own typing judgment to handle state machine
control flow. It has the form
~ Center
$\Sigma,\Delta,\Gamma,K \vdash state$,
~
where K is a list of names of states used to check that the parser's
transitions make sense. It is defined by two rules, which use another
judgement $\mathkw{state\_expr\_ok}$.

~ Infer
S,D,G,K |- state\_expr \mathkw{state\_expr\_ok}
------------------------------------------------------[Type-State-Transition]
S,D,G,K |- @state x \{ ; @transition state\_expr \}
~

~ Infer
S,D,G |- s0 -| G'
S,D,G' |- \{ \overline{s}; @transition state\_expr \}
----------------------------------------------------------[Type-State-Statement]
S,D,G,K |- @state x \{ s0; \overline{s}; @transition state\_expr \}
~

The $\mathkw{state\_expr\_ok}$ judgment is defined by the following rules.
~ Infer
x\in{}K
-----------------------------------------------[State-Expr-OK-Direct]
G,K |- \mathkw{state\_expr\_ok} x
~

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- e_m:@set<@tuple<\overline{t}>>
\overline{x\in{}K}
-----------------------------------------------[State-Expr-OK-Select]
S,D,G,K |- \mathkw{state\_expr\_ok} @select (\overline{e}) \{ \overline{e_m:x} \}
~

### Extern constructor and method typing

There are single-rule judgments for checking the constructor and
method signatures that appear in extern object declarations. Both
judgments are extended to lists by threading $\Gamma$ through.
~ Infer

--------------------------------------------------------------------------------------------------------------[Type-Ctor]
S,D,G,\tau |- @constructor<\overline{X}>(\overline{t}) -| G[X:<\overline{X}>(\overline{t})\longrightarrow_{C}\tau]
~

~ Infer

-----------------------------------------------------------------------------------------------------------------[Type-Method]
S,D,G |- @method t x<\overline{X}>(\overline{t,d}) -| G[x:<\overline{X}>(\overline{t,d})\longrightarrow_{F}t]
~

### Declaration typing judgment

Declarations are typed by a judgment of the form
~ MathPre
S,D,G,dctx |- decl -| S',D',G'.
~

It is defined inductively by the following rules.

~ Infer
S,D,G,[dctx]_E |- e:t
S, e\Downarrow{}v
------------------------------------------------[Type-Decl-Const]
S,D,G,dctx |- @const t x:=e -| S[x=v],D,G[x:t]
~

~ Infer
S,D,G,[dctx]_E |- t(\overline{e}) : t_{inst}
-----------------------------------------------------[Type-Decl-Instantiation]
S,D,G,dctx |- t x(\overline{e}) -| S,D,G[x:t_{inst}]
~

The function $\mathkw{names}(s_1, s_2, \dots)$ takes a list of states
and returns a list of their names. The $K\ \mathkw{states\_ok}$
judgment checks that the list of names $K$ contains no duplicates and
includes $\mathkw{start}$.

~ Infer
@names(\overline{state}) \mathkw{states\_ok}
S,D,G[\overline{x':t'}][\overline{x:t,d}],@InDecl |- \overline{decl} -| S',D',G'
S',D',G',(@names(\overline{state}),@accept,@reject) |- \overline{state}
----------------------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Parser]
S,D,G,dctx |- @parser X(\overline{x:t,d})(\overline{x':t'}) \{ \overline{decl} \overline{state} \} -| S,D,G[X:(\overline{t'})\longrightarrow_{C}@parser(\overline{t})]
~

~ Infer
S,D,G[\overline{x':t'}][\overline{x:t,d}],@InDecl |- \overline{decl} -| S',D',G'
S',D',G',@InApplyBlock |- blk -| G''
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Control]
S,D,G,dctx |- @control X(\overline{x:t,d})(\overline{x':t'}) \{ \overline{decl} @apply blk \} -| S,D,G[X:(\overline{t'})\longrightarrow_{C}@control(\overline{t,d})]
~

~ Infer
S,D[\overline{X \to \rho}],G[\overline{x:t}],@InFunction t |- blk: @returns -| G'
---------------------------------------------------------------------------------------------------------[Type-Decl-Function]
S,D,G,dctx |- @function t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G[x:<\overline{X}>(\overline{t})\longrightarrow_{F}t]
~

~ Infer

--------------------------------[Type-Decl-Variable]
S,D,G,dctx |- t x -| S,D,G[x:t]
~

~ Infer
S,D,G,[dctx]_E |- e:t
-----------------------------------[Type-Decl-Variable-Initialized]
S,D,G,dctx |- t x:=e -| S,D,G[x:t]
~

~ Infer
S,D,G[\overline{x:t,d0}][\overline{x':t'}],@InAction |- blk:@returns @void -| G_{blk}
dctx \in \{@InControl,@TopLevel\}
----------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Action]
S,D,G,dctx |- @action act(\overline{x:t,d_0},\overline{x':t'}) blk -| S,D,G[act:(\overline{t,d0},\overline{t}) \longrightarrow_{A} @void]
~

~ Infer
S,D,G,\{\},\{\} |- \overline{prop} -| K,A
--------------------------------------------------------------------[Type-Decl-Table]
S,D,G,@InControl |- @table x \{\overline{prop}\} -| S,D,G[x \to @table]
~

~ Infer
\overline{@error.x \notin G}
-----------------------------------------------------------[Type-Decl-Error]
S,D,G,@TopLevel |- @error \{ \overline{x} \} -| S,D,G[\overline{@error.x:@error}]
~

~ Infer
\overline{.x \notin G}
---------------------------------------------------[Type-Decl-Match-Kind]
S,D,G,@TopLevel |- \mathkw{match\_kind} \{ \overline{x} \} -| S,D,G[\overline{.x:\mathkw{match\_kind}}]
~

~ Infer
S,D,G,X |- \overline{ctor:\tau_c} -| G'
S,D,G',X |- \overline{method:\tau_m} -| G''
---------------------------------------------------------------------------------------------------------------------[Type-Decl-Extern-Object]
S,D,G,@TopLevel |- @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \} -| S,D,G''
~

~ Infer

-------------------------------------[Type-Decl-TypeDef]
S,D,G |- @typedef t X -| S,D[X=t],G
~

~ Infer

-----------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @newtype t X -| S,D[X=@newtype X t],G
~

# Dynamic Semantics

## Expression evaluation

### Run-time calls
~ Infer
@copyin E_F H (\overline{x=v,d})=E',H'
----------------------------------------------------------------------------------------------------------------------------[Expr-App-Fn]
<R,E,H,N,S,(E_F\otimes{}\lambda_F(\overline{x:\tau,d}).blk)(\overline{v})>\mapsto<E',H',N,S;[(\overline{x,d}),E],@block blk>
~

~ Infer
@copyout H E_S E (\overline{x,d})=E',H'
--------------------------------------------------------------------------------------------------[Expr-Block-Ret]
<R,E,H,N,S;[(\overline{x,d}),E_S],@block\{@return v\}>\mapsto<R,E',H',N,K,v>
~

### Compile-time calls
~ Infer

----------------------------------------------------------------------------------------------------------------------[Expr-Cons-App]
<R,E,H,N,S,((N',E')\otimes\lambda_{ctor}(\overline{x:t}).e)\ \overline{v}>\mapsto{}<E[x=v],H,@push N N',e>
~

## Declaration evaluation

### Variable declaration evaluation
~ Infer
@fresh H = \ell
------------------------------------------------------[]
<E,H,t x>\mapsto<E[x:=\ell],H[\ell:=@initialize t]>
~

### Const evaluation
~ Infer
@fresh H = \ell
---------------------------------------------------[]
<E,H,t x>\mapsto<E[x:=\ell],H[\ell:=v>
~

### Parser declaration evaluation
~ Infer

---------------------------------------------------[]

~


### Control declaration evaluation
### Extern class evaluation
### Table declaration evaluation
### Action declaration evaluation
### Function declaration evaluation
### Error and match_kind declaration evaluation
### Typedef declarations
TODO: no-op rules here
