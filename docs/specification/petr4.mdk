Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp
Package: mathtools
Package: xspace

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/( +)-\|( +)/\1\dashv{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG([^a-zA-Z])/\Gamma{}\1/g";
  replace: "/\bD([^a-zA-Z])/\Delta{}\1/g";
  replace: "/\bS([^a-zA-Z])/\Sigma{}\1/g";
  replace: "/\bt([^a-z])/\tau{}\1/g";
  replace: "/</\langle{}/g";
  replace: "/>/\rangle{}/g";
  replace: "/\b:=\b/\coloneqq{}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

p4mathgrammar {
  replace:"/\/\/(.*)/\/\/ &\text{\1}/g";
  replace: "~ Begin P4MathGrammarBlock&nl;\
                 ~ Begin MathPre&nl;&source;&nl;~ End MathPre&nl;\
                 ~ End P4MathGrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expression Syntax

~ Begin P4MathGrammar
e ::= @true
    | @false
    | a // arbitrary width integer literal
    | x // variable
    | e1[e2] // array access
    | \{ \overline{e} \} // list
    | \{ \overline{name=e} \} // records
    | uop e
    | e1 binop e2
    | (t) e // explicit cast
    | @error.name // error member
    | e.name // expression member
    | f<\overline{t}>(\overline{e}) // function call
    | t(\overline{e}) // nameless instantiation
    | e1 \texttt{\&\&\&} e2 // mask
    | e1 .. e2 // range
    | (\_)_{\tau} // universal set for type $t$
~ End P4MathGrammar

~ Begin P4MathGrammar
\hat{x} ::= name // regular variable name
          | .name // top-level variable name
~ End P4MathGrammar

~ Begin P4Grammar
// unary operators
uop ::= ! // not
      | - // unary minus

// binary operators
binop ::= +
        | -
        | *
        | <
        | >
        | &&
        | ||
        | <=
        | >=
        | ==
        | !=
~ End P4Grammar

## Statement and Block Syntax
~ Begin P4MathGrammar
s ::= e<\overline{t}>(\overline{e})     // method calls (positional)
    | e := e                            // assignment
    | @if (e) s_1 @else s_2             // conditional statement
    | blk                               // block statement
    | @exit                             // exit statement (only in controls)
    | @return                           // return (void)
    | @return e                         // return (with value)
    | @switch (e) \{ \overline{case} \} // switch statement
    | decl                              // declaration statement

case ::= case\_lbl: blk  // label with block
       | case\_lbl: {}   // fallthrough

case\_lbl ::= x                // name (of action)
            | \texttt{default} // catch-all label

blk ::= \{ s_1; ... s_n; \} // blocks
~ End P4MathGrammar

## Declaration Syntax
~ Begin P4MathGrammar
decl ::= @const t x:=e // constants
       | t x // variables
       | t x:=e // initialized variables
       | t x(\overline{e}) // named instantiations
       | @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \} // parsers
       | @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \} // controls
       | @action x (\overline{x:t,d_0},\overline{x:t}) blk // actions
       | @table x \{\overline{prop}\} // tables
       | @struct X \{\overline{x:t}\} // struct types
       | @error \{\overline{x}\} // errors
       | \mathkw{match\_kind} \{\overline{x}\} // match\_kinds
       | @extern X<\overline{X}> \{\overline{ctor}\ \overline{method}\} // extern classes
       | @control X<\overline{X}>(\overline{t,d}) // control types
       | @parser X<\overline{X}>(\overline{t,d}) // parser types
       | @typedef t X // typedefs (transparent)
       | @type t X // newtypes (opaque)

state ::= @state x \{\overline{s}; @transition state\_expr\}

state\_expr ::= x
              | @select (\overline{e}) \{\overline{e:x}\}

ctor ::= @constructor<\overline{X}>(\overline{t})

method ::= @method t x<\overline{X}>(\overline{t,d})

prop ::= @key = \{\overline{e:x}\}
       | @actions = \{\overline{a\_ref}\}
       | @const @entries = \{\overline{e:a\_ref(\overline{e})}\}
       | x = e
       | @const x = e

a\_ref ::= x(\overline{e})
~ End P4MathGrammar

## Program Syntax
A program is a sequence of declarations.
~ Begin P4MathGrammar
P ::= decl, P
    | ()
~ End P4MathGrammar

## Type Syntax

~ Begin P4MathGrammar
t ::= @bool
    | @int
    | @bit<w>
    | t[a]
    | @tuple<\overline{t}>
    | \{\overline{f:t}\}  // record type
    | \mathkw{header\ union} \{\overline{f:t}\}
    | @struct \{\overline{f:t}\}
    | @header \{\overline{f:t}\}
    | @set<t>
    | @error
    | \mathkw{match\_kind}
    | X // type name
    | @newtype X t
    | @void
    | t<\overline{t}> // specialized type
    | @package<\overline{X}>(\overline{t,d})
    | @control<\overline{X}>(\overline{t,d})
    | @parser<\overline{X}>(\overline{t})
    | @extern X \{ \overline{method} \}
    | <\overline{X}>(\overline{t,d})\longrightarrow_F{}\tau
    | (\overline{t,d_0},\overline{t})\longrightarrow_A{}@void
    | <\overline{X}>(\overline{t})\longrightarrow_C{}t
    | @table

d0 ::= @in
     | @out
     | @inout

d ::= d0 | @none

X ::= name // regular type name
    | .name // top-level type name

~ End P4MathGrammar

"eesults" $R$ are types for statements.
~ P4MathGrammar
R := @returns // written ``Void" in the implementation
     | \bot     // written ``Unit" in the implementation
~

Contexts indicate where a statement, declaration, parameter, or expression is
being typechecked.
~ P4MathGrammar
sctx ::= @InFunction t
       | @InAction
       | @InParser
       | @InControl
dctx ::= @InTopLevel
       | @InControl
       | @InParser
       | @InStatement sctx
pctx ::= sctx
       | @InExternMethod
       | @InPackage
ectx ::= @InFunction
       | @InAction
       | @InParserState
       | @InApplyBlock
       | @InDeclLocals
       | @InTableAction
       | @InConstant
~

## Value Syntax

Values
~ Begin P4MathGrammar
v_o ::= @true // booleans
    | @false
    | a // arbitrary width integer literal
    | n\mathkw{w}a // unsigned integer literal of size n
    | u // strings
    | \{\overline{v}\} // tuple
    | \{\overline{name=v}\} // records
    | @struct \{\overline{name=v}\}
    | @header \{\overline{name=v}\}
    | set
    | @error.name
    | @matchkind.name
    | \xi \otimes (\overline{x:t,d}) blk // functions, actions
    | @builtin name lv
    | \mathkw{header\ union} \{ \overline{name=v} \}
    | @stack_n n \overline{v} // stacks
    | @runtime name \ell // stateful runtime
    | @parser (\overline{name=v}) (\overline{x:t,d}) \overline{decl} \overline{state}
    | @control (\overline{name=v}) (\overline{x:t,d}) \overline{decl} blk
    | @package (\overline{name=v})
    | @table name \overline{e:x} \overline{a\_ref} a\_ref \{ \overline{e:a\_ref} \}
    | @extern name v
~ End P4MathGrammar

Sets
~ Begin P4MathGrammar
set ::=  @universal
    | @singleton w v
    | v1 \texttt{\&\&\&} v2 // mask
    | v1 .. v2 // range
    | @product \overline{set}
    | @lpm w v1 v2
~ End P4MathGrammar

## Signal Syntax
~ Begin P4MathGrammar
sig ::= \mathkw{sig\_continue}
    | \mathkw{sig\_return} v
    | \mathkw{sig\_return}
    | \mathkw{sig\_exit}
    | \mathkw{sig\_reject} v
~ End P4MathGrammar

# Static Semantics { #sec-static }

## Typing contexts

All typing judgments include
1. $\Sigma$, the values of any compile-time-known constants,
2. $\Delta$, the definitions of type names in scope, and
3. $\Gamma$, the types of variables in scope.

Type variables are tracked by mapping type names $X$ to themselves in
the context $\Delta$. Equivalently there could be another context that
was a list of lists of type variables, without them being mapped to
anything.

~ MathPre
\sigma ::= \sigma, x=v | []

S ::= S, \sigma{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []

\gamma ::= \gamma, x:t,d | []

G ::= G, \gamma{} | []
~

In all contexts there is a lookup test $C(name) = y$ which searches from
the outermost list of bindings inward and a top level lookup $C(.name) =
y$ which only looks at the innermost list of bindings.

## Context conversions

Contexts can be converted using maps $[-]_E$, $[-]_S$, and $[-]_D$.

## Expression Typing

See [petr4-full](petr4-full.html) for details.

## Statement Typing

### Result operators

The $\wedge{}$ operator is $\mathkw{returns}$ if both of its arguments
are $\mathkw{returns}$ and $\bot$ otherwise. The $\vee{}$ operator is
$\mathkw{returns}$ if any of its arguments are $\mathkw{returns}$
and $\bot$ otherwise.
~ MathPre
@returns \wedge @returns &= @returns
\bot\wedge{}R&=\bot
R\wedge\bot&=\bot
\bot\vee\bot&=\bot
@returns\vee{}R&=@returns
R\vee{}@returns&=@returns
~

### Valid declaration statements
The $decl\ \mathkw{declstmt}$ judgment says which declarations can be used as statements.
~ Infer

----------------------------[DeclStmt-Const]
@const t x:=e @declstmt
~
~ Infer

----------------------------[DeclStmt-VarDecl]
t x @declstmt
~
~ Infer

----------------------------[DeclStmt-VarInit]
t x:=e @declstmt
~

~ Infer

----------------------------[DeclStmt-Instantiation]
t x(\overline{e}) @declstmt
~

### Typing judgment

Statements are typed by a judgment of the form
~ MathPre
S,D,G,sctx |- s:R -| S',G'.
~

The judgment is defined inductively by the following rules.

~ Infer
S,D,G,[sctx]_E |- e<\overline{t}>(\overline{e}):t
-------------------------------------------------------[Type-Stmt-Method-Call]
S,D,G,sctx |- e<\overline{t}>(\overline{e}):\bot -| S,G
~

~ Infer
e_l \mathkw{lvalue}
S,D,G,[sctx]_E |- e_l:t
S,D,G,[sctx]_E |- e_r:t
----------------------------[Type-Stmt-Assignment]
S,D,G,sctx |- e_l:=e_r:\bot -| S,G
~

~ Infer
S,D,G,[sctx]_E |- e:@bool
S,D,G,sctx |- s_1:R_1 -| S_1,G_1
S,D,G,sctx |- s_2:R_2 -| S_2,G_2
----------------------------------------------[Type-Stmt-If-Else]
S,D,G,sctx |- @if (e) s_1 @else s_2:R_1\wedge{}R_2 -| S,G
~

Typing sequences of statements is defined in the next section.
~ Infer
S,D,G,sctx |- \overline{s}:R -| S',G'
---------------------------------------[Type-Stmt-Block]
S,D,G,sctx |- \{\overline{s}\}:R -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Exit]
S,D,G,@InParserState |- @exit:@returns -| S,G
~

~ Infer
S,D,G,@InFunction |- e:t
---------------------------------------------------[Type-Stmt-Return-Value]
S,D,G,@InFunction t |- @return e:@returns -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Void]
S,D,G,@InFunction @void |- @return:@returns -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Control]
S,D,G,@InControl |- @return:@returns -| S,G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Action]
S,D,G,@InAction |- @return:@returns -| S,G
~

~ Infer
decl @declstmt
S,D,G,[sctx]_D |- decl -| S',D',G'.
---------------------------------------------------[Type-Stmt-Declaration-Statement]
S,D,G,sctx |- decl:\bot -| S',G'
~

### Typing sequences of statements
We need another judgment for typing sequences $\overline{s}$ of
statements. (Sorry about the empty sequence notation in the first
rule...)

~ Infer

---------------------------------------------------[Type-Stmts-Empty]
S,D,G,sctx |- \overline{  } :\bot -| S,G
~

~ Infer
S,D,G,sctx |- s:R_1 -| S',G'
S',D,G',sctx |- \overline{s}:R_2 -| S'',G''
---------------------------------------------------[Type-Stmts-List]
S,D,G,sctx |- s;\overline{s}:R_1 \vee R_2 -| S'',G''
~

## Compile-time Evaluation

To evaluate compile-time known expressions, there is a judgment
~ Center
$S,\ e\Downarrow_{CTK}v$.
~

TODO: rules

## Declaration Typing
### Table property typing

#### Action ref typing
To make table typing rules readable there is a single-rule judgment
(abbreviation?) for action ref typing. It differs from ordinary action
invocation because it only looks at the "data plane parameters" of the
action, which are the ones with directions $d_0$.

~ Infer
G(x) = (\overline{t,d_0},\overline{t'}) \longrightarrow_A @void
S,D,G |- \overline{e:t}
-----------------------------------------------------------------[Type-ARef]
S,D,G |- x(\overline{e}) \mathkw{aref\_ok}
~

#### Entry typing

Similar situation here, but for table entries. The $x(\overline{e})
\in A$ check is implemented using a strict syntactic equality.
~ Infer
x(\overline{e}) \in A
G(x) = (\overline{t,d_0},\overline{t'}) \longrightarrow_A @void
S,D,G |- \overline{e':t'}
S,D,G |- e_m:@set<@tuple<\overline{t_k}>>
----------------------------------------------------------------------------------------------------[Type-Entry]
S,D,G;\{\overline{t_k}\},A |- e_m:x(\overline{e},\overline{e'}) \mathkw{entry\_ok}
~

#### Property typing
Table properties get their own judgment
~ MathPre
S,D,G,dctx;K,A |- prop -| K',A'
~
Where $K$ is a list of types for the table's keys and $A$ is a mapping from action refs to types.

~ Infer
S,D,G,[dctx]_E |- \overline{e:t}
S,D,G,[dctx]_E |- \overline{x:\mathkw{match\_kind}}
------------------------------------------------------------------------------[Type-Prop-Keys]
S,D,G;\{\},\{\} |- @key=\{\overline{e:x}\} -| \{\overline{\tau}\},\{\}
~

~Infer
S,D,G |- \overline{x_a(\overline{e}) \mathkw{aref\_ok}}
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Actions]
S,D,G;K,\{\} |- @actions = \{ \overline{x_a(\overline{e})} \} -| K,\{\overline{x_a(\overline{e})}\}
~

~ Infer
S,D,G;K,A |- \overline{entry \mathkw{entry\_ok}}
---------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Entries]
S,D,G;K,A |- @const @entries = \{ \overline{entry} \} -| K,A
~

~ Infer
G(x) = (\overline{t,d_0},\overline{t'}) \longrightarrow_A @void
x(\overline{e}) \in A
S,D,G |- \overline{e':t'}
----------------------------------------------------------------------------[Type-Prop-Default]
S,D,G,K,A |- \mathkw{default\_action}=x(\overline{e},\overline{e'}) -| K,A
~

### Parser state typing

Parser states need their own typing judgment to handle state machine
control flow. It has the form
~ Center
$\Sigma,\Delta,\Gamma,K \vdash state$,
~
where K is a list of names of states used to check that the parser's
transitions make sense. It is defined by two rules, which use another
judgement $\mathkw{state\_expr\_ok}$.

~ Infer
S,D,G,K |- state\_expr \mathkw{state\_expr\_ok}
------------------------------------------------------[Type-State-Transition]
S,D,G,K |- @state x \{ ; @transition state\_expr \}
~

~ Infer
S,D,G |- s0 -| G'
S,D,G' |- \{ \overline{s}; @transition state\_expr \}
----------------------------------------------------------[Type-State-Statement]
S,D,G,K |- @state x \{ s0; \overline{s}; @transition state\_expr \}
~

The $\mathkw{state\_expr\_ok}$ judgment is defined by the following rules.
~ Infer
x\in{}K
-----------------------------------------------[State-Expr-OK-Direct]
G,K |- \mathkw{state\_expr\_ok} x
~

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- e_m:@set<@tuple<\overline{t}>>
\overline{x\in{}K}
-----------------------------------------------[State-Expr-OK-Select]
S,D,G,K |- \mathkw{state\_expr\_ok} @select (\overline{e}) \{ \overline{e_m:x} \}
~

### Extern constructor and method typing

There are single-rule judgments for checking the constructor and
method signatures that appear in extern object declarations. Both
judgments are extended to lists by threading $\Gamma$ through.
~ Infer

--------------------------------------------------------------------------------------------------------------[Type-Ctor]
S,D,G,\tau |- @constructor<\overline{X}>(\overline{t}) -| G[X:<\overline{X}>(\overline{t})\longrightarrow_{C}\tau]
~

~ Infer

-----------------------------------------------------------------------------------------------------------------[Type-Method]
S,D,G |- @method t x<\overline{X}>(\overline{t,d}) -| G[x:<\overline{X}>(\overline{t,d})\longrightarrow_{F}t]
~

### Declaration typing judgment

Declarations are typed by a judgment of the form
~ MathPre
S,D,G,dctx |- decl -| S',D',G'.
~

It is defined inductively by the following rules.

~ Infer
S,D,G,[dctx]_E |- e:t
S, e\Downarrow{}v
------------------------------------------------[Type-Decl-Const]
S,D,G,dctx |- @const t x:=e -| S[x=v],D,G[x:t]
~

~ Infer
S,D,G,[dctx]_E |- t(\overline{e}) : t_{inst}
-----------------------------------------------------[Type-Decl-Instantiation]
S,D,G,dctx |- t x(\overline{e}) -| S,D,G[x:t_{inst}]
~

The function $\mathkw{names}(s_1, s_2, \dots)$ takes a list of states
and returns a list of their names. The $K\ \mathkw{states\_ok}$
judgment checks that the list of names $K$ contains no duplicates and
includes $\mathkw{start}$.

~ Infer
@names(\overline{state}) \mathkw{states\_ok}
S,D,G[\overline{x':t'}][\overline{x:t,d}],@InDecl |- \overline{decl} -| S',D',G'
S',D',G',(@names(\overline{state}),@accept,@reject) |- \overline{state}
----------------------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Parser]
S,D,G,dctx |- @parser X(\overline{x:t,d})(\overline{x':t'}) \{ \overline{decl} \overline{state} \} -| S,D,G[X:(\overline{t'})\longrightarrow_{C}@parser(\overline{t})]
~

~ Infer
S,D,G[\overline{x':t'}][\overline{x:t,d}],@InDecl |- \overline{decl} -| S',D',G'
S',D',G',@InApplyBlock |- blk -| G''
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Control]
S,D,G,dctx |- @control X(\overline{x:t,d})(\overline{x':t'}) \{ \overline{decl} @apply blk \} -| S,D,G[X:(\overline{t'})\longrightarrow_{C}@control(\overline{t,d})]
~

~ Infer
S,D[\overline{X \to \rho}],G[\overline{x:t}],@InFunction t |- blk: @returns -| G'
---------------------------------------------------------------------------------------------------------[Type-Decl-Function]
S,D,G,dctx |- @function t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G[x:<\overline{X}>(\overline{t})\longrightarrow_{F}t]
~

~ Infer

--------------------------------[Type-Decl-Variable]
S,D,G,dctx |- t x -| S,D,G[x:t]
~

~ Infer
S,D,G,[dctx]_E |- e:t
-----------------------------------[Type-Decl-Variable-Initialized]
S,D,G,dctx |- t x:=e -| S,D,G[x:t]
~

~ Infer
S,D,G[\overline{x:t,d0}][\overline{x':t'}],@InAction |- blk:@returns @void -| G_{blk}
dctx \in \{@InControl,@TopLevel\}
----------------------------------------------------------------------------------------------------------------------------------------[Type-Decl-Action]
S,D,G,dctx |- @action act(\overline{x:t,d_0},\overline{x':t'}) blk -| S,D,G[act:(\overline{t,d0},\overline{t}) \longrightarrow_{A} @void]
~

~ Infer
S,D,G,\{\},\{\} |- \overline{prop} -| K,A
--------------------------------------------------------------------[Type-Decl-Table]
S,D,G,@InControl |- @table x \{\overline{prop}\} -| S,D,G[x \to @table]
~

### Header and Struct Typing
~ Infer

-----------------------------------------------------------------------------------[Type-Decl-Header]
S,D,G,@TopLevel |- @header X \{\overline{x:t}\} -| S,D[X=@header \{\overline{x:t}\}],G
~

~ Infer

-------------------------------------------------------------------[Type-Decl-Struct]
S,D,G,@TopLevel |- @struct X \{ \overline{x:t} \} -| S,D[X=@struct \{ \overline{f:t} \}],G
~

~ Infer
\overline{@error.x \notin G}
-----------------------------------------------------------[Type-Decl-Error]
S,D,G,@TopLevel |- @error \{ \overline{x} \} -| S,D,G[\overline{@error.x:@error}]
~

~ Infer
\overline{.x \notin G}
---------------------------------------------------[Type-Decl-Match-Kind]
S,D,G,@TopLevel |- \mathkw{match\_kind} \{ \overline{x} \} -| S,D,G[\overline{.x:\mathkw{match\_kind}}]
~

~ Infer
S,D,G,X |- \overline{ctor:\tau_c} -| G'
S,D,G',X |- \overline{method:\tau_m} -| G''
---------------------------------------------------------------------------------------------------------------------[Type-Decl-Extern-Object]
S,D,G,@TopLevel |- @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \} -| S,D,G''
~

~ Infer

-------------------------------------[Type-Decl-TypeDef]
S,D,G |- @typedef t X -| S,D[X=t],G
~

~ Infer

-----------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @newtype t X -| S,D[X=@newtype X t],G
~

# Dynamic Semantics
## Evaluation Environment and State
## Control flow
## Evaluation Helper Rules
## Expression Evaluation
## Lvalue evaluation
Expressions on the left hand side of things have to be simplified but
not fully evaluated.
~ MathPre
<\zeta, \xi, \sigma', e> \Downarrow_\ell <\xi', \sigma', sig, e_lv>
~

Rules: TODO

## Statements and Block Evaluation

Statements run in a configuration with control plane data, the
environment, and the heap. They produce a new environment and heap
along with a signal.

~ Center
$\langle\zeta, \xi, \sigma, s\rangle \Downarrow_s \langle\xi', \sigma', sig\rangle$
~

~ Infer
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------[Method-Call]
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_s <\xi', \sigma', sig>
~

~ Infer
<\zeta, \xi, \sigma, e_r> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
<\zeta, \xi, \sigma', e_l> \Downarrow_\ell <\xi'', \sigma'', sig, e_lv>
----------------------------------------------------------------------------------[Assignment]
<\zeta, \xi, \sigma, e_l:=e_r> \Downarrow_s <\xi', <\xi',\sigma''>[v/e_lv]>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v>
------------------------------------------------------------------------------[Conditional-Reject]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi', \sigma', \mathkw{sig\_reject\ v}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
<\zeta, @push \xi', \sigma', s_1> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-True]
<\zeta, \xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
<\zeta, @push \xi', \sigma', s_2> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-False]
<\zeta, \xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\zeta, @push \xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig>
--------------------------------------------------------------------------[Block]
<\zeta, \xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi, \sigma', sig>
~

~ Infer

---------------------------------------------------------------------[Exit-Continue]
<\zeta, \xi, \sigma, @exit> \Downarrow_s <\xi, \sigma, \mathkw{sig\_exit}>
~

~ Infer

---------------------------------------------[Return-Void]
<\zeta, \xi, \sigma, @return> \Downarrow_s <\xi, \sigma, \mathkw{sig\_return}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------[Return-Value]
<\zeta, \xi, \sigma, @return e> \Downarrow_s <\xi', \sigma', \mathkw{sig\_return\ v}>
~

~ Infer
<\zeta, \xi, \sigma, decl> \Downarrow_d <\xi', \sigma'>
--------------------------------------------------------------------[Declaration-Statement]
<\zeta, \xi, \sigma, decl> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
~


## Declaration Evaluation

Declarations are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, decl \rangle \Downarrow_d \langle \xi', \sigma' \rangle$
~

## Program Evaluation

# Type Soundness