Set Warnings "-custom-entry-overridden".
Require Export Poulet4.P4cub.Syntax.Syntax
        Poulet4.P4cub.Transformations.Statementize
        Coq.micromega.Lia.
Require Export Poulet4.P4cub.BigStep.BigStep
        Poulet4.P4cub.Envn Poulet4.P4cub.Transformations.Lifted.
Import AllCubNotations Env.EnvNotations
       Val.ValueNotations Step.

Ltac if_destr :=
  match goal with
    |- context [if ?trm then _ else _]
    => destruct trm as [? | ?] eqn:?
  end; unfold "===" in *; try contradiction; auto.

Section Correct.
  Context {tags_t : Type}.

  Local Hint Constructors expr_big_step : core.
  Local Hint Constructors stmt_big_step : core.
  Local Hint Constructors lvalue_big_step : core.
  Local Hint Resolve Env.bind_sound : core.
  
  Arguments String.append (*"_p_4_s_e_l_" s*) : simpl never.
  
  (** Relation between temps generated by [TransformExpr]
      and variables in the evaluation store. *)
  Definition epsilon_env (eps : epsilon) (env : VarNameGen.t) : Prop :=
    forall n, env <= n ->
         Env.find (fst (VarNameGen.new_var n)) eps = None.

  Lemma epsilon_env_leq : forall env1 env2 eps,
      env1 <= env2 -> epsilon_env eps env1 -> epsilon_env eps env2.
  Proof.
    unfold epsilon_env.
    intros env1 env2 eps Henv Hee n Henv2n.
    apply Hee. lia.
  Qed.

  Lemma TransformExpr_env_inc : forall (e : Expr.e tags_t) env,
      env <= snd (TransformExpr e env).
  Proof.
    intro e; induction e using custom_e_ind;
      intro env; cbn in *; try lia; repeat transformExpr_destr.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - specialize IHe1 with env.
      specialize IHe2 with t.
      apply f_equal with (f := snd) in Heqp, Heqp0; cbn in *. lia.
    - apply f_equal with (f := snd) in Heqp; cbn in *.
      rewrite <- Heqp; clear Heqp.
      generalize dependent env.
      unfold TransformExprList'.
      ind_list_Forall; intros env; simpl in *; try lia.
      fold_destr. transformExpr_destr.
      intuition. specialize H with env.
      rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *.
      specialize H2 with t0. lia.
    - apply f_equal with (f := snd) in Heqp; cbn in *.
      rewrite <- Heqp; clear Heqp.
      generalize dependent env.
      unfold TransformFields', Field.fold.
      F.FieldTactics.ind_list_predfs; intros env; simpl in *; try lia.
      fold_destr. transformExpr_destr.
      intuition. specialize H with env.
      rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *.
      specialize H2 with t0. lia.
    - apply f_equal with (f := snd) in Heqp, Heqp0; cbn in *.
      transitivity t.
      + clear Heqp0.
        rewrite <- Heqp; clear Heqp.
        generalize dependent env.
        unfold TransformFields', Field.fold.
        (F.FieldTactics.ind_list_predfs; intros env; simpl in *; try lia;
         fold_destr; transformExpr_destr;
         intuition; specialize H with env;
         rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *;
         specialize H2 with t1; lia).
      + specialize IHe with t. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - apply f_equal with (f := snd) in Heqp; cbn in *.
      rewrite <- Heqp; clear Heqp.
      generalize dependent env.
      unfold TransformExprList'.
      ind_list_Forall; intros env; simpl in *; try lia.
      fold_destr. transformExpr_destr.
      intuition. specialize H with env.
      rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *.
      specialize H2 with t0. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
  Qed.
  
  Ltac triplet_inv :=
    match goal with
    | H: (_,_,_) = (_,_,_) |- _ => inv H
    end.
  
  Ltac solve_this_stuff :=
    match goal with
    | |- exists eps',
        ⟪ ?pkt, _, ?eps, _, _ ⟫ ⤋ ⟪ _,C,?pkt ⟫
        /\ ⟨ eps', Var ?x:_ @ _ ⟩ ⇓ ?v
        /\ ?eps ⊆ eps' /\ epsilon_env eps' _
      => exists !{ x ↦ v;; eps }!; eauto
    end; assumption.

  Ltac solve_this_stuff_with eps v :=
    match goal with
    | |- exists eps',
        ⟪ ?pkt, _, _, _, _ ⟫ ⤋ ⟪ _,C,?pkt ⟫
        /\ ⟨ eps', Var ?x:_ @ _ ⟩ ⇓ _
        /\ _ ⊆ eps' /\ epsilon_env eps' _
      => exists !{ x ↦ v;; eps }!; eauto 6
    end.

  (* Type Soundness for statements
     would be useful for this.
     Knowing [exists] an environment for
     the statement to evaluate to
     (worry about this later). *)
  Lemma expr_semantic_pres : forall (e : Expr.e tags_t) v ϵ,
      ⟨ ϵ, e ⟩ ⇓ v ->
      forall env pkt fe ctx, (* ctx & fe shouldn't matter *)
        epsilon_env ϵ env ->
        let '(s, e', env') := TransformExpr e env in
        exists ϵ',
          ⟪ pkt , fe , ϵ , ctx , s ⟫ ⤋ ⟪ ϵ' , C , pkt ⟫ /\
          (* statement evaluates to store [ϵ'] *)
          ⟨ ϵ', e' ⟩ ⇓ v /\ (* expression goes to same value [v] *)
          ϵ ⊆ ϵ' /\
          epsilon_env ϵ' env'.
  Proof.
    intros ? ? ? ebs;
      induction ebs
      as [ eps b i 
         | eps w n i
         | eps w z i
         | eps x t i v Hxv
         | eps e hi lo i v v' Hslice Hev IHev
         | eps t e i v v' Hcast Hev IHev
         | eps err i
         | eps mk i
         | eps t op e i v v' Huop Hev IHev
         | eps t op e1 e2 i v v1 v2 Hbop Hev1 IHev1 Hev2 IHev2
         | eps t e x i v v' Hmem Hev IHev
         | eps es i vs Hevs IHevs
         | eps es i vs Hevs IHevs
         | eps es e i b vs Hevs IHevs Hev IHev
         | eps ts es ni i vss Hevsss IHevsss
         | eps e i n ni ts vss b vs Haccess Hevss IHevss
         ] using custom_expr_big_step_ind;
      intros env pkt fe cx Hee; try transformExpr_destr;
        unfold decl_var_env in *; cbn in *; try triplet_inv;
          cbn in *; eauto (*; try solve_this_stuff *) .
    - exists eps. repeat split; eauto. reflexivity.
    - solve_this_stuff_with eps ~{ w VW n }~.
      repeat split; eauto; unfold epsilon_env in *.
      + apply Env.find_none_bind_sub_env.
        apply Hee. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Hee. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - solve_this_stuff_with eps ~{ w VS z }~.
      repeat split; eauto; unfold epsilon_env in *.
      + apply Env.find_none_bind_sub_env.
        apply Hee. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Hee. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - exists eps. repeat split; auto. reflexivity.
    - pose proof IHev env pkt fe cx Hee as IH; clear IHev.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH as (eps' & Hs & Hv & Hsub & Henv).
      solve_this_stuff_with eps' v'.
      repeat split; eauto; unfold epsilon_env in *.
      + transitivity eps'; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - pose proof IHev env pkt fe cx Hee as IH.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH as (eps' & Hs & Hv & Hsub & Henv).
      solve_this_stuff_with eps' v'.
      repeat split; eauto; unfold epsilon_env in *.
      + transitivity eps'; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - exists eps. repeat split; auto. reflexivity.
    - exists eps. repeat split; auto. reflexivity.
    - pose proof IHev env pkt fe cx Hee as IH; clear IHev.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH as (eps' & Hs & Hv & Hsub & Henv).
      solve_this_stuff_with eps' v'.
      repeat split; eauto; unfold epsilon_env in *.
      + transitivity eps'; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - pose proof IHev1 env pkt fe cx Hee as IH1; clear IHev1.
      transformExpr_destr_hyp.
      destruct IH1 as (eps'1 & Hs1 & Hv1 & Hsub1 & Henv1).
      pose proof IHev2 t1 pkt fe cx.
      transformExpr_destr_hyp; triplet_inv.
      (*
      destruct IHev2 as (eps'2 & Hs2 & He2).
      solve_this_stuff_with eps'2 v; intuition.
      apply sbs_seq_cont with eps'2 pkt.
      + apply sbs_seq_cont with eps'1 pkt; auto.
        (* TODO: need helper lemmas
         about environments and
         statement evalution. *) admit.
      + repeat econstructor; eauto.
        (* TODO: need helper lemmas
         about environments and
         expression evalution. *) admit.
    - specialize IHev with env pkt fe cx.
      transformExpr_destr_hyp; triplet_inv.
      destruct IHev as (eps' & Hs & He); eauto.
    - (* Has a similar problem to
         binary operation case. *)
      admit.
    - (* Has a similar problem to
         binary operation case. *)
      admit.
    - (* Has a similar problem to
         binary operation case. *)
      admit.
    - (* Has a similar problem to
         binary operation case. *)
      admit.
    - specialize IHevss with env pkt fe cx.
      transformExpr_destr_hyp; triplet_inv.
      destruct IHevss as (eps' & Hs & He); eauto. *)
  Admitted.
End Correct.
