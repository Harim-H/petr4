Set Warnings "-custom-entry-overridden".
Require Export Poulet4.P4cub.Syntax.Syntax
        Poulet4.P4cub.Transformations.Statementize
        Coq.micromega.Lia.
Require Export Poulet4.P4cub.BigStep.BigStep
        Poulet4.P4cub.Envn Poulet4.P4cub.Transformations.Lifted.
Import AllCubNotations Env.EnvNotations
       Val.ValueNotations Step.

Ltac if_destr :=
  match goal with
    |- context [if ?trm then _ else _]
    => destruct trm as [? | ?] eqn:?
  end; unfold "===" in *; try contradiction; auto.

Section Correct.
  Context {tags_t : Type}.

  Local Hint Constructors expr_big_step : core.
  Local Hint Constructors stmt_big_step : core.
  Local Hint Constructors lvalue_big_step : core.
  Local Hint Resolve Env.bind_sound : core.
  
  Arguments String.append (*"_p_4_s_e_l_" s*) : simpl never.
  
  (** Relation between temps generated by [TransformExpr]
      and variables in the evaluation store. *)
  Definition epsilon_env (eps : epsilon) (env : VarNameGen.t) : Prop :=
    forall n, env <= n ->
         Env.find (fst (VarNameGen.new_var n)) eps = None.

  Lemma epsilon_env_leq : forall env1 env2 eps,
      env1 <= env2 -> epsilon_env eps env1 -> epsilon_env eps env2.
  Proof.
    unfold epsilon_env.
    intros env1 env2 eps Henv Hee n Henv2n.
    apply Hee. lia.
  Qed.

  Lemma TransformExpr_env_inc : forall (e : Expr.e tags_t) env,
      env <= snd (TransformExpr e env).
  Proof.
    intro e; induction e using custom_e_ind;
      intro env; cbn in *; try lia; repeat transformExpr_destr.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - specialize IHe1 with env.
      specialize IHe2 with t.
      apply f_equal with (f := snd) in Heqp, Heqp0; cbn in *. lia.
    - apply f_equal with (f := snd) in Heqp; cbn in *.
      rewrite <- Heqp; clear Heqp.
      generalize dependent env.
      unfold TransformExprList'.
      ind_list_Forall; intros env; simpl in *; try lia.
      fold_destr. transformExpr_destr.
      intuition. specialize H with env.
      rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *.
      specialize H2 with t0. lia.
    - apply f_equal with (f := snd) in Heqp; cbn in *.
      rewrite <- Heqp; clear Heqp.
      generalize dependent env.
      unfold TransformFields', Field.fold.
      F.FieldTactics.ind_list_predfs; intros env; simpl in *; try lia.
      fold_destr. transformExpr_destr.
      intuition. specialize H with env.
      rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *.
      specialize H2 with t0. lia.
    - apply f_equal with (f := snd) in Heqp, Heqp0; cbn in *.
      transitivity t.
      + clear Heqp0.
        rewrite <- Heqp; clear Heqp.
        generalize dependent env.
        unfold TransformFields', Field.fold.
        (F.FieldTactics.ind_list_predfs; intros env; simpl in *; try lia;
         fold_destr; transformExpr_destr;
         intuition; specialize H with env;
         rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *;
         specialize H2 with t1; lia).
      + specialize IHe with t. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
    - apply f_equal with (f := snd) in Heqp; cbn in *.
      rewrite <- Heqp; clear Heqp.
      generalize dependent env.
      unfold TransformExprList'.
      ind_list_Forall; intros env; simpl in *; try lia.
      fold_destr. transformExpr_destr.
      intuition. specialize H with env.
      rewrite Hfoldl in H; apply f_equal with (f := snd) in Heqp; cbn in *.
      specialize H2 with t0. lia.
    - specialize IHe with env.
      apply f_equal with (f := snd) in Heqp; cbn in *. lia.
  Qed.
  
  Ltac triplet_inv :=
    match goal with
    | H: (_,_,_) = (_,_,_) |- _ => inv H
    end.
  
  Ltac solve_this_stuff :=
    match goal with
    | |- exists eps',
        ⟪ ?pkt, _, ?eps, _, _ ⟫ ⤋ ⟪ _,C,?pkt ⟫
        /\ ⟨ eps', Var ?x:_ @ _ ⟩ ⇓ ?v
        /\ ?eps ⊆ eps' /\ epsilon_env eps' _
      => exists !{ x ↦ v;; eps }!; eauto
    end; assumption.

  Ltac solve_this_stuff_with eps v :=
    match goal with
    | |- exists eps',
        ⟪ ?pkt, _, _, _, _ ⟫ ⤋ ⟪ _,C,?pkt ⟫
        /\ ⟨ eps', Var ?x:_ @ _ ⟩ ⇓ _
        /\ _ ⊆ eps' /\ epsilon_env eps' _
      => exists !{ x ↦ v;; eps }!; eauto 6
    end.

  (* Type Soundness for statements
     would be useful for this.
     Knowing [exists] an environment for
     the statement to evaluate to
     (worry about this later). *)
  Lemma expr_semantic_pres : forall (e : Expr.e tags_t) v ϵ,
      ⟨ ϵ, e ⟩ ⇓ v ->
      forall env pkt fe ctx, (* ctx & fe shouldn't matter *)
        epsilon_env ϵ env ->
        let '(s, e', env') := TransformExpr e env in
        exists ϵ',
          ⟪ pkt , fe , ϵ , ctx , s ⟫ ⤋ ⟪ ϵ' , C , pkt ⟫ /\
          (* statement evaluates to store [ϵ'] *)
          ⟨ ϵ', e' ⟩ ⇓ v /\ (* expression goes to same value [v] *)
          ϵ ⊆ ϵ' /\ (* [s] only extends existing environment. *)
          (* Maybe need instead of [ϵ ⊆ ϵ']
             [Env.disjoint_union ϵ μ ϵ']
             such that [μ] is the declared variables from lifting [e] *)
          epsilon_env ϵ' env'.
  Proof.
    intros e; induction e using custom_e_ind;
      intros v eps Hev env pkt fe cx Hee; inv Hev;
        try transformExpr_destr; unfold decl_var_env in *;
          cbn in *; try triplet_inv; cbn in *.
    - exists eps. repeat split; eauto. reflexivity.
    - solve_this_stuff_with eps ~{ w VW n }~.
      repeat split; eauto; unfold epsilon_env in *.
      + apply Env.find_none_bind_sub_env.
        apply Hee. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Hee. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - solve_this_stuff_with eps ~{ w VS n }~.
      repeat split; eauto; unfold epsilon_env in *.
      + apply Env.find_none_bind_sub_env.
        apply Hee. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Hee. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - exists eps. repeat split; auto. reflexivity.
    - admit.
    - admit.
    - admit.
    - pose proof IHe1 v1 eps H6 env pkt fe cx Hee as IH1; clear IHe1.
      transformExpr_destr_hyp.
      destruct IH1 as (eps'1 & Hs1 & Hv1 & Hsub1 & Henv1).
      assert (Hepst1 : epsilon_env eps t0).
      { apply epsilon_env_leq with env; auto.
        apply f_equal with (f := snd) in Heqp0; cbn in *.
        rewrite <- Heqp0. auto using TransformExpr_env_inc. }
      pose proof IHe2 v2 eps H7 t0 pkt fe cx Hepst1 as IH2; clear IHe2.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH2 as (eps'2 & Hs2 & Hv2 & Hsub2 & Henv2).
      solve_this_stuff_with eps'2 v.
      repeat split; eauto; unfold epsilon_env in *.
      + apply sbs_seq_cont with (ϵ' := eps'2) (pkt' := pkt).
        * apply sbs_seq_cont with (ϵ' := eps'1) (pkt' := pkt); auto.
          (* need lemma about statement evaluation & ⊆. *) admit.
        * constructor; auto.
          econstructor; eauto.
          (* need lemma about expression evaluation & ⊆. *) admit.
      + transitivity eps'2; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv2. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv2. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
          (*
    - pose proof IHev env pkt fe cx Hee as IH; clear IHev.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH as (eps' & Hs & Hv & Hsub & Henv).
      solve_this_stuff_with eps' v'.
      repeat split; eauto; unfold epsilon_env in *.
      + transitivity eps'; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - pose proof IHev env pkt fe cx Hee as IH.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH as (eps' & Hs & Hv & Hsub & Henv).
      solve_this_stuff_with eps' v'.
      repeat split; eauto; unfold epsilon_env in *.
      + transitivity eps'; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - exists eps. repeat split; auto. reflexivity.
    - exists eps. repeat split; auto. reflexivity.
    - pose proof IHev env pkt fe cx Hee as IH; clear IHev.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH as (eps' & Hs & Hv & Hsub & Henv).
      solve_this_stuff_with eps' v'.
      repeat split; eauto; unfold epsilon_env in *.
      + transitivity eps'; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - pose proof IHev1 env pkt fe cx Hee as IH1; clear IHev1.
      transformExpr_destr_hyp.
      destruct IH1 as (eps'1 & Hs1 & Hv1 & Hsub1 & Henv1).
      assert (Hepst1 : epsilon_env eps t1).
      { apply epsilon_env_leq with env; auto.
        apply f_equal with (f := snd) in Heqp0; cbn in *.
        rewrite <- Heqp0. auto using TransformExpr_env_inc. }
      pose proof IHev2 t1 pkt fe cx Hepst1 as IH2; clear IHev2.
      transformExpr_destr_hyp; triplet_inv.
      destruct IH2 as (eps'2 & Hs2 & Hv2 & Hsub2 & Henv2).
      solve_this_stuff_with eps'2 v.
      repeat split; eauto; unfold epsilon_env in *.
      + apply sbs_seq_cont with (ϵ' := eps'2) (pkt' := pkt).
        * apply sbs_seq_cont with (ϵ' := eps'1) (pkt' := pkt); auto.
          (* need lemma about statement evaluation & ⊆. *) admit.
        * constructor; auto.
          (* need lemma about expression evaluation & ⊆. *) admit.
      + transitivity eps'2; auto.
        apply Env.find_none_bind_sub_env.
        apply Henv2. lia.
      + intros k Hk.
        unfold VarNameGen.new_var, fst in *.
        rewrite Env.bind_complete.
        * apply Henv2. lia.
        * intros Hwah.
          apply string_append_inj_l in Hwah.
          apply string_of_unit_of_to_uint_inj in Hwah.
          lia.
    - pose proof IHev env pkt fe cx Hee as IH; clear IHev.
      transformExpr_destr_hyp; triplet_inv.
      firstorder eauto.
    - admit.
    - admit.
    - admit.
    - admit.
    - pose proof IHevss env pkt fe cx Hee as IH; clear IHevss.
      transformExpr_destr_hyp; triplet_inv.
      firstorder eauto. *)
  Admitted.
End Correct.
