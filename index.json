[
{
	"uri": "https://cornell-netlab.github.io/petr4/installation/",
	"title": "Installing Petr4",
	"tags": [],
	"description": "",
	"content": "Petr4 is available pre-built in a VM or as an OPAM package. The OPAM package can be built from the version published on opam.ocaml.org/packages or it can be built from the Petr4 git repository directly.\nInstalling the VM  Install VirtualBox or your preferred virtualization software capable of running .ova files. Download the VM image from Zenodo [TODO:link when VM is ready and uploaded]. Boot the VM image. The username is petr4 and the password is petr4. There should be a prebuilt version of petr4 installed and the source code is checked out in the VM user\u0026rsquo;s home directory.  Installing the OPAM package   Install OPAM 2 following the official OPAM installation instructions. Make sure opam --version reports version 2 or later.\n  Check the installed version of OCaml:\nocamlc -v If the version is less than 4.09.0, upgrade:\nopam switch create 4.09.0 ocaml-base-compiler.4.09.0   Install external dependencies:\nsudo apt-get install m4 libgmp-dev   Installing from source   Check out p4pp and install it with opam pin add p4pp \u0026lt;path to root of p4pp repo\u0026gt;.\n  Check out petr4 and install it with opam pin add petr4 \u0026lt;path to root of petr4 repo\u0026gt;.\n  Installing from OPAM   opam install petr4 Note that if you\u0026rsquo;ve previously installed petr4 using opam pin, this will use the pinned (local) package rather than the version on OPAM. If you change your mind, use opam unpin petr4.  "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/claims/",
	"title": "Verifying claims from the POPL&#39;21 paper",
	"tags": [],
	"description": "",
	"content": "Claims The following claims from section 5 (\u0026ldquo;Evaluation\u0026rdquo;) should be verifiable using the artifact.\n We run a test suite totaling 792 tests from p4c. All 792 of the tests pass the parser. Only 782 pass the typechecker. The 10 typechecker failures may be attributed to the following limitations.  A lexer bug regarding casts applied to function calls. The use of @optional argument annotations. Tests expecting certain numeric casts to fail, rather than only issue a warning. (The spec only requires implementations to issue warnings for these casts.) p4c rejects programs that shadow names, while the petr4 implementation allows shadowing. Petr4\u0026rsquo;s implicit cast insertion algorithm may turn a bad divisor (a negative signed integer) into one that typechecks (an unsigned, hence positive integer) where p4c\u0026rsquo;s implicit cast machinery would not. p4c goes beyond the standard P4 type system to enforce special typing constraints for some V1Model constructs, while Petr4 currently provides a target-agnostic type system.   There are 110 other tests left off for their use of the following unsupported features or disagreements with the specification. Some of these are not enumerated in the paper.  Ignores annotations of all types No abstract externs or user-defined initialization blocks for externs Parser value sets Struct flattening in key contexts (not in spec) Generic control and parser declarations (not in spec) Casting int to bool not allowed (not in spec) Enforcing byte alignment of header fields Petr4 does not (and cannot) implement the p4c/bmv2 C++ extension API. Other overly permissive tests which pass only for p4c\u0026rsquo;s spec violating behavior Other overly strict tests which fail despite spec-compliant behavior from petr4   There are 121 tests from p4c including STF so they can be used to test the Petr4 interpreter. Of these, 26 are excluded, for the following reasons.  Unimplemented architectures like PSA and ubpf. Some unimplemented v*odel and ebpf externs: meters, direct-mapped objects, multicast, CRC16 checksums, and others. Empty STF files that do nothing.   There are 40 additional custom tests we wrote, all of which pass.  Checking the claims To run the test suite, open a terminal in the root of the petr4 repository and run the following command.\nmake claims It should produce this output.\nRunning test suite. This will take a few minutes... 792 parser tests 792 passed 0 failed 792 typechecker tests 782 passed 10 failed [Run `grep -R FAIL /home/ryan/dev/petr4-aux/test/_build/_tests/4BC654C2-965B-45E1-83A6-E5EEF138A21D` to see which.] 95 p4c STF tests 95 passed 0 failed 40 custom STF tests 40 passed 0 failed 91 excluded [See examples/checker_tests/excluded.] 27 with STF The tally of excluded checker tests (91) differs from the paper\u0026rsquo;s claim (110) because the paper counted individual files as test. There is a single test case fabric.p4 which uses 18 additional P4 files under the directory examples/checker_tests/excluded/good/include, but is counted as a single test by the test framework because the support files cannot be run on their own.\nThe tally of excluded STF tests (27) differs from the paper\u0026rsquo;s claim (26). This seems to be an error and will be corrected in the camera-ready version.\n"
},
{
	"uri": "https://cornell-netlab.github.io/petr4/usage/",
	"title": "Using Petr4",
	"tags": [],
	"description": "",
	"content": "Functionality: Reproducing Results from POPL \u0026lsquo;21 paper Oops, the stuff in \u0026ldquo;Claims\u0026rdquo; should go here.\nReusability: Petr4 provides a reference interpreter that runs P4 programs but can also serve as a useful frontend for P4 tools or as a testbed for new features.\nRunning P4 programs with Petr4 Before Petr4 can run a P4 program you have to provide it a control plane configuration and a packet in the STF (Simple Test Framework) format, which is described in the next section. Assuming you have a program file.p4 and STF configuration file.stf, you can run it as follows.\npetr4 stf -I examples -stf file.stf file.p4 The -I command sets the include path for petr4 to the examples directory in the Petr4 repository, which is where the standard library headers are kept.\nWriting STF Here are the first few lines of the examples/lpm-example-for-artifact-eval.stf STF script, which is representative of the form of most STF files: a prelude adding rules to tables followed by some test packets.\nadd t_lpm h.h.key:0x11/0xf0 set_port(x:1) add t_lpm h.h.key:0x12/0xff set_port(x:2) packet 0 0b 11 00 b0 expect 1 0b 11 ** ** $ It adds a rule to the table simple_table, sends a 4-byte packet to the program on port 0, and checks that the packet is emitted on port 1 with its first two bytes unchanged.\nTo run this STF script, use petr4 stf from the root of the petr4 repo.\npetr4 stf -I examples -stf examples/lpm-example-for-artifact-eval.stf examples/lpm-example-for-artifact-eval.p4 STF commands The packet command takes a port number and then a packet. Spaces in packets are ignored and should be used to group bytes or headers for legibility.\nThe expect command takes a port and then a packet pattern. Spaces in packet patterns are ignored. Asterisks match anything. By default pattern matching just checks prefixes, so a pattern FF would match a packet FFFF. Adding a $ at the end of the packet will restrict the match to the entire packet.\nThe format of an add command is add table_name key:match\u0026hellip;key:match action. The table_name should refer to a table in the P4 program being tested or run. STF permits writing a list of matches in an add command without the key: parts because the list of keys can be determined from the table declaration in P4. The P4 table declaration will contain a list of keys marked with match kinds (e.g., exact or ternary). There should be one key:match expression in an add rule for each key in the table\u0026rsquo;s keys property. Each match should be formatted appropriately for the given match kind.\nMatch kinds There are three match kinds: exact, ternary, and lpm (longest prefix match). Each has an associated format for writing matches in STF.\nFor an exact key, the match should be an integer constant in hexadecimal. In our example above, the key is an exact key and the match is 0x55.\nFor a ternary key, the match can also include asterisks * to indicate bits that can match anything. For example, 0xFF** will match any two-byte key with FF in the first byte.\nFor an lpm key, the match should be two integer constants separated by a slash /. The constant after the slash is the mask, which may be familiar from IPv4 configuration: a mask 0xFFFFFF00 corresponds to setting your IPv4 subnet to 255.255.255.0. The semantics of LPM is, as the name suggests, to follow the match-action rule which matches the longest prefix of the key. So if several value-mask pairs match the key but one has a longer mask, that\u0026rsquo;ll be the preferred rule (with ties broken by rule insertion order).\nUnderstanding the architecture of Petr4 [Nate: describe ASTs in here]\n -- "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/contributors/",
	"title": "Contributors",
	"tags": [],
	"description": "",
	"content": " Ryan Doenges, Cornell University Mina Tahmasbi Arashloo, Cornell University Santiago Bautista, ENS Rennes Alexander Chang, Cornell University Newton Ni, Cornell University Samwise Parkinson, Cornell University Rudy Peterson, Cornell University Alaia Solko-Breslin, Cornell University Amanda Xu, Cornell University Nate Foster, Cornell University  "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cornell-netlab.github.io/petr4/",
	"title": "Petr4: Formal Foundations for P4 Data Planes",
	"tags": [],
	"description": "[insert short description]",
	"content": "[insert abstract] Goals   Goal1  [describe Goal1]      Goal2  [describe Goal2]      Goal3  [describe Goal3]     "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
