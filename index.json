[
{
	"uri": "https://cornell-netlab.github.io/petr4/installation/",
	"title": "Installing Petr4",
	"tags": [],
	"description": "",
	"content": "Petr4 is available pre-built in a VM or it may be built from source.\nInstalling the VM  Install VirtualBox or your preferred virtualization software capable of running .ova files. Download the VM image from Box. It is a 1.4GB file and should not take too long to download. Boot the VM image. The username is petr4 and the password is petr4. There is a prebuilt version of petr4 installed and the source code is checked out in ~/petr4.  Installing from source Make sure you have a local copy of the Petr4 and P4pp (P4 Preprocessor) repositories.\ngit clone git://github.com/cornell-netlab/petr4 git clone git://github.com/cornell-netlab/p4pp Installing dependences   Install OPAM 2 following the official OPAM installation instructions. Make sure opam --version reports version 2 or later.\n  Check the installed version of OCaml:\nocamlc -v If the version is less than 4.09.0, upgrade:\nopam switch create 4.09.0 ocaml-base-compiler.4.09.0   Install external dependencies:\nsudo apt-get install m4 libgmp-dev   Building Petr4 Run the following steps first for p4pp and then for petr4. The p4pp package is a dependency of petr4.\n  Use OPAM to install OCaml library dependencies.\nopam install . --deps-only   Build binaries using the supplied Makefile.\nmake   Install the binaries in your local OPAM directory.\nmake install   "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/claims/",
	"title": "Verifying claims from the POPL&#39;21 paper",
	"tags": [],
	"description": "",
	"content": "Claims The following claims from section 5 (\u0026ldquo;Evaluation\u0026rdquo;) should be verifiable using the artifact.\n We run a test suite totaling 792 tests from p4c. All 792 of the tests pass the parser. Only 782 pass the typechecker. The 10 typechecker failures may be attributed to the following limitations.  A lexer bug regarding casts applied to function calls. The use of @optional argument annotations. Tests expecting certain numeric casts to fail, rather than only issue a warning. (The spec only requires implementations to issue warnings for these casts.) p4c rejects programs that shadow names, while the petr4 implementation allows shadowing. Petr4\u0026rsquo;s implicit cast insertion algorithm may turn a bad divisor (a negative signed integer) into one that typechecks (an unsigned, hence positive integer) where p4c\u0026rsquo;s implicit cast machinery would not. p4c goes beyond the standard P4 type system to enforce special typing constraints for some V1Model constructs, while Petr4 currently provides a target-agnostic type system.   There are 110 other tests left off for their use of the following unsupported features or disagreements with the specification. Some of these are not enumerated in the paper.  Ignores annotations of all types No abstract externs or user-defined initialization blocks for externs Parser value sets Struct flattening in key contexts (not in spec) Generic control and parser declarations (not in spec) Casting int to bool not allowed (not in spec) Enforcing byte alignment of header fields Petr4 does not (and cannot) implement the p4c/bmv2 C++ extension API. Other overly permissive tests which pass only for p4c\u0026rsquo;s spec violating behavior Other overly strict tests which fail despite spec-compliant behavior from petr4   There are 121 tests from p4c including STF so they can be used to test the Petr4 interpreter. Of these, 26 are excluded, for the following reasons.  Unimplemented architectures like PSA and ubpf. Some unimplemented v*odel and ebpf externs: meters, direct-mapped objects, multicast, CRC16 checksums, and others. Empty STF files that do nothing.   There are 40 additional custom tests we wrote, all of which pass.  Checking the claims To run the test suite, open a terminal in the root of the petr4 repository and run the following command.\nmake claims It should produce this output.\nRunning test suite. This will take a few minutes... 792 parser tests 792 passed 0 failed 792 typechecker tests 782 passed 10 failed [Run `grep -R FAIL /home/ryan/dev/petr4-aux/test/_build/_tests/4BC654C2-965B-45E1-83A6-E5EEF138A21D` to see which.] 95 p4c STF tests 95 passed 0 failed 40 custom STF tests 40 passed 0 failed 91 excluded [See examples/checker_tests/excluded.] 27 with STF The tally of excluded checker tests (91) differs from the paper\u0026rsquo;s claim (110) because the paper counted individual files as test. There is a single test case fabric.p4 which uses 18 additional P4 files under the directory examples/checker_tests/excluded/good/include, but is counted as a single test by the test framework because the support files cannot be run on their own.\nThe tally of excluded STF tests (27) differs from the paper\u0026rsquo;s claim (26). This seems to be an error and will be corrected in the camera-ready version.\n"
},
{
	"uri": "https://cornell-netlab.github.io/petr4/usage/",
	"title": "Using Petr4",
	"tags": [],
	"description": "",
	"content": "Petr4 provides a reference interpreter that runs P4 programs but can also serve as a useful frontend for P4 tools or as a testbed for new features.\nBefore Petr4 can run a P4 program you have to provide it a control plane configuration and a packet in the STF (Simple Test Framework) format, which is described in the next section. Assuming you have a program file.p4 and STF configuration file.stf, you can run it as follows.\npetr4 stf -I examples -stf file.stf file.p4 The -I command sets the include path for petr4 to the examples directory in the Petr4 repository, which is where the standard library headers are kept.\nWriting STF Here are the first few lines of the examples/lpm-example-for-artifact-eval.stf STF script, which is representative of the form of most STF files: a prelude adding rules to tables followed by some test packets.\nadd t_lpm h.h.key:0x11/0xf0 set_port(x:1) add t_lpm h.h.key:0x12/0xff set_port(x:2) packet 0 0b 11 00 b0 expect 1 0b 11 ** ** $ It adds a rule to the table simple_table, sends a 4-byte packet to the program on port 0, and checks that the packet is emitted on port 1 with its first two bytes unchanged.\nTo run this STF script, use petr4 stf from the root of the petr4 repo.\npetr4 stf -I examples -stf examples/lpm-example-for-artifact-eval.stf examples/lpm-example-for-artifact-eval.p4 STF commands The packet command takes a port number and then a packet. Spaces in packets are ignored and should be used to group bytes or headers for legibility.\nThe expect command takes a port and then a packet pattern. Spaces in packet patterns are ignored. Asterisks match anything. By default pattern matching just checks prefixes, so a pattern FF would match a packet FFFF. Adding a $ at the end of the packet will restrict the match to the entire packet.\nThe format of an add command is add table_name key:match\u0026hellip;key:match action. The table_name should refer to a table in the P4 program being tested or run. STF permits writing a list of matches in an add command without the key: parts because the list of keys can be determined from the table declaration in P4. The P4 table declaration will contain a list of keys marked with match kinds (e.g., exact or ternary). There should be one key:match expression in an add rule for each key in the table\u0026rsquo;s keys property. Each match should be formatted appropriately for the given match kind.\nMatch kinds There are three match kinds: exact, ternary, and lpm (longest prefix match). Each has an associated format for writing matches in STF.\nFor an exact key, the match should be an integer constant in hexadecimal. In our example above, the key is an exact key and the match is 0x55.\nFor a ternary key, the match can also include asterisks * to indicate bits that can match anything. For example, 0xFF** will match any two-byte key with FF in the first byte.\nFor an lpm key, the match should be two integer constants separated by a slash /. The constant after the slash is the mask, which may be familiar from IPv4 configuration: a mask 0xFFFFFF00 corresponds to setting your IPv4 subnet to 255.255.255.0. The semantics of LPM is, as the name suggests, to follow the match-action rule which matches the longest prefix of the key. So if several value-mask pairs match the key but one has a longer mask, that\u0026rsquo;ll be the preferred rule (with ties broken by rule insertion order).\n -- "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/targets/",
	"title": "Adding a New Target",
	"tags": [],
	"description": "",
	"content": "The P4 specification leaves some decisions about program structure and semantics up to targets. Petr4 is modular in the same way, for two key reasons: it helps us comply with the specification, and it lets users easily add support for new targets. This will be useful for anyone interested in using Petr4 to test P4 code written in an architecture we do not yet support, or those looking to design a new P4 architecture. Here, we document the process of adding an implementation of a P4 architecture to our interpreter.\nWhat is a P4 architecture? At surface level, an architecture in P4 provides a collection of extern functions/datatypes and defines the user-programmable components of its packet-processing pipeline. However, a closer examination of the the P4 specification reveals that many decisions in the P4 semantics are left up to targets. The architecture\u0026rsquo;s responsibilities include but are not limited to:\n  provide static analysis for enforcing target-dependent well-formedness rules\n  define semantics for initializing metadata\n  provide semantics for threading the packet and other metadata through the pipeline\n  define the behavior of reading from uninitialized/invalid headers\n  provide custom table attributes\n  define custom semantics for the invocation/execution of tables\n  Therefore, an architecture consists of definitions for all of these semantic concerns. Indeed, many of these components correspond directly to values required by our signature for a target implementation.\nAdding to our code The Petr4 interpreter is written as a module functor in the OCaml module system. Before the interpreter can run at all, a target implementor has to provide an implementation of the Target module type and instantiate the interpreter with their target. The specialized module will evaluate programs according to the semantics of the target.\nThe signature for the module type Target is given in lib/target.mli. It is worth noting that there is a large collection of helper functions defined in target.mli which will be available in the newly implemented target. Our own implementations of the V1model and eBPF architectures make use of these. Also provided by target.mli is the abstract type for the state of the program. An implementer will be primarily concerned with the functions insert_extern and find_extern, as they deal with the part of the state which contains all of the target-provided stateful objects.\nWe now step through the process of implementing this signature using the example architecture Very Simple Switch (VSS), a toy architecture that the P4 language specification uses to illustrate the oddities of target-dependent semantics in P4. For reference, the target description file in the P4 code is given below:\n# include \u0026lt;core.p4\u0026gt; typedef bit\u0026lt;4\u0026gt; PortId; const PortId REAL_PORT_COUNT = 4w8; struct InControl { PortId inputPort; } const PortId RECIRCULATE_IN_PORT = 0xD; const PortId CPU_IN_PORT = 0xE; struct OutControl { PortId outputPort; } const PortId DROP_PORT = 0xF; const PortId CPU_OUT_PORT = 0xE; const PortId RECIRCULATE_OUT_PORT = 0xD; parser Parser\u0026lt;H\u0026gt;(packet_in b, out H parsedHeaders); control Pipe\u0026lt;H\u0026gt;(inout H headers, in error parseError, in InControl inCtrl, out OutControl outCtrl); control Deparser\u0026lt;H\u0026gt;(inout H outputHeaders, packet_out b); package VSS\u0026lt;H\u0026gt;(Parser\u0026lt;H\u0026gt; p, Pipe\u0026lt;H\u0026gt; map, Deparser\u0026lt;H\u0026gt; d); extern Checksum16 { Checksum16(); void clear(); void update\u0026lt;T\u0026gt;(in T data); void remove\u0026lt;T\u0026gt;(in T data); bit\u0026lt;16\u0026gt; get(); } First, the user must provide the type obj, which will be used to represent target-provided stateful values. In the case of VSS, only one such data structure is needed \u0026ndash; the underlying value of the Checksum16 extern. Some other commonly used externs include counter and register arrays, as in V1 Model. The types state and extern are parameterized on the type obj and should be copied into the implementation as they appear in the signature.\nThe user must also provide the functions write_header_field and read_header_field. These functions will be called by the main interpreter when reading and writing to headers, and they are intended to capture the fact that the semantics in these cases is left target-dependent by the P4 specification. However, the abstraction in its current form is not necessarily expressive enough to capture all possible decisions for header reads and writes. The average user will likely want to reuse our implementations of these functions in v1model.ml and ebpf.ml.\nThe next required value is the eval_extern function. This function takes as its arguments the name of the extern to evaluate, the envrionment and state, the type arguments of the extern call (e.g. a concrete value for T in the case of update and remove in VSS provided by the type checker), and the arguments paired with their types. For implementation, we may assume that the arguments are provided in the correct order and that the list is the proper length. The is also the place where we use the number and types of the arguments to distinguish between different externs of the same name, as permitted by the P4 specification. Note that in the case of an invocation of an extern function using dot-notation, e.g. checksum.clear(), the value of checksum will be available as the addition first argument in the list of arguments. The extern evaluation should then return as a tuple the updated environment (though most externs do not change the environment), the update state, a signal (almost always Continue), and the return value. Implementing the externs will require some degree of familiarity with our types for values, environments, and states. Also, note that any mutation of an extern object should be done by updating the mapping in the state via insert_extern.\nThe target must also define what meta-data to initialize. Most targets initialize metadata upon packet ingress for each individual packet, consisting at least of the port number. The current version of our interpreter takes as input this port number, and it is provided as an argument to initialize_metadata. Note that the current architecture is not expressive enough to capture all values one may wish to include in the metadata, such as time stamps.\nWe also include a post-processing step, get_outport, which is intended to examine the state and environment for the metadata at the end of the packet-processing pipeline in order to decide on which port number the P4 program has determined the packet should be emitted.\nLastly, the target implementation should provide the function eval_pipeline, which determines how the components of the main P4 package should interact in order to process a given packet. The pipeline evaluator takes as inputs the control-plane configuration, initial environment and state, and the packet, outputting the updated state, environment, and optional packet (no packet corresponds to the packet having been dropped). The astute reader will notice the mysterious final argument of type state apply. This function is the only piece of the interpreter which we were unable to move into target.ml due to a circular dependency, so the interpreter passes it to the pipeline evaluator as an argument. A typical implementation of a pipeline will normally invoke this apply function on the packet and the other required arguments to the parser(s) and control(s). Because the target is responsible for providing arguments to its P4-programmable blocks, this will involve constructing values of our value type explicitly and loading them into the environment and state. The user should be careful to choose variable names that will not result in naming conflicts. In the case of VSS, an implementation will need to pass a packet value and an uninitialized header to the parser, pass the resulting headers, error, and metadata to the control, and finally pass the updated packet and metadata to the deparser, returning the updated state, environment and packet.\nThe final step is to apply the Corize functor from lib/p4core.ml to your new target to ensure that it provides the standard operations on packets provided by the core library in addition to its own externs (this is a single line at the bottom of your newly implemented target). Then, apply the MakeInterpreter functor from lib/eval.mli to your corized target in a new line at the bottom of eval.ml(i) to instantiate the semantics of P4 on your custom interpreter! This provides you with the library of evaluation functions given in lib/eval.mli which you may use to process individual packets on custom control-plane configurations.\nSupported Architectures Petr4\u0026rsquo;s implementation currently supports the V1 Model architecture, which is perhaps the most widely used architecture in P4. It is standard to bmv2, and much of the benchmark suite from P4c is written in the V1 model. Many of the standard operations we may expect a network device to perform are expressed in the V1 model\u0026rsquo;s extern library, and it\u0026rsquo;s pipeline is representative of the structure of a standard packet-processing pipeline.\nWe also support the eBPF Filter architecture. This is a much smaller architecture, with a minimal collection of externs and a pipeline consisting of only two components. This is supported primarily for proof-of-concept that our abstraction over targets is powerful enough to describe more than only the V1 model.\nThe code that implements the externs and the pipelines of the V1 model and the eBPF filter can be found in lib/v1model.ml and lib/ebpf.ml respectively. The implementation of ebpf.ml in particular may be a good reference point for someone seeking to implement their own target.\nLimitations There are two main ways in which our current implementation fails to capture the full expressivity of the P4 abstract machine. First, our implementation has no support for concurrency, and we only consider single-packet execution with a mostly static control-plane configuration. Some important externs from the V1 model library that have to do with concurrency and multiple packets (such as clone and resubmit) are unimplemented in v1model.ml. Second, our abstraction excludes from consideration some important concerns about target-dependent semantics in P4. Specifically, while we provide minimal support for target-dependent decisions about invalid headers, our abstraction is not expressive enough to describe all possible decisions a target may make about accessing invalid header fields, header union, uninitialized stack accesses, etc. We also omit target-dependent table behaviors such as certain table annotations or custom table attributes.\n -- "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/contributors/",
	"title": "Contributors",
	"tags": [],
	"description": "",
	"content": " Ryan Doenges, Cornell University Mina Tahmasbi Arashloo, Cornell University Santiago Bautista, ENS Rennes Alexander Chang, Cornell University Newton Ni, Cornell University Samwise Parkinson, Cornell University Rudy Peterson, Cornell University Alaia Solko-Breslin, Cornell University Amanda Xu, Cornell University Nate Foster, Cornell University  "
},
{
	"uri": "https://cornell-netlab.github.io/petr4/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cornell-netlab.github.io/petr4/",
	"title": "Petr4: Formal Foundations for P4 Data Planes",
	"tags": [],
	"description": "[insert short description]",
	"content": "P4 is a domain-specific language for specifying the behavior of packet-processing systems. It is based on an elegant design with high-level abstractions, such as parsers and match-action pipelines, which can be compiled to efficient implementations in hardware or software. Unfortunately, like many industrial languages, P4 lacks a formal foundation. The P4 specification is a 160-page document with a mixture of informal prose, graphical diagrams, and pseudocode. The reference compiler is complex, running to over 40KLoC of C++ code. Clearly neither of these artifacts is suitable for formal reasoning.\nThis project presents a new framework, called Petr4, that puts P4 on a solid foundation. Petr4 uses standard elements of the semantics engineering toolkit, namely type systems and operational semantics, to build a compositional semantics that assigns an unambiguous meaning to every P4 program. Petr4 is implemented as an OCaml prototype that has been validated against a suite of over 750 tests from the reference implementation. While developing Petr4, we discovered dozens of bugs in the language specification and the reference implementation, many of which have been fixed. Furthermore, we have used Petr4 to establish the soundness of P4’s type system, prove key properties such as termination, and formalize a language extension.\n"
},
{
	"uri": "https://cornell-netlab.github.io/petr4/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
